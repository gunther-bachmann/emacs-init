#+title: init.el
#+property: spellcheck no
#+property: readonly yes
#+property: header-args :tangle ~/.emacs.d/init.el :comments org 
#
# execute org-babel-tangle to actually export the code into a init.el (directly into the emacs directory)
#   c-c c-v t  (org-babel-tangle)
#
# on first run
#   - an error occurs (error "no executable `epdfinfo' found") when installing pdf-tools
#     just answer the upcoming question whether to compile pdf-tools with 'yes'
#     and wait until buffer *compile pdf-tools* reports compilation finished
#     restart emacs: the error should not come up any more!
#
# make sure to take a look at the message buffer
#   - entries with 'preinstall' mark packages that are installed up front
#   - entries with 'ok: ... installed' mark checks for external programs that are needed for some packages to work
#
* preset
  - things to setup before anything else happens
  #+BEGIN_SRC emacs-lisp
    (setq gb/log-startup-timing nil) ;; set true for timing messages during startup
    (setq gb/debug-req-package nil) ;; debug req package (look into message buffer)

    (setq gb/time (float-time))

    (setq gc-cons-threshold 800000000)

    (defun report-elapsed (msg-prefix)
      "record an message time since last call of this function"
           (if gb/log-startup-timing
               (progn
                 (setq gb/elapsed-time (- (float-time) gb/time))
                 (setq gb/time (float-time))
                 (message (format "%s: %f seconds" msg-prefix gb/elapsed-time)))))

    (report-elapsed "preset")
  #+END_SRC
* benchmarking
  - simply call M-x profiler-report after loading
  #+BEGIN_SRC emacs-lisp
    (if gb/log-startup-timing
      (profiler-start 'cpu))
  #+END_SRC
* info
  - information about this file and usages of certain functionalities
** el-get packages
   - example of how to load packages dynamically via el-get from git sources
   #+BEGIN_SRC emacs-lisp :tangle no
     (el-get-bundle org-brain
       :url "https://github.com/Kungsgeten/org-brain.git"
       :features org-brain)
     (if (el-get-package-is-installed 'org-brain)
         (el-get 'sync 'org-brain))
     (req-package org-brain
       :loader :el-get
       :require org dash helm-org-rifle
       :commands org-brain-open org-brain-visualize org-brain-insert-link
       :config
       (progn
         (setq org-brain-path "~/brain")
         (if (not (file-exists-p org-brain-path))
             (make-directory org-brain-path t))
         (defun helm-org-rifle-brain ()
           "Rifle files in `org-brain-path'."
           (interactive)
           (helm-org-rifle-directories (list org-brain-path)))))
   #+END_SRC
** req-package
*** deferred loading with arbitrary key binding (even key chords are this possible)
   - this code:
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package ace-jump-mode
     :defer t ;; valid because of key registration in init
     :init
     (autoload 'ace-jump-mode "ace-jump-mode" nil t)
     (bind-key "c-." 'ace-jump-mode))
   #+END_SRC
   - is equivalent with this code (loading is done when the key is used)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package ace-jump-mode
     :bind (("c-." . ace-jump-mode)))
   #+END_SRC
** helm locate
   helm uses /usr/bin/locate to actually provide a list of possible candidates.  the configuration goes into /etc/locate.rc (open within
   /sudo::/etc/locate.rc).
** helm-m-x 
*** command history
    - is saved in extended-command-history and saved through the
      package 'session' which stores lots of session information into
      the file .session in the .emacs.d
* enhancements and todos
  list of todos and enhancements to be implmented, checked, verified (some day)
** TODO switch gnus mail sync with google calendar to org-gcal
** TODO lsp-mode: check what packages have to be deactivated in order to not interfere with lsp-mode and company suggestions
** TODO allow duplex/non-duplex configuration of printer / printing (see org header "printer")
** TODO minimap mode results in ligatures being misplaced!
** IMPLEMENT describe each packages' benefit for my configuration
** TODO define something like layers
   e.g. layer for core, editing, navigation, programming ... such that these layers can be easily switched off and on at the top of the init
   file
** IMPLEMENT find keybinding for jumplist, complete jumplist-hook-commands
   - state "implement"  from "todo"       [2015-11-16 mon 12:58]
** IMPLEMENT list modes actually in use and think about optimal key/function binding
   - state "implement"  from "planned"    [2016-11-28 mon 08:08]
*** gnus
*** elfeed
*** paradox
*** org
**** org babel
**** org timers
*** latex
*** clojure
*** java
*** java script
*** docker
** TODO elfeed: filter news depending on title/feed/url etc.
   - state "test"       from "todo"       [2016-04-08 fri 15:55]
** TEST amplify org-mode
   #+BEGIN_SRC emacs-lisp :tangle no
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; org-mode agenda options                                                ;;
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;don't show tasks as scheduled if they are already shown as a deadline
     (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
     ;;don't give awarning colour to tasks with impending deadlines
     ;;if they are scheduled to be done
     (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
     ;;don't show tasks that are scheduled or have deadlines in the
     ;;normal todo list
     (setq org-agenda-todo-ignore-deadlines (quote all))
     (setq org-agenda-todo-ignore-scheduled (quote all))
     ;;sort tasks in order of when they are due and then by priority
     (setq org-agenda-sorting-strategy
       (quote
        ((agenda deadline-up priority-down)
         (todo priority-down category-keep)
         (tags priority-down category-keep)
         (search category-keep))))
   #+END_SRC
** PLANNED explore org-contacts as bbdb replacement (look [[https://julien.danjou.info/projects/emacs-packages#org-contacts][here]] and [[http://kitchingroup.cheme.cmu.edu/blog/2016/12/22/context-specific-org-mode-speed-keys/?utm_source=feedburner&utm_medium=twitter&utm_campaign=feed:+thekitchinresearchgroup+(the+kitchin+research+group)][here]])
** PLANNED add additional modes to store linenumbers when capturing
   [[file:~/.emacs.d/init.el::org-file-lineno-store-link][file:~/.emacs.d/init.el::org-file-lineno-store-link]]
** PLANNED install xcape into the linux installtions to allow for using space as control where possible
   - configuring needs to be streamlined to allow space-down key-down key-up space-up to work as control
   - all other uses (especially space-down key-down space-up key-up should function as space then key) should work as with normal space mapping
** PLANNED rebind C-x C-k keymacros to some other binding (since C-x C-k is used for killing buffers and windows)
** PLANNED define additional capture templates
   [[file:~/.emacs.d/init.el::org-capture-templates][file:~/.emacs.d/init.el::org-capture-templates]]
** PLANNED adjust selfinsertion commands to put the charater where expected (depending on the mode)
   - see http://mbork.pl/2015-10-31_Smart_comma_and_other_punctuation
** PLANNED define hydra for dired
** PLANNED define hydra for pdf-tools
** DONE check magit ediffing with exwm, seems to have trouble with control window!
   - State "DONE"       from "TODO"       [2017-11-16 Thu 06:52]
** DONE synchronise linux and mac os x init
   - State "DONE"       from "IMPLEMENT"  [2017-10-04 Wed 21:47]
   - state "implement"  from "todo"       [2017-01-27 fr 20:02]
*** todo some org-babel packages are not resolved during bootstrap of init.el (sed, shell, groovy)
*** todo loadpath dependencies that should be resolved
    - ob-clojure
    - javad
    - gnus-calendar
    - ox-confluence (obsolete)
    - org-jekyl (obsolete)
*** done require the emacs package manager, add available repositories and intialize packet manager
    make sure that the initial (minimal set) packages needed are all loaded
    - dash
    - maxframe
    - bind-key
    - key-chord
    - benchmark (currently via loadpath)
** DONE undo-tree workaround: [2017-02-25 Sat] currently org src block fontification is disabled if undo tree is called, since undo tree exits on up/down in the tree
** DONE disable smart region '/' in gnus (since / is used to narrow selection and is not used to surround selected text in this context)
** DONE commit message should not store any cursor position info but should always start at the beginning of the buffer
   - session does probably store this position even though COMMIT_EDITMSG is explicitly excluded from this behaviour
   - look at M-x customize-group session-name  session-name-disable-regexp
** DONE todo define keybindings depending on keyboard layout => e.g. key-chords won't make sense in us-keyboard layout
   - State "DONE"       from              [2017-06-26 Mon 16:45]
** DONE pixel wise scrolling
   - look at sublimity defvar 'sublimity--post-vscroll-functions' which is called for scrolling with the amount of lines to actually scroll
     (negative for up). this could be used to actually call pixelwise scrolling on the last line of the scroll action which would make the
     scrolling much more smooth.
** DONE selected workaround: [2017-02-22 Wed] reactivate package selected, currently running in an error, thus expand/contract region does not work anymore
** DONE extend check prerequisites to check multiple programs to exist
** DONE copy windows setup into separate region
   - State "DONE"       from "IMPLEMENT"  [2017-02-18 Sa 06:37]
   - State "IMPLEMENT"  from "TODO"       [2017-02-14 Di 15:57]
** DONE check gnus with extended setup
   - State "DONE"       from "TODO"       [2016-12-23 Fr 12:04]
** DONE when in multicursor, hungry delete should fall back to normal delete
   - State "DONE"       from "TODO"       [2016-12-23 Fr 11:47]
   - is there a mc/keymap? there C-d and <BACKSPACE> could be mapped to different functions
** DONE inserting appointments into org-agenda should make it possible to decide into which calendar this should go
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:49]
** DONE make sure that proportional font is not bold!
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:30]
** DONE remove bind-key with req-package :bind entries, since these bindings will result in loading the package (if not present yet)!
   - State "DONE"       from "IMPLEMENT"  [2016-11-28 Mon 08:07]
   - State "IMPLEMENT"  from "TODO"       [2016-11-06 So 18:12]
** DONE plantuml-mode and puml-mode are both installed, only one should reside
   - State "DONE"       from "TODO"       [2016-11-28 Mon 08:06]
** DONE put this file into version control
   - State "DONE"       from "TODO"       [2016-11-06 So 18:20]
** OBSOLETE todo accepting invitations go into agenda, syncing google calendar goes into gcal
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:45]
   it seems that accepted invitations (accepted within emacs from mail) does not correctly sync with google calendar
** OBSOLETE todo move diminish at the end of file to the respective packages
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:44]
* initial unsetting of global keys
  #+BEGIN_SRC emacs-lisp
    (global-unset-key "\C-z")     ;; (now mapped to prefix -- dash)
    (global-unset-key "\C-x\C-k") ;; keyboard makros prefix (now mapped to kill buffer)
    (global-unset-key "\M-%")     ;; replaced by visual-regexp ...
    ;; unbind super key bindings with the given keys
    (dolist (key '(& \, \^ \` \| \~ \?))
      (global-unset-key (kbd (concat "s-" (symbol-name key))))
      (global-unset-key (kbd (concat "s-" (upcase (symbol-name key))))))
    ;; unbind super key bindings with letters (lower and upper case variant)
    (dotimes (i 26)
      (let ((letter (byte-to-string (+ 65 i))))
        (global-unset-key (kbd (concat "s-" letter)))
        (global-unset-key (kbd (concat "s-" (downcase letter))))))
  #+END_SRC
* check account configuration files
  #+BEGIN_SRC emacs-lisp
    (setq agenda-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/agenda-accounts.el")))
    (setq calendar-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/calendar-accounts.el")))
    (setq mail-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/mail-accounts.el")))
  #+END_SRC
* initial setting of vars
  #+BEGIN_SRC emacs-lisp
    ;; must be set before loading use-package in order to work
    (setq use-package-enable-imenu-support t) ;; enable locating package loaded by use-package within init.el
  #+END_SRC
* initial function setup
  #+BEGIN_SRC emacs-lisp
    (defun is-ms-windows-p ()
      "check whether this system is microsoft windows"
      (if (string-match "windows" (symbol-name system-type))
          t
        nil))

    (defun is-linux-p ()
      "check whether this system is a linux"
      (if (string-match "linux" (symbol-name system-type))
          t
        nil))

    (defun is-macos-p ()
      "check whether this system is mac os"
      (if (string-match "darwin" (symbol-name system-type))
          t
        nil))

    (defun is-_nix-p ()
      "check whether this is a *nix derivative (either linux or macos)"
      (or (is-linux-p) (is-macos-p)))
  #+END_SRC
* proxy setup (if present)
  #+BEGIN_SRC emacs-lisp
    (if (file-exists-p (concat user-emacs-directory "accounts/proxy-account.el"))
        (load-file (concat user-emacs-directory "accounts/proxy-account.el")))
  #+END_SRC
* package setup
#+BEGIN_SRC emacs-lisp
  (report-elapsed "enter package setup")
  (require 'package)

  ;; package access either through secure https, or insecure http
  (setq secure-package-access t)


  (when gb/debug-req-package
    (setq ;; add verbosity to req package
          req-package-log-level 'debug
          ;; add verbosity level to use package
          use-package-verbose t
          ;; make sure that use-package does minimal reporting to the message buffer
          use-package-expand-minimally t))

  (if secure-package-access
      (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                               ("melpa-stable" . "https://stable.melpa.org/packages/")
                               ("org" . "https://orgmode.org/elpa/")
                               ("melpa" . "https://melpa.org/packages/")))
    (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                             ("melpa-stable" . "http://stable.melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("melpa" . "http://melpa.org/packages/"))))

  (setq package-archive-priorities
        '(("melpa-stable" . 20)  ;; stable is preferred
          ("melpa" . 10)
          ("gnu" . 0)))

  (setq package-menu-async (is-_nix-p)) ;; defaulting operations to be async (is problematic on windows systems)

  (package-initialize) ;; cannot use t as parameter since initialization is necessary for init file to work

  (defun require-package (package)
    "refresh package archives, check package presence and install if it's not installed"
    (if (null (require package nil t))
        (progn
          (let* ((ARCHIVES (if (null package-archive-contents)
                               (progn (package-refresh-contents)
                                      package-archive-contents)
                             package-archive-contents))
                 (AVAIL (assoc package ARCHIVES)))
            (if AVAIL
                (package-install package)))
          (require package))))

  (setq package-to-install-initially
        '( dash
           ht
           maxframe
           bind-key
           key-chord
           validate
           use-package
           req-package
           seq
           el-get))

  ;; add mac specific packages
  (when (is-macos-p)
    (add-to-list 'package-to-install-initially 'exec-path-from-shell))

  (dolist (package package-to-install-initially)
    (progn
      (message (concat "Preinstall/require " (symbol-name package)))
      (require-package package)))

  ;; incomplete implementation of layers
  (setq active-layers '(core clojure navigation completion positioning editing))

  ;; cl--parsing-keywords does not function, since splitting is done based on certain keywords
  ;; TODO: do splitting off :layer, extracting layer dependency, reconstruct list fo req-package macro and splice macro in
  ;; do some custom modification to req-package
  (defmacro gb/req-package (pkg &rest cl-keys)
    "wrapping req-package.

  Check for keyword argument ':layer' to be in active-layers list.
  When no :layer is given or given :layer is within active-layers list,
  the package gets /required/, else it will not be /required/."
    (cl--parsing-keywords ((:layer nil)) nil
      (if (or (null cl-layer)
              (memq cl-layer active-layers))
          `(progn
             (message (concat "pacakge '" (symbol-name pkg) "' is required"))
             ,(req-package pkg @cl-keys))
        '(message (concat "package '" (symbol-name pkg) "' is not required, layer '" (symbol-name cl-layer) "' is not part of active-layers.")))))
  (report-elapsed "exit package setup")
#+END_SRC
** paradox (package list alternative)
   #+BEGIN_SRC emacs-lisp 
          (req-package paradox
            :require hydra
            :commands paradox-list-packages
            :bind (:map paradox-menu-mode-map ("<f1>" . hydra-paradox-list-packages/body))
            :init (report-elapsed ":init-enter paradox")
            :config
            (report-elapsed ":config-enter paradox")

            ;; description is pastell sand like color
            (custom-set-faces '(paradox-description-face ((t (:foreground "#e0d0a0")))))
            (progn 
              (let* ((github-token-file "~/.github-token.properties.gpg"))
                (if (file-exists-p github-token-file)
                    (let* ((auth-map (jde-read-properties-file "~/.github-token.properties.gpg")))
                      (setq paradox-github-token (gethash "github-paradox-token" auth-map)))
                  (message "WARNING: github token file not found. paradox-list-packages will have to work without github integration.")))

              (setq paradox-automatically-star nil)
              (when (package-installed-p 'hydra)
                (defhydra hydra-paradox-list-packages ()
                  "
               [_v_] view homepage           [_x_] execute commands
               [_l_] show latest commits     [_i_] install 
                ^ ^                          [_d_] delete
                ^ ^                          [_U_] update all
            %s(hydra-combine-functions-w-key-bindings 
              '((\"    view homepage      \" . paradox-menu-visit-homepage)
                (\"    show latest commit \" . paradox-menu-view-commit-list)
                (\"    execute commands   \" . paradox-menu-execute)
                (\"    install            \" . package-menu-mark-install)
                (\"    delete             \" . package-menu-mark-delete)
                (\"    mark upgrades      \" . package-menu-mark-upgrades)))
            "
                  ("v" paradox-menu-visit-homepage)
                  ("l" paradox-menu-view-commit-list)
                  ("x" paradox-menu-execute :exit t)
                  ("i" package-menu-mark-install )
                  ("d" package-menu-mark-delete)
                  ("U" package-menu-mark-upgrades)
                  ("q" (message "Abort") :exit t))
                ))
            (report-elapsed ":config-exit paradox")
            )
   #+END_SRC
* splash and initial buffer config
#+BEGIN_SRC emacs-lisp
  ;; set scratch window content
  (let* ((total-ram (if (is-macos-p)
                        (/ (string-to-int (shell-command-to-string "sysctl hw.memsize | sed 's/.*:\s*//'")) (* 1024 1024 1024) )
                      (/ (nth 0 (memory-info)) (* 1024 1024))))
         (free-ram (if (is-macos-p) 0 (/ (nth 1 (memory-info)) (* 1024 1024))))
         (total-ram-str (concat (number-to-string total-ram) "GB" ))
         (free-ram-str (if (= 0 free-ram) "LOTS OF" (concat (number-to-string free-ram) "GB" )))
         (len-avail-for-memory (+ (length emacs-version) 1))
         (len-needed-for-memory (+ (length free-ram-str) (length total-ram-str))))

    (setq initial-scratch-message 
          (propertize (concat ";; ***** FREE SOFTWARE FOUNDATION  EMACS "
                              emacs-version
                              " *****\n;;   "
                              total-ram-str 
                              " RAM SYSTEM" 
                              (make-string (max 2 (- len-avail-for-memory len-needed-for-memory)) ? )
                              free-ram-str
                              " EMACS LISP BYTES FREE\n;; READY\n")
                      ;; properties do not work here, since they are overwritten/not used
                      )))

  ;; make sure no *Messages* buffer is open on startup 
  (add-hook 'window-setup-hook 'delete-other-windows)

  ;; Go strait to scratch buffer on startup
  (setq inhibit-startup-message t)
#+END_SRC
* own utility functions
** misc
   #+BEGIN_SRC emacs-lisp
     (defun re-seq (regexp string &optional matchpos)
       "Get a list of all regexp matches in a string, use matchpos as group index if groups are used!"
       (save-match-data
         (let ((pos-to-match (or matchpos 0))
               (pos 0)
               matches)
           (while (string-match regexp string pos)
             (push (match-string pos-to-match string) matches)
             (setq pos (match-end 0)))
           matches)))
     (rx-to-string `(: bos "prefix"))
     (ert-deftest re-seq-test ()
       "test re-seq (only)"
       (should (let* ((result (re-seq  "\\([0-9]+\\)" "some31and4other")))
                 (and (member "4" result)
                      (member "31" result)
                      (= 2 (length result)))))
       (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother")))
                 (and (member "31and" result)
                      (= 1 (length result)))))
       (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother" 1)))
                 (and (member "31" result)
                      (= 1 (length result))))))

     (defun string/starts-with (string prefix)
       "Return t if string starts with prefix."
       (and (string-match (rx-to-string `(: bos ,prefix) t)
                          string)
            t))

     (defun file-name-from-current-dir (file-name)
       "get given file in the directory of the file currently active"
       (concat (file-name-directory (file-truename (or (concat  "./" file-name) (buffer-file-name (current-buffer))))) file-name))


     (defun get-buffer-file-matching-extension (extension-regex)
       "get all buffers that are associated with a file matching the given extension"
       (--filter (string-match extension-regex (or (file-name-extension it) ""))
                 (remove-if 'null (mapcar 'buffer-file-name (buffer-list)))))

     (defun get-visible-buffer-file-matching-extension (extension-regex)
       "get all buffers visible that are associated with a file matching the given extension"
       (--filter (string-match extension-regex (or (file-name-extension it) ""))
                 (remove-if 'null  (mapcar 'buffer-file-name (mapcar 'window-buffer (window-list))))))

     (defun spit (contents file-name)
       "Write the given contents into the given file"
       (with-temp-buffer 
         (insert contents)
         (write-file file-name)))

     (defun slurp (file-name)
       "Return file content."
       (with-temp-buffer
         (insert-file-contents file-name)
         (buffer-string)))

     (defun jde-read-properties-file (file-name)
       "read a java properties file and provide a map with key value pairs.
      property files are transformed such that multiline properties are heeded, 
      double colon is heeded and spaces after the key and before the value are 
      discarded."
       (let* ((file-string (slurp file-name))
              (file-string-nomultiline (replace-regexp-in-string "[^\\\\]\\(\\\\\n *\\)" "" file-string nil nil 1)) ;; incomplete! 1)
              (file-string-nobackslash-escaping (replace-regexp-in-string "\\\\\\\\" "\\\\" file-string-nomultiline))
              (file-string-nodoublecolon-and-spaces (replace-regexp-in-string " *\\(:\\|=\\) *" "=" file-string-nobackslash-escaping))
              (prop-matches (re-seq "^[^#!=:][^=:]*\\(=\\|:\\)[^=:\n]+$" file-string-nodoublecolon-and-spaces))
              (hash-map (make-hash-table :test 'equal)))
         (--map 
          (let* ((splitted-prop (split-string it "="))
                 (key (nth 0 splitted-prop))
                 (value (nth 1 splitted-prop)))
            (puthash key value hash-map))
          prop-matches)
         hash-map))
     ;; 1) what should be tested if an unbalanced backslash is present at the end of the line.
     ;;    currently the test checks whether there is a single backslash at the end of the line!

   #+END_SRC
** transparency
   #+BEGIN_SRC emacs-lisp
       (defun disable-transparency ()
         "make emacs solid again"
         (interactive)
         (setq frame-transparency-value 100)
         (set-frame-parameter (selected-frame) 'alpha '(100 100)))

       (defun increase-transparency ()
         "increase current frame transparency"
         (interactive)
         (setq frame-transparency-value (max 35 (- frame-transparency-value 7)))
         (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

       (defun decrease-transparency ()
         "decrease current frame transparency"
         (interactive)
         (setq frame-transparency-value (min 100 (+ frame-transparency-value 7)))
         (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

       (setq frame-transparency-value 100)
       (add-to-list 'default-frame-alist '(alpha 100 100))
   #+END_SRC
** editing
*** comment toggle
    #+BEGIN_SRC emacs-lisp
       (defun toggle-comment-on-line ()
         "comment or uncomment current line"
         (interactive)
         (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
    #+END_SRC
*** dos/windows-eol
    #+BEGIN_SRC emacs-lisp
        (defun remove-dos-eol ()
          "Do not show ^M in files containing mixed UNIX and DOS line endings.
                  This is especially useful when viewing diffs in magit!"
          (interactive)
          (setq buffer-display-table (make-display-table))
          (aset buffer-display-table ?\^M []))
    #+END_SRC
*** query for a word
    #+BEGIN_SRC emacs-lisp
      ;; aktivate through M-s M-w
      (defun gb/eww-search (orig-fun &rest args)
        "query for string if no active region is present"
        (if (region-active-p)
            (apply orig-fun args)
          (eww (read-string "Query: "))))

      (advice-add 'eww-search-words :around #'gb/eww-search) 
    #+END_SRC
*** buffer utils
    #+BEGIN_SRC emacs-lisp
      (defun gb/buffer-contains-string(str)
        "does the current buffer contain the given string?"
        (save-excursion
          (goto-char (point-min))
          (let ((search-result (re-search-forward str nil t)))
            (if search-result (point) nil))))    
    #+END_SRC
** scrolling
   #+BEGIN_SRC emacs-lisp
       (defun scroll-up-line-7 ()
         (interactive)
         (scroll-up-line 7))
       (defun scroll-down-line-7 ()
         (interactive)
         (scroll-down-line 7))

       ;; scroll and move cursor
       (defun scroll-up-line-and-move-cursor ()
         (interactive)
         (scroll-up 1)
         (forward-line 1))

       (defun scroll-down-line-and-move-cursor ()
         (interactive)
         (scroll-down 1)
         (forward-line -1))

       (defun scroll-up-line-and-move-cursor-7 ()
         (interactive)
         (scroll-up-line 7)
         (next-line 7))
  
       (defun scroll-down-line-and-move-cursor-7 ()
         (interactive)
         (scroll-down-line 7)
         (previous-line 7))
   #+END_SRC
** hydra utils
   #+BEGIN_SRC emacs-lisp
    (defun keys-for-function (fun-symbol)
      "find a key binding for the given function
      always returns a string (can be empty)"
      ;; (or (car (car (car (--filter (eq (car (cdr it)) fun-symbol) personal-keybindings)))) "")
      (let ((result (substitute-command-keys (concat "\\[" (symbol-name fun-symbol) "]"))))
        (if (equal (substring result 0 (min (length result) 3)) "M-x")
            ""
          result)))

    (defun hydra-combine-functions-w-key-bindings (pairs)
      "return a string that can be put into hydra menu
      pairs must be a list of tuple of the form ( string . function )
      if a personal keybinding exists the string is concatenated with the 
      keybinding of the respective function. if no keybining exists that
      pair is ignored for the rest of the function. all pairs found relevant
      are combined with line breaks in between.

      example call: (hydra-combine-functions-w-key-bindings 
                       '(( \"some \" . function )
                         ( \"other\" . mc/mark-previous-like-this )))"
      (--reduce 
       (if (eq it nil) "" (format "%s
      %s" acc it)) 
       (-non-nil 
        (--map 
         (let ((kb (keys-for-function (cdr it)))) 
           (if (string-empty-p kb) nil (concat (car it) " <" kb ">")))
           pairs))))
   #+END_SRC
** org utils
   #+BEGIN_SRC emacs-lisp
     (defun gb/execute-startup-block ()
       "execute within this org file the source code block that's named 'startup'"
       (interactive)
       (org-babel-goto-named-src-block "startup")
       (org-babel-execute-src-block))
   #+END_SRC
** ui
   #+BEGIN_SRC emacs-lisp
     (defun gb/kill-a-buffer-and-delete-window (askp)
       "kill the current buffer and remove the window"
       (interactive "P")
       (gb/kill-a-buffer askp)
       ;; only called without prefix argument and not the root window of the frame
       (if (not (or askp (frame-root-window-p (get-buffer-window))))
           (delete-window)))

     (defun gb/kill-a-buffer (askp)
       "kill the current buffer (ask if prefix argument is given)"
       (interactive "P")
       (if askp
           (kill-buffer (ivy-read "Kill buffer: " (mapcar #'buffer-name (buffer-list))))
         (if (string= (buffer-name) "*scratch*") 
             (message "scratch buffer must be killed explicitly (with prefix argument, then selecting the buffer)")
           (kill-this-buffer))))

     (global-set-key (kbd "C-x k") 'gb/kill-a-buffer)
     (global-set-key (kbd "C-x C-k") 'gb/kill-a-buffer-and-delete-window)
   #+END_SRC
** printer
   extensions
   - add options to print black&white, 2sided, on a4, more than 1 pager per paper
   - printing from pdf-tools view uses the following options for printing
     - (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge"))
   - these could be set via function to allow duplex/non-duplex printing
   #+BEGIN_SRC emacs-lisp
     (setq ps-font-size (quote (7 . 6.5)))
     (setq ps-paper-type (quote a4))
     (setq ps-print-header-frame nil)
     (setq ps-print-header nil)
     (defun gb/get-known-printers ()
       "get all printers currently known to the system"
       (let* ((result (shell-command-to-string "lpstat -a | cut -f1 -d ' '"))
              (result-list (split-string result)))
         result-list))

     (defun gb/get-standard-printer ()
       "get the current standard printer"
       (string-trim (shell-command-to-string "lpq | grep -v 'no entries' | awk '{ print $1; }'")))

     (defun gb/set-default-printer (printer-str)
       "set the given printer to the standard printer"
       (shell-command (concat "lpoptions -d " printer-str " -o media=A4"))
       (setq printer-name printer-str)
       (setq ps-printer-name printer-str))

     (defun gb/query-default-printer ()
       "interactively query for the printer that is then set to be the default printer"
       (interactive)
       (let ((printer-name (ivy-read "printer:" (gb/get-known-printers) :preselect (gb/get-standard-printer) :require-match t)))
         (gb/set-default-printer printer-name)))

     (defun gb/print-buffer (x)
       "Output a postscript file using the defaults.

     When called with universal argument, use font lock.
     Ligatures are disabled for printing."
       (interactive "P")
       (let* (reenable-ligatures ligatures-enabled)
         (gb/disable-ligatures)
         (redisplay t)
         (setq ps-top-margin 80)
         (if x
             (ps-print-buffer-with-faces "~/temp.ps")
           (ps-print-buffer "~/temp.ps"))
         (cond
          ((is-macos-p) (shell-command "open /Applications/Preview.app ~/temp.ps"))
          ((file-executable-p "evince") (shell-command "evince ~/temp.ps"))
          (t (message "No viewer for postscript files known to display ~/temp.ps")))
         (gb/enable-ligatures)))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp

     ;; source: https://stackoverflow.com/questions/5580562/formatting-an-integer-using-iso-prefixes-for-kb-mb-gb-and-kib-mib-gib
     (defconst number-to-string-approx-suffixes
       '("k" "M" "G" "T" "P" "E" "Z" "Y"))

     (defun number-to-string-approx-suffix (n &optional binary)
       "Return an approximate decimal representation of NUMBER as a string,
     followed by a multiplier suffix (k, M, G, T, P, E, Z, Y). The representation
     is at most 5 characters long for numbers between 0 and 10^19-5*10^16.
     Uses a minus sign if negative.
     NUMBER may be an integer or a floating point number.
     If the optional argument BINARY is non-nil, use 1024 instead of 1000 as
     the base multiplier."
       (if (zerop n)
           "0"
         (let ((sign "")
               (b (if binary 1024 1000))
               (suffix "")
               (bigger-suffixes number-to-string-approx-suffixes))
           (if (< n 0)
               (setq n (- n)
                     sign "-"))
           (while (and (>= n 9999.5) (consp bigger-suffixes))
             (setq n (/ n b) ; TODO: this is rounding down; nearest would be better
                   suffix (car bigger-suffixes)
                   bigger-suffixes (cdr bigger-suffixes)))
           (concat sign
                   (if (integerp n)
                       (int-to-string n)
                     (number-to-string (floor n)))
                   suffix))))

     (defun sudo-shell-command (command)
       (interactive "MShell command (root): ")
       (with-temp-buffer
         (cd "/sudo::/")
         (async-shell-command command)))

     (defun dont-kill-emacs()
       "Disable C-x C-c binding execute kill-emacs."
       (interactive)
       (error (substitute-command-keys "To exit emacs: \\[kill-emacs]")))
     (bind-key "C-x C-c" 'dont-kill-emacs)

     (defun ibuffer-list-buffers-and-switch ()
       "Shows a list of buffers"
       (interactive)
       (ibuffer-list-buffers)
       (other-window 1))

     (require 'subr-x)
     (defun _nix-program-exists-in-path-p (program-string)
       "Does the given exist as file and is on the path?
          PROGRAM is the name of the program without path, given as string.

          (fn PROGRAM)

          This program won't work in non unix environments.

          the return value is either t or nil."
       (let* ((which-result (shell-command-to-string (concat "which " program-string))))
         (not (or (string-empty-p which-result)
                  (string-match (concat "no " program-string " in") which-result)
                  (string-match "not found"  which-result)))))

     (defun all-files-exist (full-file-string-list)
       "does the given file (list of files, all) exist?
     pass either list of strings or a string."
       (if (stringp full-file-string-list)
           (file-regular-p full-file-string-list)
         (-none-p 'null (-map 'file-regular-p full-file-string-list))))

     (defun all-files-excutable (full-file-string-list)
       "is the given file (list of files, all) executable?
     pass either list of strings or a string."
       (if (stringp full-file-string-list)
           (file-executable-p full-file-string-list)
         (-none-p 'null (-map 'file-executable-p full-file-string-list))))

     (defun all-_nix-program-exists-in-path-p (program-string)
       "make sure that the PROGRAM-STRING exists as executable reachable for unix.
     If PROGRAM-STRING is a list, make sure this is true for all elements of the list"
       (if (stringp program-string)
           (executable-find program-string)
         (-none? 'null (-map 'executable-find program-string))))

     (defun report-string-or-list (string-or-list)
       "return STRING-OR-LIST if it is a string, else join the list of strings with comma"
       (if (stringp string-or-list)
           string-or-list
         (string-join string-or-list ", ")))

     (defmacro check-file-existence-status (var-name full-file-string file-name warning)
       "set VAR-NAME to t iff all files in FULL-FILE-STRING exist. additionall
     report existing files (with ok) and non existing files (with warning)."
       `(progn
          (setq ,var-name (all-files-exist ,full-file-string))
          (if (not ,var-name)
              (message (concat "WARNING: " ,file-name " missing, " ,warning))
            (message (concat "OK: " ,file-name " exists.")))))

     (defmacro check-windows-program-status (var-name full-program-string program-name warning)
       "Will check that FULL-PROGRAM-STRING is a full path to an executable and setq's VAR-NAME to installation status
          A WARNING will be logged if no installation is found.

          (macro VAR-NAME FULL-PROGRAM-STRING PROGRAM-NAME WARNING)
          "
       `(if (is-ms-windows-p)
            (progn
              (setq ,var-name (all-files-executable ,full-program-string))
              (if (not ,var-name)
                  (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
                (message (concat "OK: " ,program-name " installed."))))
          (progn
            (setq ,var-name nil)
            (message (concat "UNCHECKED (win): " ,program-name)))))

     (defmacro check-_nix-program-status (var-name program-string program-name warning)
       "Will check that PROGRAM-STRING is an executable on the path and setq's VAR-NAME to installation status
          A WARNING will be logged if no installation is found.

          (macro VAR-NAME PROGRAM-STRING PROGRAM-NAME WARNING)
          "
       `(if (is-_nix-p)
            (progn
              (setq ,var-name (all-_nix-program-exists-in-path-p ,program-string))
              (if (not ,var-name)
                  (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
                (message (concat "OK: " ,program-name " installed."))))
          (progn
            (setq ,var-name nil)
            (message (concat "UNCHECKED (*nix) : " ,program-name)))))

   #+END_SRC
* delete old backup files
  #+BEGIN_SRC emacs-lisp
    ;; delete backup files that are older than 20 weeks
    ;; or that are elisp files within .emacs.d/elpa/*
    (if (not (file-exists-p "~/file-backups"))
        (make-directory "~/file-backups"))
    (message "Deleting old backup files...")
    (let ((weeks (* 60 60 24 7 20)) ;; twenty weeks
          (current (float-time (current-time))))
      (dolist (file (directory-files (expand-file-name "~/file-backups") t))
        (when (and (backup-file-name-p file)
                   (or (> (- current (float-time (nth 5 (file-attributes file))))
                          weeks)
                       (string-match "!.emacs.d!elpa!.*elc?~$" file))) ;; remove old elpa files (which are not edited by me anyway)
          (message "about to delete file: %s" file)
          (delete-file file))))
  #+END_SRC
* ms windows specific stuff
  #+BEGIN_SRC emacs-lisp
    (when (is-ms-windows-p)
        (progn

          (setq gnutls-cli-installed nil)

          ;; make sure that git asks for the credentials via gui
          (setenv "GIT_ASKPASS" "git-gui--askpass")

          (setq graphviz-installation-path "C:/dev/tools/Graphviz 2.28/")

          (check-windows-program-status graphviz-installed (concat graphviz-installation-path "bin/dot.exe") "Graphviz" "org babel will not be able to prodcess dot files.")

          (if graphviz-installed
              (add-to-list 'exec-path graphviz-installation-path))

          (setq org-plantuml-jar-path "c:/dev/tools/plantuml.jar")

          (check-file-existence-status plantuml-installed org-plantuml-jar-path "plantuml.jar" "org babel won't be able to produce uml diagrams via plantuml.")

          (setq everthing-installation-path "C:/dev/tools/es/")
          (check-windows-program-status everything-installed (concat everthing-installation-path "es.exe") "Everything" "Helm locate will not work without 'Everthing' installed")

          (if everything-installed
              (progn
                (setq everything-cmd "C:/dev/tools/es/es.exe")
                (setq helm-locate-command "es.exe %s -r %s")))

          (setq magithub-installation-path "c:/dev/tools/hub/bin/")
          (check-windows-program-status hub-installed (concat magithub-installation-path "hub.exe") "Hub" "cannot use magithub within magit.")

          (if hub-installed
              (magithub-hub-executable (concat magithub-installation-path "hub.exe")))

          ;; windows specific settings
          ;; 1. install AutoHotkey
          ;; 2. remap windows and alt keys (left windows key will be meta, alt key will be super)
          ;;      LWin::LAlt
          ;;      LAlt::LWin
          ;;      Capslock::Ctrl
          ;; 3. disable windows hot key binding in windows (LWin + f won't open the windows find dialog anymore!)
          ;;      - start 'regedit'
          ;;      - got to the key 'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer'
          ;;      - create a new DWORD 'NoWinKeys' entry  and set its value to 1
          ;;      - reboot

          ;; make sure that autohotkey is run beforehand to map the left windows key to alt!
          (setq w32-lwindow-modifier 'super)

          (setq w3m-installed nil)

          (setq aspell-installation-path "C:/dev/tools/Aspell/")
          (check-windows-program-status aspell-installed (concat aspell-installation-path "bin/aspell.exe") "Aspell" "no spell checking will be possible")

          (if aspell-installed
              (progn
                (add-to-list 'exec-path (concat aspell-installation-path "bin/"))
                (setq ispell-program-name "aspell")))))
  #+END_SRC
* mac os x specific stuff
** misc
#+BEGIN_SRC emacs-lisp
  ;; mac specific adjustments (keyboard etc)
    (when (is-macos-p)
      (progn

        (setq browse-url-browser-function 'browse-url-chromium)
        (setq browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
        (setq browse-url-firefox-program "/Applications/Firefox.app/Contents/MacOS/firefox")

        ;;     ns-alternate-modifier
        ;;     ns-command-modifier
        ;;     ns-control-modifier
        ;;     ns-function-modifier
        ;;     ns-option-modifier (just a different name for ns-alternate-modifier)
        ;;     ns-right-alternate-modifier
        ;;     ns-right-command-modifier
        ;;     ns-right-control-modifier
        ;;     ns-right-option-modifier

        ;; Each variable can be set to 'control, 'meta, 'alt, 'super, or 'hyper.
        ;; control = C-
        ;; meta = M-
        ;; alt = A-
        ;; super = s-
        ;; hyper = H-


        ;; make sure native fullscreen is off (multi monitor support is shitty then)
        (setq ns-use-native-fullscreen nil)

        ;; make sure that using powerline, the arrows are not somewhat color garbled
        ;; Non-nil means to use sRGB colorspace on OSX >= 10.7.
        (setq ns-use-srgb-colorspace nil)

        ;; fonts anti-aliasing einschalten
        (setq mac-allow-anti-aliasing t)

        ;; Some mac-bindings interfere with Emacs bindings.
        (when (boundp 'mac-pass-command-to-system)
          (setq mac-pass-command-to-system nil))
        ;; Some mac-bindings interfere with Emacs bindings.
        (when (boundp 'mac-pass-control-to-system)
          (setq mac-pass-control-to-system nil))

        ;; Make sure the right alt key is not bound to meta (such that the right alt key can be used on a mac to create []{}...)
        (setq ns-command-modifier 'super)
        (setq ns-function-modifier 'hyper)
        (setq ns-alternate-modifier 'meta)
        (setq ns-control-modifier 'control)
        (setq ns-right-command-modifier 'super)

        ;; on macos x the right alt key is used to get e.g. the pipe '|' (alt-7)
        (setq ns-right-alternate-modifier nil) ;; 'meta

        (defun gb/keyboard-off-macbook-internal () "switch the internal keyboard of the macbook pro off"
          (interactive)
          (sudo-shell-command "kextunload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))

        (defun gb/keyboard-on-macbook-internal () "switch the internal keyboard of the macbook pro on"
          (interactive)
          (sudo-shell-command "kextload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))
        ))
#+END_SRC
** correct shell path behaviour
   #+BEGIN_SRC emacs-lisp
  ;; make sure this is run before anything else, since all shell program starts need the correct path
  ;; exec-path-from-shell alread required (w/i initial package setup)
  (when (is-macos-p)
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-envs
     '("PATH")))
#+END_SRC
* check installation status of programs (*nix)
  - make sure this is done, after path is properly setup (mac os problem)
  #+BEGIN_SRC emacs-lisp
    (when (is-_nix-p)
        (progn

          ;; is imagemagick installed (program for command line image manipulation)
          ;; install via "brew install imagemagick" or "pacman -S imagemagick"
          (check-_nix-program-status imagemagick-installed "animate" "ImageMagick" "pdf-tools not installed!")
          (check-_nix-program-status poppler-installed "pdfinfo" "poppler" "pdf-tools not installed!")
          (check-_nix-program-status gnutls-cli-installed "gnutls-cli" "gnutls-cli" "gnutls-cli not installed!")

          (check-_nix-program-status xmllint-installed "xmllint" "xmllint" "xmllint not installed, some xml functions will not be accessible (e.g. formatting)")


          ;; graphviz brings dot (and other) cl tools which are needed for plantuml to work
          (check-_nix-program-status graphviz-installed "dot" "GraphViz" "dot is not available, thus plantuml cannot be used!")

          ;; make useful for pdf tools
          (check-_nix-program-status make-installed '("make" "automake" "autoconf" "g++" "gcc") "make-tools" "make-tools are not (completely) available, thus pdf-tools cannot be compiled!")

          ;; check basic tooling
          (check-_nix-program-status locate-installed "locate" "locate" "locate is not available, thus helm find file will not work properly!")

          ;; lein (for clojure)
          (check-_nix-program-status lein-installed "lein" "leinigen" "lein is not available, thus clojure/cider will not work properly!")

          ;; hub (for magithub)
          (check-_nix-program-status hub-installed "hub" "hub" "hub command line tool not available, magithub will not be installed")

          ;; gpg (for file encryption)
          (check-_nix-program-status gpg-installed "gpg" "gpg" "gpg is necessary for file encryption.")
          (if gpg-installed
              (setq epg-gpg-program "gpg"))

          (check-_nix-program-status w3m-installed '("w3m") "w3m" "html messages in gnus will not be displayed, helm dash browsing will not use w3m.")

          (check-_nix-program-status git-lfs-installed "git-lfs" "git-lfs" "magit-lfs will not be available")

          (check-_nix-program-status ledger-installed "ledger" "ledger" "ledger-mode will not be available")

          (check-_nix-program-status chromium-installed "chromium" "chromium" "chromium not found, flymd will not work")

          (check-_nix-program-status firefox-installed "firefox" "firefox" "firefox not found")

          (check-_nix-program-status git-imerge-installed "git-imerge" "git-imerge" "git-imerge not found")

          (check-_nix-program-status languagetool-installed "languagetool" "languagetool" "languagetool not found")


          (if firefox-installed
            (progn
              (setq browse-url-browser-function 'browse-url-firefox)
              (setq browse-url-firefox-program (s-trim (shell-command-to-string "which firefox")))))

          ;; chromium takes precedence (over firefox)
          (if chromium-installed
            (progn
              (setq browse-url-browser-function 'browse-url-chromium)
              (setq browse-url-chromium-program (s-trim (shell-command-to-string "which chromium")))))

          (setq gnu-ls-installed (not (is-ms-windows-p)))
              (if gnu-ls-installed
                    (setq gnu-ls-bin-path (car (split-string (shell-command-to-string "which ls")))))
          ))
  #+END_SRC
* check emacs capabilities
  #+BEGIN_SRC emacs-lisp
  ;; check on png support
  (if (image-type-available-p 'png)
      (message "OK: Image type png is supported.")
    (message "WARNING: image type png is NOT supported."))
  #+END_SRC
* own utility functions (based on installed utils)
** xml
   #+BEGIN_SRC emacs-lisp
     ;; make sure flyspell works with nxml mode
     ;; (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)
     ;; make sure to use flyspell-prog-mode, though

     ;; if interactively used, print the current path to the mini buffer
     ;; if used non interactively, return the same
     (defun nxml-where ()
       "Display the hierarchy of XML elements the point is on as a path."
       (interactive)
       (let ((path nil))
         (save-excursion
           (save-restriction
             (widen)
             (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                         (condition-case nil
                             (progn
                               (nxml-backward-up-element) ; always returns nil
                               t)
                           (error nil)))
               (setq path (cons (xmltok-start-tag-qname) path)))
             (let ((result (format "/%s" (mapconcat 'identity path "/"))))
               (if (called-interactively-p t)
                   (message result)
                 result))))))

     (defun nxml-where-to-clipboard ()
       "paste xpath of the current location into clipboard and message buffer"
       (interactive)
       (let ((result (nxml-where)))
         (kill-new result)
         (message result)))

     (when xmllint-installed
     (defun nxml-pretty-format ()
       "use command line tool xmllint to format (large) xml files"
       (interactive)
       (save-excursion
         (shell-command-on-region (point-min) (point-max) "xmllint -nowarning --format -" (buffer-name) t)
         (nxml-mode)
         (indent-region begin end))))

     (when xmllint-installed
     (defun nxml-xpath (xpath)
       "run an xpath (may NOT include namespaces) on the currently selected buffed.
     output is pasted into buffer *xpath-output*"
       (interactive (list (read-string "xpath:" nil 'xpath-history)))
       (let* ((out-buffer "*xpath-output*")
              (new-buffer (get-buffer-create out-buffer))
              (cmd (concat "xmllint --nowarning --xpath " (shell-quote-argument xpath) " -")))
         (if (fboundp 'persp-add-buffer)
             (persp-add-buffer out-buffer))
         (shell-command-on-region (point-min) (point-max) cmd out-buffer)
         (with-current-buffer out-buffer
           (condition-case nil
               (if (string= "<" (buffer-substring-no-properties 1 2))
                   (nxml-mode)
                 (text-mode))
             (error (text-mode))))
         (if (not (get-buffer-window out-buffer))
             (message (concat "output is on buffer " out-buffer))))))

     (when xmllint-installed
     (defun nxml-xpath-on-file (xpath)
       "run an xpath (may include namespaces) on the FILE of the currently selected buffed.
     output is pasted into buffer *xpath-output*"
       (interactive (list (read-string "xpath:" nil 'xpath-history)))
       (let ((cmd (concat "echo -e \"setrootns\ncat " xpath "\" | xmllint --nowarning --shell "
                          (buffer-file-name (window-buffer (minibuffer-selected-window)))
                          "| grep -v -e \"^/ >\""))
             (out-buffer "*xpath-output*"))
         (if (fboundp 'persp-add-buffer)
             (persp-add-buffer out-buffer))
         (shell-command cmd out-buffer)
         (with-current-buffer out-buffer
           (condition-case nil
               (if (string= "<" (buffer-substring-no-properties 1 2))
                   (nxml-mode)
                 (text-mode))
             (error (text-mode))))
         (if (not (get-buffer-window out-buffer))
             (message (concat "output is on buffer " out-buffer))))))

     (when xmllint-installed
     (defun nxml-run-xmllint-shell ()
       "run an interactive xmllint shell on the FILE of the currently selected buffer"
       (interactive)
       (compile (concat "xmllint --shell " (buffer-file-name (window-buffer (minibuffer-selected-window)))) t)))
   #+END_SRC

* encryption
** epa (see 'check-installation-status *nix)
** configure pinentry
   #+BEGIN_SRC emacs-lisp
     ;; (setq epa-pinentry-mode 'loopback)
     ;; (global-visible-mark-mode -1)
   #+END_SRC
** pinentry (currently not functional, disabled)
   - see ~/.gnupg/gpg-agent.conf
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package pinentry
       :config 
       (progn 
         ;; (pinentry-start)
         ))
   #+END_SRC
* networking
** tls
   - --tofu                 Enable trust on first use authentication
   - --strict-tofu          Fail to connect if a known certificate has changed
   - %p inserts port
   - %h inserts host
   - keys are saved in ~/.gnutls/known_hosts
   #+BEGIN_SRC emacs-lisp
    (req-package tls
      :config (when gnutls-cli-installed (add-to-list 'tls-program "gnutls-cli -p %p %h")))
   #+END_SRC
   - fetch a certificate and put it into known_hosts
   #+BEGIN_SRC sh :tangle no
   gnutls-cli --tofu -p 443 imap.gmail.com
   #+END_SRC
* browser
** w3m
   #+BEGIN_SRC emacs-lisp
     (if w3m-installed
         (req-package w3m
           :commands w3m w3m-search w3m-browse-url
           :config
           (progn
             (setq w3m-default-display-inline-images t)
             (setq w3m-toggle-inline-images t))))
   #+END_SRC
* ui related stuff
** command logging
   - 'M-x command-log-mode' opens a buffer that logs all commands used
   - other functions use prefix 'clm/'
   #+BEGIN_SRC emacs-lisp
     (req-package command-log-mode
       :commands clm/toggle-command-log-buffer
       :config
       (setq command-log-mode-auto-show t))
   #+END_SRC
** interaction log
   - start via ilog-log-buffer-mode, creates a buffer called *Emacs log*, just open it
   #+BEGIN_SRC emacs-lisp
   (req-package interaction-log
     :commands ilog-log-buffer-mode)
   #+END_SRC
** copy of window init from spacemacs
   #+BEGIN_SRC emacs-lisp
     (defvar gb--after-display-system-init-list '()
       "List of functions to be run after the display system is initialized.")

     (defadvice server-create-window-system-frame
         (after gb-init-display activate)
       "After Emacs server creates a frame, run functions queued in
     `GB--AFTER-DISPLAY-SYSTEM-INIT-LIST' to do any setup that needs to have
     the display system initialized."
       (progn
         (dolist (fn (reverse gb--after-display-system-init-list))
           (funcall fn))
         (ad-disable-advice 'server-create-window-system-frame
                            'after
                            'gb-init-display)
         (ad-activate 'server-create-window-system-frame)))

     (defmacro gb/do-after-display-system-init (&rest body)
       "If the display-system is initialized, run `BODY', otherwise,
     add it to a queue of actions to perform after the first graphical frame is
     created."
       `(let ((init (cond ((boundp 'ns-initialized) ns-initialized)
                          ;; w32-initialized gets set too early, so
                          ;; if we're on Windows, check the list of fonts
                          ;; instead (this is nil until the graphics system
                          ;; is initialized)
                          ((boundp 'w32-initialized) (font-family-list))
                          ((boundp 'x-initialized) x-initialized)
                          ;; fallback to normal loading behavior only if in a GUI
                          (t (display-graphic-p)))))
          (if init
              (progn
                ,@body)
            (push (lambda () ,@body) gb--after-display-system-init-list))))
   #+END_SRC
** winner mode
   - undo/redo window configuration with C-c <left> and C-c <right>
   #+BEGIN_SRC emacs-lisp
   (winner-mode 1)
   #+END_SRC
** minibuffer
   #+BEGIN_SRC emacs-lisp
     (setq enable-recursive-minibuffers t)
     (minibuffer-depth-indicate-mode 1)
   #+END_SRC
** jumpy scrolling
   - some settings that makes scrolling a bit more what is actually wanted
   #+BEGIN_SRC emacs-lisp
     (progn
       (setq-default scroll-up-aggressively 0.01
                     scroll-down-aggressively 0.01)
       (setq scroll-up-aggressively 0.01
             scroll-down-aggressively 0.01)
       (setq scroll-margin 0)
       ;; (setq scroll-step 1)
       (setq scroll-conservatively 10000)
       (setq auto-window-vscroll nil))
       (setq smooth-scroll/vscroll-step-size 3)
  #+END_SRC
** show menu bar (only in case of macos)
 #+BEGIN_SRC emacs-lisp
   (if (is-macos-p)
       (menu-bar-mode 1)
     (menu-bar-mode -1))
 #+END_SRC
** remove scroll bars
#+BEGIN_SRC emacs-lisp
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC
** add theme
   #+BEGIN_SRC emacs-lisp
     (if (file-exists-p (concat user-emacs-directory "themes"))
        (progn
          (add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes"))
          (add-to-list 'load-path (concat user-emacs-directory "themes"))
          (if (file-exists-p (concat user-emacs-directory "themes/sanityinc-tomorrow-night-theme.el"))
              (progn
                (load-theme 'sanityinc-tomorrow-night t)
                (custom-set-faces '(link-face ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
                (custom-set-faces '(link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e")))))))
            (message (concat "WARNING: theme folder '" user-emacs-directory "themes' does not contain 'sanityinc-tomorrow-night"))))
      (message (concat "WARNING: theme folder '" user-emacs-directory "themes' not found. Themes will not be loaded")))
   #+END_SRC
** display symbols (pretty-mode, prettify-greek)
   #+BEGIN_SRC emacs-lisp
     (req-package pretty-mode
       :config 
       (progn
         (global-pretty-mode 1)
         (global-prettify-symbols-mode 1)
         (setq prettify-symbols-unprettify-at-point t)

         ;; make sure this does not collide with symbols from fira code symbol replacement (ligatures)
         (pretty-deactivate-groups
          '(:equality :ordering :ordering-double :ordering-triple
                      :arrows :arrows-twoheaded :punctuation :arithmetic :arithmetic-double))
         (pretty-activate-groups
          '(:sub-and-superscripts :greek :arithmetic-nary))
         ))

     (req-package prettify-greek) ;; prettify greek symbols 
   #+END_SRC
** font related stuff
   #+BEGIN_SRC emacs-lisp
     (setq gb/default-font "Source Code Pro")
     ;; (setq gb/default-font "Fira Code")
     ;; (setq gb/default-font "Cousine")

     (when (not (member gb/default-font (font-family-list)))
       (message (concat "WARNING: expected font '" gb/default-font "' not found in available font list.")))

     (require 'ht)
     (defun gb/get-font-heights (display-width win-system)
       "Get font heights depending on display width"
       (if (memq win-system '(mac ns))
           (cond ((> display-width 3400)
                  (ht ('default-height 150) ('variable-pitch-height 160)))
                 ((ht ('default-height 130) ('variable-pitch-height 140))))
         (cond ((> display-width 3400)
                (ht ('default-height 120) ('variable-pitch-height 130)))
               ((ht ('default-height 100) ('variable-pitch-height 110))))))

     (defun gb/get-font-weights (win-system)
       "Get font weights depending on windowing system"
       (if (memq win-system '(mac ns))
           (ht ('default-weight 'light) ('variable-pitch-weight 'regular))
         (ht ('default-weight 'regular) ('variable-pitch-weight 'regular))))

     (setq gb/setup-main-fonts-needs-execution t)
     (defun gb/setup-main-fonts (&optional frame)
       "Set up default fonts.

       Use DEFAULT-HEIGHT for default face and VARIABLE-PITCH-HEIGHT
       for variable-pitch face."
       (if gb/setup-main-fonts-needs-execution
           (let* ((attr-map (ht-merge (gb/get-font-heights (x-display-pixel-width) window-system)
                                      (gb/get-font-weights window-system))))
             (message "setting up default fonts")
             (message (format "display pixel width %d" (x-display-pixel-width)))
             (set-face-attribute 'default nil
                                 :family gb/default-font
                                 :height (ht-get attr-map 'default-height)
                                 :weight (ht-get attr-map 'default-weight))
             (set-face-attribute 'variable-pitch nil
                                 ;; :family "Fira Sans"
                                 :height (ht-get attr-map 'variable-pitch-height)
                                 :weight (ht-get attr-map 'variable-pitch-weight))
             (setq gb/setup-main-fonts-needs-execution nil))))

     (defun gb/reset-main-fonts ()
       "reinitialize fonts e.g. if resolution changed etc."
       (interactive)
       (setq gb/setup-main-fonts-needs-execution t)
       (gb/setup-main-fonts))

     ;; (gb/setup-main-fonts)
     (gb/do-after-display-system-init (gb/setup-main-fonts))
     ;;(add-hook 'after-make-frame-functions #'gb/setup-main-fonts)
     ;;(add-hook 'focus-in-hook #'gb/setup-main-fonts)
     ;;(when (display-graphic-p)
     ;;  (gb/setup-main-fonts))

     ;; (if after-init-time
     ;;     (gb/setup-main-fonts)
     ;;   (add-hook 'after-init-hook 'gb/setup-main-fonts))

   #+END_SRC
   - install ligatures via fira code symbol (had to install [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][fira code symbol]] for the following to work)
     #+BEGIN_SRC emacs-lisp
       (setq gb/setup-ligatures-needs-execution t)
       (defun gb/setup-ligatures (&optional frame) "setup ligatures"
       (if gb/setup-ligatures-needs-execution
       (progn
         (setq fira-code-symbol-installed (member "Fira Code Symbol" (font-family-list)))

         (if (not fira-code-symbol-installed)
             (message "WARNING: Fira code symbol not installed. Ligatures will not be available."))

         (when fira-code-symbol-installed
           (message "setting up ligatures")
           ;; Fira code
           ;; This works when using emacs --daemon + emacsclient
           ;; (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
           ;; This works when using emacs without server/client
           (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
           ;; I haven't found one statement that makes both of the above situations work, so I use both for now

           (defconst fira-code-font-lock-keywords-alist
             (mapcar (lambda (regex-char-pair)
                       `(,(car regex-char-pair)
                         (0 (prog1 ()
                              (compose-region (match-beginning 1)
                                              (match-end 1)
                                              ;; The first argument to concat is a string containing a literal tab
                                              ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
                     '(("\\(www\\)"                   #Xe100)
                       ;; ("[^/\\*]\\(\\*\\*\\)[^\\*/]"        #Xe101) ;; double **
                       ;; ("\\(\\*\\*\\*\\)"             #Xe102) ;; triple stars ***
                       ;; ("\\(\\*\\*/\\)"               #Xe103) ;; double comment end **/
                       ;; ("\\(\\*>\\)"                  #Xe104)
                       ;; ("[^*]\\(\\*/\\)"              #Xe105) ;; single comment end */
                       ("\\(*\\)" #Xe16f) ;; single *
                       ("\\(\\\\\\\\\\)"              #Xe106)
                       ("\\(\\\\\\\\\\\\\\)"          #Xe107)
                       ("\\({-\\)"                    #Xe108)
                       ("\\(\\[\\]\\)"                #Xe109)
                       ("\\(::\\)"                    #Xe10a)
                       ("\\(:::\\)"                   #Xe10b)
                       ("[^=]\\(:=\\)"                #Xe10c)
                       ("\\(!!\\)"                    #Xe10d)
                       ("\\(!=\\)"                    #Xe10e)
                       ("\\(!==\\)"                   #Xe10f)
                       ("\\(-}\\)"                    #Xe110)
                       ("\\(--\\)"                    #Xe111)
                       ("\\(---\\)"                   #Xe112)
                       ("\\(-->\\)"                   #Xe113)
                       ("[^-]\\(->\\)"                #Xe114)
                       ("\\(->>\\)"                   #Xe115)
                       ("[^<-]\\(-<\\)[^<>]"                    #Xe116)
                       ("\\(-<<\\)"                   #Xe117)
                       ("\\(-~\\)"                    #Xe118)
                       ("\\(#{\\)"                    #Xe119)
                       ("\\(#\\[\\)"                  #Xe11a)
                       ("\\(##\\)"                    #Xe11b)
                       ("\\(###\\)"                   #Xe11c)
                       ("\\(####\\)"                  #Xe11d)
                       ("\\(#(\\)"                    #Xe11e)
                       ("\\(#\\?\\)"                  #Xe11f)
                       ("\\(#_\\)"                    #Xe120)
                       ("\\(#_(\\)"                   #Xe121)
                       ("\\(\\.-\\)"                  #Xe122)
                       ("\\(\\.=\\)"                  #Xe123)
                       ("\\(\\.\\.\\)"                #Xe124)
                       ("\\(\\.\\.<\\)"               #Xe125)
                       ("\\(\\.\\.\\.\\)"             #Xe126)
                       ("\\(\\?=\\)"                  #Xe127)
                       ("\\(\\?\\?\\)"                #Xe128)
                       ("\\(;;\\)"                    #Xe129)
                       ;; ("\\(/\\*\\)"                  #Xe12a)
                       ;; ("\\(/\\*\\*\\)"               #Xe12b)
                       ("\\(/=\\)[^=]"                    #Xe12c)
                       ("\\(/==\\)"                   #Xe12d)
                       ("[^<]\\(/>\\)"                    #Xe12e)
                       ("[^/]\\(//\\)[^/]"                    #Xe12f)
                       ("\\(///\\)"                   #Xe130)
                       ("\\(&&\\)"                    #Xe131)
                       ("\\(||\\)[^=]"                    #Xe132)
                       ("\\(||=\\)"                   #Xe133)
                       ("[^|]\\(|=\\)"                #Xe134)
                       ("\\(|>\\)"                    #Xe135)
                       ("\\(\\^=\\)"                  #Xe136)
                       ("\\(\\$>\\)"                  #Xe137)
                       ("\\(\\+\\+\\)"                #Xe138)
                       ("\\(\\+\\+\\+\\)"             #Xe139)
                       ("\\(\\+>\\)"                  #Xe13a)
                       ("\\(=:=\\)"                   #Xe13b)
                       ("[^!/]\\(==\\)[^>=]"           #Xe13c)
                       ("\\(===\\)"                   #Xe13d)
                       ("\\(==>\\)"                   #Xe13e)
                       ("[^=<>]\\(=>\\)[^>]"                #Xe13f)
                       ("\\(=>>\\)"                   #Xe140)
                       ("[^<>]\\(<=\\)[^=<>]"                    #Xe141)
                       ("\\(=<<\\)"                   #Xe142)
                       ("\\(=/=\\)"                   #Xe143)
                       ("\\(>-\\)"                    #Xe144)
                       ("\\(>=\\)[^>]"                    #Xe145)
                       ("\\(>=>\\)"                   #Xe146)
                       ("[^-=]\\(>>\\)"               #Xe147)
                       ("\\(>>-\\)"                   #Xe148)
                       ("\\(>>=\\)"                   #Xe149)
                       ("\\(>>>\\)"                   #Xe14a)
                       ;; ("\\(<\\*\\)[^>]"                  #Xe14b)
                       ;; ("\\(<\\*>\\)"                 #Xe14c)
                       ("\\(<|\\)[^>]"                    #Xe14d)
                       ("\\(<|>\\)"                   #Xe14e)
                       ("\\(<\\$\\)[^>]"                  #Xe14f)
                       ("\\(<\\$>\\)"                 #Xe150)
                       ("\\(<!--\\)"                  #Xe151)
                       ("\\(<-\\)[^-<>]"                    #Xe152)
                       ("\\(<--\\)"                   #Xe153)
                       ("\\(<->\\)"                   #Xe154)
                       ("\\(<\\+\\)[^>]"                  #Xe155)
                       ("\\(<\\+>\\)"                 #Xe156)
                       ("\\(<=\\)[^=<>]"                    #Xe157)
                       ("\\(<==\\)"                   #Xe158)
                       ("\\(<=>\\)"                   #Xe159)
                       ("\\(<=<\\)"                   #Xe15a)
                       ("[^-]\\(<>\\)[^-]"                    #Xe15b)
                       ("[^-=]\\(<<\\)"               #Xe15c)
                       ("\\(<<-\\)"                   #Xe15d)
                       ("\\(<<=\\)"                   #Xe15e)
                       ("\\(<<<\\)"                   #Xe15f)
                       ("\\(<~\\)[^~]"                    #Xe160)
                       ("\\(<~~\\)"                   #Xe161)
                       ("\\(</\\)[^>]"                    #Xe162)
                       ("\\(</>\\)"                   #Xe163)
                       ("\\(~@\\)"                    #Xe164)
                       ("\\(~-\\)"                    #Xe165)
                       ("\\(~=\\)"                    #Xe166)
                       ("[^<~]\\(~>\\)"                    #Xe167)
                       ("[^<]\\(~~\\)[^>]"                #Xe168)
                       ("\\(~~>\\)"                   #Xe169)
                       ("\\(%%\\)"                    #Xe16a)
                       ;;("\\(x\\)"                     #Xe16b)
                       ("[^:=]\\(:\\)[^:=]"           #Xe16c)
                       ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
                       ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

           (defun add-fira-code-symbol-keywords ()
             (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

           (defun remove-fira-code-symbol-keywords ()
             (font-lock-remove-keywords nil fira-code-font-lock-keywords-alist))

           (defun gb/disable-ligatures ()
             "disable ligatures"
             (interactive)
             (remove-fira-code-symbol-keywords)
             (remove-hook 'prog-mode-hook
                          #'add-fira-code-symbol-keywords)
             (font-lock-flush)
             (run-mode-hooks)
             (setq ligatures-enabled nil))

           (defun gb/enable-ligatures ()
             "enable ligatures"
             (interactive)
             (add-fira-code-symbol-keywords)
             (add-hook 'prog-mode-hook
                       #'add-fira-code-symbol-keywords)
             (font-lock-flush)
             (run-mode-hooks)
             (setq ligatures-enabled t))

           (defun gb/toggle-ligatures ()
             "toggle display of ligatures in progmode"
             (interactive)
             (if ligatures-enabled
                 (progn
                   (gb/disable-ligatures)
                   (message "disabled ligatures."))
               (progn
                 (gb/enable-ligatures)
                 (message "enabled ligatures."))))

           (gb/enable-ligatures)
           (message "enabled ligatures.")
           (setq gb/setup-ligatures-needs-execution nil)))))

       (gb/do-after-display-system-init (gb/setup-ligatures))
       ;; (add-hook 'focus-in-hook #'gb/setup-ligatures)
       ;; (add-hook 'after-make-frame-functions #'gb/setup-ligatures)
       ;; (when (display-graphic-p)
       ;;   (gb/setup-ligatures))

     #+END_SRC
** sublimity
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package sublimity
       :config
       (progn
         ;; enable smooth scrolling
         (require 'sublimity-scroll)

         (defun gb/enable-sublimity-mode ()
           "do not enable sublimity mode for a certain list of modes"
           (if (memq major-mode (list 'ansi-term-mode 'term-mode 'shell-mode))
               (sublimity-mode -1)
             (sublimity-mode 1)))
         (add-hook 'after-change-major-mode-hook #'gb/enable-sublimity-mode)
         (setq sublimity-scroll-drift-length 4)
         (setq sublimity-scroll-weight 4.0)
         ;; minimap is explicitly not enabled, since another minimap-mode is used for that
         ;; enable minimap
         ;; (require 'sublimity-map)
         ;; show minimap after x seconds of inactivity
         ;; (sublimity-map-set-delay 3)
         ))
   #+END_SRC
** other
#+BEGIN_SRC emacs-lisp
  ;; Changes all yes/no questions to y/n type
  (fset 'yes-or-no-p 'y-or-n-p)

  (setq-default line-spacing 1)

  ;; These settings relate to how emacs interacts with your operating system
  (setq ;; makes killing/yanking interact with the clipboard
        select-enable-clipboard t

        ;; use primary selection for cut/paste
        select-enable-primary t

        ;; Save clipboard strings into kill ring before replacing them.
        ;; When one selects something in another program to paste it into Emacs,
        ;; but kills something in Emacs before actually pasting it,
        ;; this selection is gone unless this variable is non-nil
        save-interprogram-paste-before-kill t

        ;; Shows all options when running apropos. For more info,
        ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html
        apropos-do-all t

        ;; Mouse yank commands yank at point instead of at click.
        mouse-yank-at-point t)

  ;; No cursor blinking, it's distracting
  (blink-cursor-mode 0)

  ;; make cursor the width of the character it is under
  ;; i.e. full width of a TAB
  (setq x-stretch-cursor t)

  ;; full path in title bar
  (setq-default frame-title-format "%b (%f)")

  (setq visible-bell 1)
#+END_SRC
** window/frame
#+BEGIN_SRC emacs-lisp
  ;; do window enlarge and shrink
  (defun shrink-window-horizontally-effect ()
    "shrink window within a frame with visual effect"
    (interactive)
    (save-excursion
      (let ((speeds '(4 4 4)))
        (dolist (speed speeds) 
          (shrink-window-horizontally speed)
          (force-window-update (selected-window))
          (redisplay)))))

  (defun enlarge-window-horizontally-effect ()
    "enlarge window within frame with visual effect"
    (interactive)
    (save-excursion
      (let ((speeds '(4 4 4)))
        (dolist (speed speeds) 
          (enlarge-window-horizontally speed)
          (force-window-update (selected-window))
          (redisplay)))))

  (defun enlarge-window-effect ()
    "enlarge window vertically with visual effect"
    (interactive)
    (save-excursion
      (let ((speeds '(1 1 1 1)))
        (dolist (speed speeds) 
          (enlarge-window speed)
          (force-window-update (selected-window))
          (redisplay)))))

  (defun shrink-window-effect () 
    "shrink window vertically with visual effect"
    (interactive)
    (save-excursion
      (let ((speeds '(1 1 1 1)))
        (dolist (speed speeds) 
          (shrink-window speed)
          (force-window-update (selected-window))
          (redisplay)))))

  (defun balance-windows-respecting-speedbar ()
    "balance all windows but make sure that speedbar is sized to 50 width"
    (interactive)
    (balance-windows)
    (with-selected-window (get-buffer-window "*SPEEDBAR*") 
      (let ((delta (- 50 (window-width (selected-window)))))
        (if (< 0 delta) 
            (shrink-window-horizontally (- delta))
          (enlarge-window-horizontally delta)))))

  ;; make sure that macos mouse scrolling is not too jerky
  (setq mouse-wheel-scroll-amount '(0.01))
#+END_SRC
** maxframe
 #+BEGIN_SRC emacs-lisp
   (req-package maxframe
     :config
     (progn
       ;; remove defined alias
       (defalias 'mf nil)))
 #+END_SRC
** transpose frame
#+BEGIN_SRC emacs-lisp
  (req-package transpose-frame
    :bind (
    ("C-s-+" . flip-frame) ;; exchange top with bottom windows (german layout)
    ("C-s-]" . flip-frame) ;; us layout
    ("C-s-#" . flop-frame) ;; exchange right with left windows
    ("C-s-'" . flop-frame) ;; us layout
    ("C-s--" . transpose-frame) ;; exchange splitted vertically with splitted horizontally window
    ("C-s-/" . transpose-frame) ;; us layout
    ))
#+END_SRC
** bind-key
   #+BEGIN_SRC emacs-lisp
     ;; set global keys for window management
     (req-package bind-key
       :config
       (progn
       ;; shrink selected window horizontally
       (bind-key "C-s-<left>" 'shrink-window-horizontally-effect)
       ;; enlarge selected window horizontally
       (bind-key "C-s-<right>" 'enlarge-window-horizontally-effect)
       ;; shrink selected window vertically
       (bind-key "C-s-<down>" 'shrink-window-effect)
       ;; enlarge slected window vertically
       (bind-key "C-s-<up>" 'enlarge-window-effect)

       ;; maximize selected window
       (bind-key "C-s-<return>" 'maximize-window)
       ;; balance all windows and the set speedbar to 50 width
       (bind-key "C-s-<backspace>" 'balance-windows-respecting-speedbar)

       ;; Key binding to use "hippie expand" for text autocompletion
       ;; http://www.emacswiki.org/emacs/HippieExpand
       (bind-key "s-7" 'hippie-expand)
       ;; Interactive search key bindings. By default, C-s runs
       ;; isearch-forward, so this swaps the bindings.
       (bind-key "C-s" 'isearch-forward-regexp) ;; currently shadowed by visual-regexp (in test)
       (bind-key "C-r" 'isearch-backward-regexp) ;; currently shadowed by visual-regexp (in test)
       ;; (bind-key "C-M-s" 'isearch-forward)
       ;; (bind-key "C-M-r" 'isearch-backward)

       ;; indent relative to the stuff on the previous line
       ;; overwrite (hide) original binding M-i tab-to-tab-stop
       ;; (global-set-key (kbd "M-i") 'indent-relative)
       (bind-key "M-i" 'indent-relative)


       (bind-key "C-c RET" 'remove-dos-eol)
       (bind-key "C-c <C-return>" 'remove-dos-eol)

       (bind-key "C-x C-c" 'dont-kill-emacs)

       (bind-key "s-+" 'decrease-transparency)
       (bind-key "s--" 'increase-transparency)
       (bind-key "s-#" 'disable-transparency)
       (bind-key "s-]" 'decrease-transparency)
       (bind-key "s-'" 'increase-transparency)
       (bind-key "s-/" 'disable-transparency)

       (bind-key "C-;" 'toggle-comment-on-line)

       (bind-key "C-x b" 'ibuffer-list-buffers-and-switch)

       (bind-key "<s-up>" 'scroll-up-line)
       (bind-key "<s-down>" 'scroll-down-line)
       (bind-key "<M-s-up>" 'scroll-up-line-7)
       (bind-key "<M-s-down>" 'scroll-down-line-7)

       (bind-key "<s-C-up>" 'scroll-up-line-and-move-cursor)
       (bind-key "<s-C-down>" 'scroll-down-line-and-move-cursor)

       (bind-key "<s-C-M-up>" 'scroll-up-line-and-move-cursor-7)
       (bind-key "<s-C-M-down>" 'scroll-down-line-and-move-cursor-7)

       (bind-key "C-h C-m" 'discover-my-major)))
   #+END_SRC
** sytem stats (for minibuffer)
   #+BEGIN_SRC emacs-lisp
     (req-package symon
       :commands symon-mode
       :config
       (progn
         ;; make sure to load it
         (require 'symon)
         ;; redefine to display right aligned
         (defun symon--display-update ()
           "update symon display"
           (unless (or cursor-in-echo-area (active-minibuffer-window))
             (let ((message-log-max nil)  ; do not insert to *Messages* buffer
                   (display-string nil)
                   (page 0))
               (dolist (lst symon--display-fns)
                 (if (= page symon--active-page)
                 (let* ((fheight (ht-get (gb/get-font-heights (x-display-pixel-width) window-system) 'default-height))
                        (spaces (floor (- (/ (frame-pixel-width) 10) (- (* 1.5 fheight) 100)))))
                     (message (concat (make-string  spaces ? ) "%s") (apply 'concat (mapcar 'funcall lst))))
                   (mapc 'funcall lst))
                 (setq page (1+ page))))
             (setq symon--display-active t)))
         ;; then redefine with alternate cpu benchmark (dividing cpu mark by 8 cores)
         (defun symon-darwin--maybe-start-process ()
           (symon--maybe-start-process (format "
     while true; do
         echo \"----\"

         interface=`route get 0.0.0.0 | grep interface | awk '{print $2}'`
         s=`netstat -bi -I $interface | tail -1`;
         echo $s | awk '{print \"rx:\"$7}'
         echo $s | awk '{print \"tx:\"$8}'

         s=`ps -e -o %%cpu | awk '{x+=$1} END {print x/8}' | sed 's/,.*//'`           ### cpu number is 8 => /8
         echo \"cpu:$s\"

         m1=`sysctl hw.memsize | sed 's/.*:\s*//'`
         m_active=`vm_stat | grep 'Pages active' | sed 's/.*: *//'`
         m_wired=`vm_stat | grep 'Pages wired' | sed 's/.*: *//'`

         s=`echo \"scale=2; (($m_active+$m_wired)*4096*100 / $m1)\"| bc -l`
         echo \"mem:$s\"

         sleep %d
     done" symon-refresh-rate)))

         (setq symon-sparkline-type 'boxed)
         ;; (symon-mode 1)
         ))
   #+END_SRC
** modeline
*** spinner (busy indicator for modeline)
    - (spinner-start 'vertical-breathing 10)
    - (spinner-start 'minibox)
    - (spinner-start 'moon)
    - (spinner-start 'triangle)
    #+BEGIN_SRC emacs-lisp
    (req-package spinner)
    #+END_SRC
*** spaceline (mode line of spacemacs)
    #+BEGIN_SRC emacs-lisp
      (req-package spaceline
        :require powerline
        :config
        ;; Valid Values: alternate, arrow, arrow-fade, bar, box, brace,
        ;; butt, chamfer, contour, curve, rounded, roundstub, wave, zigzag,
        ;; utf-8
        (setq powerline-default-separator 'utf-8)

        (require 'spaceline-config)
        (spaceline-spacemacs-theme)
        (spaceline-helm-mode)
        (custom-set-faces
         '(spaceline-highlight-face ((t (:background "DarkGoldenrod3" :foreground "#000000" :inherit (quote mode-line))))))

        (gb/do-after-display-system-init

         (setq gb/mode-line-buffer-read-only-symbol (if fira-code-symbol-installed "\ue0a2" "o"))  ;; ""
         (setq gb/mode-line-buffer-modified-ro-symbol (if fira-code-symbol-installed "\ue16b" "x"))  ;; ""
         (setq gb/mode-line-buffer-modified-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
         (setq gb/mode-line-branch-up-to-date-symbol "\u2713")  ;; ""
         (setq gb/mode-line-branch-edited-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
         (setq gb/mode-line-cutted-path-prefix-symbol "\u2025") ;; ""

         (spaceline-define-segment gb/buffer-status
           "Buffer status (read-only, modified), with color"
           (cond ((and buffer-read-only (buffer-modified-p)) gb/mode-line-buffer-modified-ro-symbol)
                 (buffer-read-only gb/mode-line-buffer-read-only-symbol)
                 ((buffer-modified-p) gb/mode-line-buffer-modified-symbol)
                 (t " ")))

         (spaceline-define-segment gb/date-and-cw
           "display date and calendar week of window is broad enough"
           (if (> (window-width) 150)
               (propertize (format-time-string "%m-%d/%V")
                           'help-echo "month-day/calendarweek")
             ""))

         (spaceline-define-segment gb/buffer-id
           (propertize (buffer-name) 'help-echo (format "%s, size: %s" (buffer-name) (number-to-string (buffer-size)))))

         (spaceline-define-segment gb/buffer-file-name
           "provide fullpath to buffer file name, shortened to 35 characters if too long"
           ;; limit path length to a certain number of characters (currently 35)
           ;; TODO: allow replacing certain paths with some shorthands (e.g. :doc: for ~/Documents/)
           (let* ((path (replace-regexp-in-string (concat "^" (regexp-quote (expand-file-name "~"))) "~" (or (file-name-directory (or buffer-file-name "")) "")))
                  (maxlen (max 0 (- (window-width) 57 (length (buffer-name)))))
                  (spath (cond ((>= 0 maxlen) "")
                               ((> (length path) maxlen)
                                (concat gb/mode-line-cutted-path-prefix-symbol (substring path (- maxlen) nil)))
                               (t path))))
             (propertize spath 'help-echo path))
           -       ;;     (or spath "")
           :tight t)

         (defun gb/in-git-dir-p ()
           (not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir"))))

         (defun gb/vc-status ()
           (if vc-mode
               vc-mode
             (concat "\ue0a0 " (car (split-string (shell-command-to-string "git rev-parse --abbrev-ref HEAD"))))))

         (setq gb/vc-status-cache-delay "10 sec")
         (setq gb/vc-status-cache-buffer-id nil)
         (setq gb/vc-status-cache nil)
         (setq gb/vc-status-cache-timer nil)

         (defun gb/get-cached-git-state ()
           "if cache filled and within same buffer (name) refresh in five seconds and return cached value, else refresh cache and return new values"
           (if (and gb/vc-status-cache (string= (buffer-name) gb/vc-status-cache-buffer-id))
               ;; only if no timer is running!
               (unless gb/vc-status-cache-timer
                 (setq gb/vc-status-cache-timer (run-at-time gb/vc-status-cache-delay nil 'gb/refresh-vc-status-cache)))
             (gb/refresh-vc-status-cache))
           gb/vc-status-cache)

         (defun gb/refresh-vc-status-cache ()
           "refresh values with actual git call and clear timer (maybe cancel?)"
           (setq gb/vc-status-cache-buffer-id (buffer-name))
           (setq gb/vc-status-cache (gb/git-state))
           (setq gb/vc-status-cache-timer nil))

         (defun gb/git-state ()
           "query git status for the currently active buffer, refresh on buffer switches"
           (let* ((git-output (shell-command-to-string "git status -s")))
             ;; (message (concat  "git querried " (current-time-string))) ;; just for debugging, please remove when done
             (if (string-empty-p git-output)
                 'up-to-date
               'dirty)))

         (defun gb/vc-state ()
           (if (buffer-file-name)
               (vc-state (buffer-file-name))
             (gb/get-cached-git-state)))

         (defun gb/buffer-on-remote ()
           "return whether current buffer is on remote (via tramp)"
           (file-remote-p (or default-directory buffer-file-name dired-directory "")))

         (spaceline-define-segment gb/projectile-id
           (cond ((gb/buffer-on-remote) "")
                 ((and (fboundp 'projectile-project-p) (projectile-project-p))
                  (projectile-project-name))
                 (t "")))

         (spaceline-define-segment gb/version-control
           "Version control information."
           (when (and (not (gb/buffer-on-remote)) (gb/in-git-dir-p))
             (powerline-raw
              (s-trim (concat (replace-regexp-in-string "^ *Git[:-]" "\ue0a0 " (gb/vc-status)) ;; "  "
                              (pcase (gb/vc-state)
                                (`up-to-date (concat " " gb/mode-line-branch-up-to-date-symbol))
                                (`edited (concat " " gb/mode-line-branch-edited-symbol))
                                (`added " +")
                                (`unregistered " ?")
                                (`removed " -")
                                (`needs-merge " m")
                                (`needs-update " u")
                                (`ignored " i")
                                (_ " x")))))))

         (spaceline-define-segment gb/time
           "A segment to to display the time"
           (propertize (format-time-string "%H:%M")
                       'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit)
                       'display '(raise 0.1)
                       'help-echo (format-time-string "%A, %Y.%m.%d %H:%M")))

         (when (package-installed-p 'indent-info)
           (spaceline-define-segment gb/indent-info-mode-line
             ""
             (indent-info-mode-line)))

         ))
    #+END_SRC
*** spaceline all the icons
    - important: install fonts located [[https://github.com/domtronn/all-the-icons.el/tree/master/fonts][here]]
    #+begin_SRC emacs-lisp
      (req-package font-lock+)
      (req-package all-the-icons
        :require memoize font-lock+
        :config
        ;; extend list of all-the-icons-mode-icon-alist
        ;; by
        ;; (typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
        ;; (tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
        (with-eval-after-load 'all-the-icons
          (progn
            (add-to-list 'all-the-icons-mode-icon-alist '(typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
            (add-to-list 'all-the-icons-mode-icon-alist '(tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
            )))

      (req-package memoize)

      (req-package spaceline-all-the-icons
        :require spaceline all-the-icons memoize ;; indent-info
        ;; :defer 1
        :config
        ;; (spaceline-all-the-icons-theme)
        (custom-set-variables  '(spaceline-all-the-icons-highlight-file-name t)
                               '(spaceline-all-the-icons-separator-type (quote slant)) ;; cup, slant, wave, arrow
                               '(spaceline-all-the-icons-slim-render nil)
                               '(spaceline-all-the-icons-file-name-highlight t)
                               )

        (gb/do-after-display-system-init
         (progn
           (defun gb/warn-missing-font (font-name)
             "warn of font missing, if not found"
             (if (member font-name (font-family-list))
                 (message (concat "OK: font '" font-name "' is installed."))
               (message (concat "WARNING: make sure font '" font-name  "' is installed."))))

           (gb/warn-missing-font "all-the-icons")
           (gb/warn-missing-font "file-icons")
           (gb/warn-missing-font "FontAwesome")
           (gb/warn-missing-font "Material Icons")
           (gb/warn-missing-font "github-octicons")
           (gb/warn-missing-font "Weather Icons")

           (spaceline-install '((gb/buffer-status :face highlight-face)
                                ;; auto-compile
                                ;; buffer-size
                                gb/buffer-file-name
                                (gb/buffer-id :face highlight-face) ;; popup-menu-selection-face
                                ;; remote-host
                                (paradox-menu :when active)
                                ;; persp-name
                                ;; major-mode
                                ((flycheck-error flycheck-warning flycheck-info)
                                  :when active)
                                ((all-the-icons-mode-icon
                                  ;; gb/projectile-id

                                  ;;  all-the-icons-projectile
                                  ;; (minor-modes :when active)
                                  (gb/version-control :when (string= major-mode "shell-mode"))
                                  ;; all-the-icons-vc-icon
                                  ;; (all-the-icons-vc-status
                                  ;;  all-the-icons-git-ahead
                                  ;;   all-the-icons-git-status
                                  ;; :when (buffer-file-name))
                                  ;; all-the-icons-flycheck-status
                                  ;; all-the-icons-flycheck-status-info
                                  ;; all-the-icons-package-updates
                                  ))

                                ;; (erc-track :when active)
                                (process :when active)
                                (org-pomodoro :when active)
                                (org-clock :when active)
                                )

             '(;; which-function
               ;; (python-pyvenv :fallback python-pyenv)
               ;; purpose

               selection-info
               ;; gb/indent-info-mode-line
               ;; input-method
               ((buffer-encoding-abbrev
                 point-position
                 line-column)
                :separator " ")
               ;;(global :when active)
               ((buffer-position
                 hud))
               (gb/date-and-cw :tight t :when active :face default-face)
               ((all-the-icons-battery-status :tight t)
                ;; (all-the-icons-time :when active :tight t)
                (gb/time :when active :tight t)

                ;; :separator (spaceline-all-the-icons--separator "|" " ") :face default-face
                )
               ))

           (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
           (spaceline-all-the-icons--setup-anzu)
           ))

        ;; (spaceline-all-the-icons--setup-paradox)
        )
    #+END_SRC
*** rich minority mode (hide minor modes from smart mode line) (disabled, smart mode line not in use anymore)
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package rich-minority
        :config
        (progn
          (rich-minority-mode +1)
          (setq rm-blacklist
                '(" GitGutter"
                  " MRev"
                  " company" ;; complete anything mode
                  " mate"
                  " Projectile" ;;
                  " Anzu" ;; mode to display number of matches during reg ex search
                  " Undo-Tree"
                  " SliNav" ;; slime navigation mode (C-, C-.)
                  " ElDoc" ;; elisp documentation mode
                  " WLR" ;; whole line or region mode
                  " $" ;; rich minority mode
                  " Fly" ;; flymake mode?
                  " h"
                  " hs" ;; hide show (toggle block visibility)
                  " Abbrev" ;; 
                  " ARev" ;; auto revert mode
                  " WK" ;; which key
                  " yas" ;; yasnippets
                  " Fill" ;; auto-fill-mode
                  " ElDoc overlay" ;; eldoc-overlay-mode
                  " AceI" ;; ace-isearch-mode
                  " Helm" ;; helm mode
                  " HidePW" ;; hide passwords in org mode files
                  " back" ;; back-button-mode (navigation local/global)
                  " sel" ;; selected-minor-mode (provides extra keymap '' if a region is selected)
                  " wr" ;; wrap-region-mode, wraps a region with tags (e.g. '*' in org mode wraps marked region in ** )
                  " VHl" ;; volatile-highlights-mode (visual feedback to some operations related to regions)
                  " Paredit" ;;
                  " OTSH" ;; org table sticky headers
                  " ^L" ;; display ^L as continuous line
                  " ez-esc" ;; easy-escape displays regular expressions in a more readable way
                  ))))
    #+END_SRC
*** smart mode line (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      ;; make sure the install question is not interactively placed!
      ;; (setq sml/no-confirm-load-theme t)
      ;; (setq powerline-arrow-shape 'curve)   
      ;; (setq powerline-default-separator-dir '(right . left))
      ;; (setq sml/theme 'powerline)
      ;; (sml/setup)

      (req-package powerline)
      (req-package smart-mode-line-powerline-theme
        :require powerline)
      (req-package smart-mode-line
        :require powerline smart-mode-line-powerline-theme
        :init (add-hook 'after-init-hook 'sml/setup)
        :config
        (progn
          (setq sml/name-width 60) ;; max filename length
          ;; (setq sml/mode-width 'full) ;; mode are to be displayed fully
          (setq sml/shorten-directory t)
          (setq sml/shorten-modes t)

          (setq sml/col-number-format "%3c")

          (if after-init-time
              (sml/setup))

          ;; (require 'smart-mode-line-powerline-theme)
          ;; (sml/apply-theme 'dark)
          ;; Alternatives:
          (sml/apply-theme 'powerline)
          ;; (sml/apply-theme 'dark)
          ;; (sml/apply-theme 'light)
          ;; (sml/apply-theme 'respectful)
          ;; (sml/apply-theme 'automatic)
          ;; (setq powerline-default-separator 'arrow)
          ;;(setq powerline-default-separator-dir '(right . left))

          ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Projects/" ":iP:"))
          ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Utilities/" ":iU:"))
          (add-to-list 'sml/replacer-regexp-list '("^~/Documents/clojure/workspace" ":clj:"))))

    #+END_SRC
*** fancy battery (for modeline)
    Display of battery status in the emacs mode line (all the way to the left)
    See [[https://github.com/lunaryorn/fancy-battery.el][link]]
   #+BEGIN_SRC emacs-lisp
   (req-package fancy-battery
     :init (progn (add-hook 'after-init-hook #'fancy-battery-mode)))
   #+END_SRC
** rainbow mode
   #+BEGIN_SRC emacs-lisp
   (req-package rainbow-mode
     :init (add-hook 'help-mode-hook #'rainbow-mode))
   #+END_SRC
** rainbow identifiers
   #+BEGIN_SRC emacs-lisp
     ;; can be switched off by M-x rainbow-identifiers-mode, which toggles the mode
     (req-package rainbow-identifiers
       :init
       (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
   #+END_SRC
** cursor blinking / beacon
   #+BEGIN_SRC emacs-lisp
     ;; mark cursor when switching buffers/windows/frames
     (req-package crosshairs
       :require ace-window ;; optional, install cursor blink after ace window switch
                helm       ;; optional, install cursor blink after helm buffer switch
       :config
       (progn
       (defun blink-cursor-mode-off ()
         (blink-cursor-mode 0))

       (setq cursor-flash-timer nil)

       (defun cursor-flash (&optional seconds)
         "let cursor flash for three seconds"
         (interactive "P")
         (if cursor-flash-timer
             (cancel-timer cursor-flash-timer)) ; Cancel to prevent duplication.
         (blink-cursor-mode 0)
         (blink-cursor-mode 1)
         (let ((delay (or seconds 3)))
           (setq cursor-flash-timer (run-at-time
                                     delay nil
                                     #'blink-cursor-mode-off))))

       (defun cursor-ping (&optional seconds)
         (flash-crosshairs)
         (cursor-flash (or seconds 3)))

       ;; (toggle-crosshairs-when-idle t)
       (setq col-highlight-vline-face-flag  t
             col-highlight-face             
             hl-line-face)

       (global-set-key (kbd "C-+") '(lambda (&optional u) (interactive) (cursor-ping 1)))

       (defadvice switch-to-buffer (after switch-to-buffer-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (when (package-installed-p 'helm)
         (defadvice helm-buffer-list (after helm-buffer-list-flash-crosshairs activate)
           "Call `flash-crosshairs' after `switch-to-buffer'"
           (cursor-ping 2)))

       (defadvice ns-next-frame (after ns-next-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (defadvice ns-prev-frame (after ns-prev-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `ns-prev-frame'"
         (cursor-ping 2))

       (defadvice other-window (after other-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `other-window'"
         (cursor-ping 1))

       (defadvice delete-window (after delete-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching because of `delete-window'"
         (cursor-ping 1))
  
       (when (package-installed-p 'ace-window)
         (defadvice ace-window (after ace-window-flash-crosshairs activate)
           "Call `flash-crosshairs' after switching with `ace-window'"
           (cursor-ping 1)))))
   #+END_SRC
** window arrangement
   - [[https://github.com/wasamasa/shackle][github]]
   - [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-shackle.el][example usage]]
   #+BEGIN_SRC emacs-lisp
          (req-package shackle
            :config
            (progn
            (shackle-mode 1)
            (setq shackle-rules 
                  '(
                    ("*helm M-x*"            :align right :size 0.3)
                    ("*helm imenu-anywhere*" :align right :size 0.5)
                    ("*helm for files*"      :align right :size 0.5)
                    ("*undo-tree*"           :align right :size 0.25)
                    ))))
   #+END_SRC
** linenumbers
   #+BEGIN_SRC emacs-lisp
     (req-package nlinum
       :bind (("M-g M-g" . goto-line-with-feedback))
       :init (progn
         (defun goto-line-with-feedback ()
           "Show line numbers temporarily, while prompting for the line number input"
           (interactive)
           (unwind-protect
               (progn
                 (nlinum-mode 1)
                 (goto-line (read-number "Goto line: ")))
             (nlinum-mode -1)))
       )
       :config
       (progn
         (setq linum-delay t)
         ;; (global-set-key [remap goto-line] 'goto-line-with-feedback)

         ;; (setq global-nlinum-mode t)
         ))
   #+END_SRC
** toggle serif font
   #+BEGIN_SRC emacs-lisp
     (defvar serif-preserve-default-list nil
       "A list holding the faces that preserve the default family and
       height when TOGGLE-SERIF is used.")

     (setq serif-preserve-default-list
           '(;; LaTeX markup
             font-latex-math-face
             font-latex-sedate-face
             font-latex-warning-face
             ;; org markup
             org-latex-and-related
             org-meta-line
             org-verbatim
             org-block-begin-line
             ;; syntax highlighting using font-lock
             font-lock-builtin-face
             font-lock-comment-delimiter-face
             font-lock-comment-face
             font-lock-constant-face
             font-lock-doc-face
             font-lock-function-name-face
             font-lock-keyword-face
             font-lock-negation-char-face
             font-lock-preprocessor-face
             font-lock-regexp-grouping-backslash
             font-lock-regexp-grouping-construct
             font-lock-string-face
             font-lock-type-face
             font-lock-variable-name-face
             font-lock-warning-face))

     (defun toggle-serif ()
       "Change the default face of the current buffer to use a serif family."
       (interactive)
       (when (display-graphic-p)  ;; this is only for graphical emacs
         ;; the serif font familiy and height, save the default attributes
         (let ((serif-fam "Source Serif Pro")
               (serif-height 120)
               (default-fam (face-attribute 'default :family))
               (default-height (face-attribute 'default :height)))
           (if (not (bound-and-true-p default-cookie))
               (progn (make-local-variable 'default-cookie)
                      (make-local-variable 'preserve-default-cookies-list)
                      (setq preserve-default-cookies-list nil)
                      ;; remap default face to serif
                      (setq default-cookie
                            (face-remap-add-relative
                             'default :family serif-fam :height serif-height
                             :weight 'light
                             ))
                      ;; keep previously defined monospace fonts the same
                      (dolist (face serif-preserve-default-list)
                        (add-to-list 'preserve-default-cookies-list
                                     (face-remap-add-relative
                                      face :family default-fam :height default-height)))
                      (text-scale-increase 2)
                      (message "Turned on serif writing font."))
             ;; undo changes
             (progn (face-remap-remove-relative default-cookie)
                    (dolist (cookie preserve-default-cookies-list)
                      (face-remap-remove-relative cookie))
                    (setq default-cookie nil)
                    (setq preserve-default-cookies-list nil)
                    (text-scale-decrease 2)
                    (message "Restored default fonts."))))))
   #+END_SRC
** form feed
   - display ^L as h-bar
   #+BEGIN_SRC emacs-lisp
     (req-package form-feed
       :init
       (progn (add-hook 'text-mode-hook #'form-feed-mode)))
   #+END_SRC
** hide show org like
   - if tab does not indent, folding is done
   #+BEGIN_SRC emacs-lisp
   (req-package hideshow-org
     :init (add-hook 'text-mode #'hs-org/minor-mode))
   #+END_SRC
** highlight indent
   - Minor mode to highlight indentation
   #+BEGIN_SRC emacs-lisp
   (req-package highlight-indent-guides
     :init (add-hook 'prog-mode-hook #'highlight-indent-guides-mode)
     :config
     (progn
       (set-face-background 'highlight-indent-guides-odd-face "darkgray")
       (set-face-background 'highlight-indent-guides-even-face "dimgray")
       (setq highlight-indent-guides-character ?\|)
       (setq highlight-indent-guides-method 'character)))
   #+END_SRC
* editing related stuff
** auto-fill-mode configuration
   - will word break / line break after column _
   #+BEGIN_SRC emacs-lisp
     (setq fill-column 140)
     (set-default 'fill-column 140)
     (defun gb/enable-auto-fill-mode ()
       "enable auto-fill-mode regardless of current state"
       (auto-fill-mode +1))
   #+END_SRC
** keep some session stuff
   - will keep helm-M-x history after restart
   - will keep recent in file location even for org files
   #+begin_src emacs-lisp 
     (req-package session
       :init (add-hook 'after-init-hook 'session-initialize)
       :config
       (progn
         (setq session-name-disable-regexp "\\(\\`/tmp\\|COMMIT_EDITMSG\\)")))
   #+end_src
** smart-region
   1. set mark, repetitive calls to M-x smart-region will call er/expand-region
   2. set mark, move up/down, stay in same column, call M-x smart-region will open mc/multiple-cursor on each line
      easier to reach via C-S-> and C-S-<
   3. set mark, move right/left/up/down, call M-x smart-region will make a rectangular selection
   #+begin_src emacs-lisp 
   (req-package smart-region
     :commands smart-region
     :require expand-region multiple-cursors)
   #+end_src
** edit-indirect
   - edit region in separate buffer (and guess mode)
   #+begin_src emacs-lisp 
   (req-package edit-indirect
     :commands edit-indirect-region edit-indirect-commit)
   #+end_src
** autosave
   #+BEGIN_SRC emacs-lisp
   (setq auto-save-interval 500)
   #+END_SRC
** ws-butler
   - remove trailing whitespaces upon save (unobtrusively, that is only in lines actually changed)
   - [[https://github.com/lewang/ws-butler][home page]]
   #+BEGIN_SRC emacs-lisp
     (req-package ws-butler
       :config
       (progn
         (ws-butler-global-mode 1)))
   #+END_SRC
** encoding
   #+BEGIN_SRC emacs-lisp
     (prefer-coding-system 'utf-8-unix)
     (set-default-coding-systems 'utf-8-unix)
     (set-terminal-coding-system 'utf-8-unix)
     (set-keyboard-coding-system 'utf-8-unix)
     (set-selection-coding-system 'utf-8-unix)
     (setq-default buffer-file-coding-system 'utf-8-unix)
     ;; (set-language-environment "UTF-8")
   #+END_SRC
** easy-escaping
   - display escaping \ (which is normaly doubled) as single red backslash
   #+BEGIN_SRC emacs-lisp
     (req-package easy-escape
       :init (add-hook 'prog-mode-hook 'easy-escape-minor-mode)
       :config
       (progn
         (set-face-attribute 'easy-escape-face nil :foreground "red") ;; make a \\ stand out as red backslash
         ))
   #+END_SRC
** schrute mode (make suggestions) disabled
   #+begin_src emacs-lisp :tangle no
     (req-package schrute
       :disabled t
       :config
       (progn
         (defun msgavy ()
           (interactive)
           (message "try avy-goto-line"))
         (setf schrute-shortcuts-commands
               '((msgavy      . (next-line previous-line))))
         (schrute-mode)))
   #+end_src
** german umlaute
   - standard binding is C-x 8 " a|o|u|s
   - key-chords: hit a|u|o and e simultaneously => umlaut
   - other-key: hit C-" then a|u|o|s => umlaut,
   #+BEGIN_SRC emacs-lisp
     (progn
       (require 'bind-key)
       (require 'key-chord)
       (bind-key "C-\" a" (lambda () (interactive) (insert "")))
       (bind-key "C-\' a" (lambda () (interactive) (insert "")))
       (bind-key "C-\" A" (lambda () (interactive) (insert "")))
       (key-chord-define-global "AE" (lambda () (interactive) (insert "")))
       ;;(key-chord-define-global "ae" (lambda () (interactive) (insert "")))
       (bind-key "C-\" u" (lambda () (interactive) (insert "")))
       (bind-key "C-\' u" (lambda () (interactive) (insert "")))
       (bind-key "C-\" U" (lambda () (interactive) (insert "")))
       (key-chord-define-global "UE" (lambda () (interactive) (insert "")))
       ;;(key-chord-define-global "ue" (lambda () (interactive) (insert "")))
       (bind-key "C-\" o" (lambda () (interactive) (insert "")))
       (bind-key "C-\' o" (lambda () (interactive) (insert "")))
       (bind-key "C-\" O" (lambda () (interactive) (insert "")))
       (key-chord-define-global "OE" (lambda () (interactive) (insert "")))
       ;; (key-chord-define-global "oe" (lambda () (interactive) (insert "")))
       (bind-key "C-\" s" (lambda () (interactive) (insert "")))
       (bind-key "C-\' s" (lambda () (interactive) (insert "")))
       (bind-key "C-\" S" (lambda () (interactive) (insert ""))))
   #+END_SRC
** hungry delete (disabled, testing smart hungry delete)
   - delete all spaces before/after when using backspace/delete
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package hungry-delete
       :bind (( "C-S-d" . hungry-delete-forward)
              ( "S-<backspace>" . hungry-delete-backward)))
   #+END_SRC
** editing
#+BEGIN_SRC emacs-lisp
  ;; No need for ~ files when editing
  (setq create-lockfiles nil)  

  ;; Customizations relating to editing a buffer.
  ;; enable C-x C-u to do upcase on region (which is disabled by default)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

  ;; display tabs as four spaces
  (setq default-tab-width 4)
  (setq tab-width 4)

  ;; indent all c and derived sources (java, groovy) with the basic 4 indent
  (defun gb/c-mode-hook ()
    (setq indent-tabs-mode nil
          c-basic-offset 4))
  (add-hook 'c-mode-common-hook 'gb/c-mode-hook)


  ;; make sure that C-k kills to the end of line and the whole line if cursor is at the start of the line
  (setq-default kill-whole-line t)

  ;; automatically reload open buffers if they changed on disk
  (global-auto-revert-mode 1)

  ;; overwrite selected text
  (delete-selection-mode t)

  ;; Lisp-friendly hippie expand
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))

  ;; Highlights matching parenthesis
  (show-paren-mode 1)

  ;; Highlight current line
  (global-hl-line-mode 1)
  (custom-set-faces
   '(hl-line ((t (:background "gray22"))))
   '(highlight ((t (:background "gray22")))))

  ;; Don't use hard tabs
  (setq-default indent-tabs-mode nil)

  ;; after indent is ok, try to complete
  (setq tab-always-indent 'complete)
  (add-to-list 'completion-styles 'initials t)
  ;; Emacs can automatically create backup files. This tells Emacs to
  ;; put all backups in ~/.emacs.d/backups. More info:
  ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                 "backups"))))
  (setq auto-save-default nil)


  (req-package rainbow-delimiters
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

  (defun die-tabs ()
    "remove all tabs within this buffer using spaces, interpreting a tab as 8 spaces"
    (interactive)
    (set-variable 'tab-width 8)
    (mark-whole-buffer)
    (untabify (region-beginning) (region-end))
    (keyboard-quit))

  ;; fix weird os x kill error
  (defun ns-get-pasteboard ()
    "Returns the value of the pasteboard, or nil for unsupported formats."
    (condition-case nil
        (ns-get-selection-internal 'CLIPBOARD)
      (quit nil)))

  (setq electric-indent-mode nil)

#+END_SRC
** toggle commands (C-x t ...)
   #+BEGIN_SRC emacs-lisp
     (define-prefix-command 'gb/toggle-map)
     ;; The manual recommends C-c for user keys, but C-x t is
     ;; always free, whereas C-c t is used by some modes.
     (define-key ctl-x-map "t" 'gb/toggle-map)
     (define-key gb/toggle-map "c" #'column-number-mode)
     (define-key gb/toggle-map "d" #'toggle-debug-on-error)
     (define-key gb/toggle-map "e" #'toggle-debug-on-error)
     (define-key gb/toggle-map "f" #'auto-fill-mode)
     (define-key gb/toggle-map "h" #'highlight-thing-mode)
     (define-key gb/toggle-map "i" #'gb/toogle-highlight-what-thing)
     (define-key gb/toggle-map "k" #'flycheck-mode)
     (define-key gb/toggle-map "l" #'toggle-truncate-lines)
     (when (fboundp 'gb/toggle-visible-mark-mode)
       (define-key gb/toggle-map "m" #'gb/toggle-visible-mark-mode))
     (define-key gb/toggle-map "p" #'toggle-serif)
     (define-key gb/toggle-map "q" #'toggle-debug-on-quit)
     (define-key gb/toggle-map "r" #'toggle-word-wrap)
     (define-key gb/toggle-map "s" #'flyspell-mode)
     (when (fboundp 'gb/toggle-ligatures)
       (define-key gb/toggle-map "t" #'gb/toggle-ligatures))
     (define-key gb/toggle-map "u" #'gb/switch-dictionary)
     (define-key gb/toggle-map "w" #'whitespace-mode)
     (define-key gb/toggle-map "5" #'toggle-frame-fullscreen)
   #+END_SRC
** browse kill ring
   - allow to browse kill ring via M-y and insert from arbitrary positions
   #+BEGIN_SRC emacs-lisp
     (req-package browse-kill-ring
       ;; bind M-y to interactively browsing the kill ring buffer
       :config
       (browse-kill-ring-default-keybindings))
   #+END_SRC
** save-place
   - When you visit a file, point goes to the last place where it
     was when you previously visited the same file.
   - http://www.emacswiki.org/emacs/SavePlace
   #+BEGIN_SRC emacs-lisp
     (if (not (version< emacs-version "25.0"))
        ;; for later emacs versions, save place is no separate packate, but built in
        (progn (save-place-mode +1)
               (setq save-place-file (concat user-emacs-directory "places")))
     (req-package saveplace
       :config
       (progn
         (save-place-mode +1)
         ;; keep track of saved places in ~/.emacs.d/places
         (setq save-place-file (concat user-emacs-directory "places")))))
   #+END_SRC
** save on focus loss
   #+BEGIN_SRC emacs-lisp
     (defun save-all ()
       (interactive)
       (save-some-buffers t))
     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC
** undo tree
   - C-x u opens the undo tree and lets you move through the tree of undo/redo
   #+BEGIN_SRC emacs-lisp 
     (req-package undo-tree
       :config
       (progn
         ;; (setq undo-tree-auto-save-history t) ;; it seems that this feature regularly causes emacs to crash, if this history file cannot be read properly
         (setq undo-tree-visualizer-diff t) ;; display diff to previous
         (global-undo-tree-mode)))
   #+END_SRC
** very large files
   - edit very large files in chunks (see [[https://github.com/m00natic/vlfi][here]])
   #+BEGIN_SRC emacs-lisp
     (req-package vlf
       :defer 7
       :config (require 'vlf-setup))
   #+END_SRC
** volatile hightlighting
   - highlight blocks associated with buffer commands until any key is pressed
     (e.g. highlight pasted text)
   #+BEGIN_SRC emacs-lisp
     (req-package volatile-highlights
       :config
       (volatile-highlights-mode t))
   #+END_SRC
** region related editing
*** wrap-region
    - works nicely together with expand region
    - simple mark a region and hit the key '(' e.g. to wrap marked region with parenthesis
    #+BEGIN_SRC emacs-lisp
      ;; wrap-region
      (req-package wrap-region
        :config
        (progn
          (wrap-region-global-mode 1)
          (wrap-region-add-wrappers
            ;; default includes ( { [ ' ", so there is no need to define those
           '(("*" "*" nil (markdown-mode org-mode))
             ("~" "~" nil (markdown-mode org-mode))
             ("/" "/" nil (markdown-mode org-mode))
             ("=" "=" "+" (markdown-mode org-mode))
             ("_" "_" nil (markdown-mode org-mode))
             ("$" "$" nil (org-mode latex-mode))
             ("/*" "*/" "/" java-mode)))
          (add-to-list 'wrap-region-except-modes 'gnus-group-mode)
          (add-to-list 'wrap-region-except-modes 'gnus-summary-mode)  ;; don't remap / key, since it is used to limit mail list
          ;; hooks only useful if global region mode is not set (see above)
          ;; (add-hook 'org-mode-hook 'wrap-region-mode)
          ;; (add-hook 'latex-mode-hook 'wrap-region-mode)
          ;; (add-hook 'prog-mode 'wrap-region-mode)
          ))
#+END_SRC
*** embrace region
    - embrace symbol/word ... with ", ', ( { [ ...
    - key binding is Press C-, a w ' to add '' to the current word:
    #+BEGIN_SRC emacs-lisp
    (req-package embrace
      :require expand-region)
    #+END_SRC
*** change-inner
    #+BEGIN_SRC emacs-lisp
      (req-package change-inner
        :require expand-region
        :bind (("M-i" . change-inner)
               ("M-o" . change-outer)))
    #+END_SRC
*** easy kill
    - see [[https://github.com/leoliu/easy-kill][here]]
    - M-w selects the following in the order of availability:
      active region, url, email and finally current line
    - M-w is also a prefix that can be followed by
      - w save word at point
      - b save buffer file name (including path) or default-directory
      - s save sexp at point
      - l save list at point (enclosing sexp)
      - d save defun at point
      - D save defun name at point
      - f save file at point
    - the following keys modify the selection (following the key above)
      - @ append selection to previous kill
      - C-w kill selection and exit
      - +, - and 1..9 expand/shrink the selection
      - 0 shrink selection to initial size
      - C-SPC turn selection into an active region
      - C-g abort
      - ? help
    #+BEGIN_SRC emacs-lisp
    (req-package easy-kill
      :init (global-set-key [remap kill-ring-save] 'easy-kill))
    #+END_SRC
*** expand region
    expand / shrink region smartly
    #+BEGIN_SRC emacs-lisp
      (req-package expand-region
        :require key-chord ;; optional, install key chords that do region expansion/shrink
        ;; :defer t ;; valid since init script registeres keys
        :init
        (autoload 'expand-region "er/expand-region" nil t)
        (autoload 'expand-region "er/contract-region" nil t)
        (when (package-installed-p 'key-chord)
          (key-chord-define-global "+"   'er/expand-region) ;; make the current selection expand to the next outer bounds
          (key-chord-define-global "]["   'er/expand-region) ;; make the current selection expand to the next outer bounds
          (key-chord-define-global ".-"   'er/contract-region)
          (key-chord-define-global "./"   'er/contract-region))) ;; make the current selection collapse again into the inner bounds
    #+END_SRC
** subword (internal programming minor mode)
   #+BEGIN_SRC emacs-lisp
   (req-package subword
     )
   #+END_SRC
** multicursor
   #+BEGIN_SRC emacs-lisp
       (req-package multiple-cursors
         :require hydra
         ;; bind currently does not work since some other project loads multiple cursors without req-package actually loading this!
          :bind (
                 ;; When you have an active region that spans multiple lines, the following will
                 ;; add a cursor to each line:
                 ("C-S-c C-S-c" . mc/edit-lines)

                 ;; When you want to add multiple cursors not based on continuous lines, but based on
                 ;; keywords in the buffer, use:

                 ("C->" . mc/mark-next-like-this)
                 ("C-<" . mc/mark-previous-like-this)
                 ("C-c C-<" . mc/mark-all-like-this) ;; mark textually (even substrings)
                 ("C-c C->" . mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
                 )
         :config
         (progn
           ;; add a cursor to each line:
           ;; (bind-key "C-S-c C-S-c" 'mc/edit-lines)

           ;; When you want to add multiple cursors not based on continuous lines, but based on
           ;; keywords in the buffer, use:

           ;; (bind-key "C->" 'mc/mark-next-like-this)
           ;; (bind-key "C-<" 'mc/mark-previous-like-this)
           ;; (bind-key "C-c C-<" 'mc/mark-all-like-this) ;; mark textually (even substrings)
           ;; (bind-key "C-c C->" 'mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
           (defhydra hydra-multiple-cursors ()
             "
                     ^Up^            ^Down^          ^Other^
                     ----------------------------------------------
                     [_p_]   Next    [_n_]   Next    [_l_] Edit lines
                     [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
                     [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
                     ^ ^             ^ ^             [_m_] Mark by avy
                     ^ ^             ^ ^             [_q_] Quit
                 %s(hydra-combine-functions-w-key-bindings 
                   '((\"    [p]   Up-Next       \" . mc/mark-previous-like-this)
                     (\"    [P]   Up-Skip       \" . mc/skip-to-previous-like-this)
                     (\"    [M-p] Up-Unmark     \" . mc/unmark-previous-like-this)
                     (\"    [n]   Down-Next     \" . mc/mark-next-like-this)
                     (\"    [N]   Down-Skip     \" . mc/skip-to-next-like-this)
                     (\"    [M-n] Down-Unmark   \" . mc/unmark-next-like-this)
                     (\"    [l]   Edit lines    \" . mc/edit-lines)
                     (\"    [a]   Mark all      \" . mc/mark-all-like-this)
                     (\"    [r]   Mark by regexp\" . mc/mark-all-in-region-regexp)
                     (\"    [m]   Mark by avy   \" . ace-mc-add-multiple-cursors)))
                     "
             ("l" mc/edit-lines :exit t)
             ("a" mc/mark-all-like-this :exit t)
             ("n" mc/mark-next-like-this)
             ("N" mc/skip-to-next-like-this)
             ("M-n" mc/unmark-next-like-this)
             ("p" mc/mark-previous-like-this)
             ("P" mc/skip-to-previous-like-this)
             ("M-p" mc/unmark-previous-like-this)
             ("r" mc/mark-all-in-region-regexp :exit t)
             ("m" ace-mc-add-multiple-cursors :exit t)
             ("q" (message "Abort") :exit t))))
   #+END_SRC
** IMPLEMENT ace-mc
   - mark multiple cursors using avy to jump to the places that should be multicursored!
     - available functions are: ace-mc-add-multiple-cursors
   #+BEGIN_SRC emacs-lisp
     (req-package ace-mc
       :commands ace-mc-add-multiple-cursors ace-mc-add-single-cursor
       :bind (("C-|" . ace-mc-add-multiple-cursors))
       :require avy multiple-cursors ace-jump-mode)
   #+END_SRC
** key-chord
   #+BEGIN_SRC emacs-lisp
     (req-package key-chord
       :config
       (progn
         (setq key-chord-two-keys-delay 0.10)
         (setq key-chord-one-key-delay 0.20)
         (key-chord-mode 1)

         ;; (key-chord-define-global "hj"   'undo)

         ;; (key-chord-define-global "12"   'delete-other-windows) ;; key 12 is too often typed directly after each other => function is triggered unwanted
         ;; (key-chord-define-global "23"   'split-window-below)
         ;; (key-chord-define-global "34"   'split-window-right)
         ;; (key-chord-define-global "0"   'delete-window)

         ))
   #+END_SRC
** space-chord (currently disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; last time I had to install this via M-x el-get-list-packages before it actually started working
     ;; when using space as an alternative to control this will not work right
     (el-get-bundle space-chord)
     (req-package space-chord
       :loader :el-get
       :require key-chord
       :config
       (progn
         (setq space-chord-delay 0.08)
         (space-chord-define-global "f" 'find-file) ;; just an example
         (space-chord-define-global "u" 'undo)
         ))
   #+END_SRC
** highlight thing
   #+BEGIN_SRC emacs-lisp
     (req-package highlight-thing
       :require key-chord ;; optional, install key chord to highlight thing
       :init (progn
         ;; make sure that during marking words, the highlighting is switched (temporarily) off
         (add-hook 'activate-mark-hook 'highlight-thing-mode-temporary-off)
         (add-hook 'deactivate-mark-hook 'highlight-thing-mode-temporary-on))
       :config
       (progn
       (setq highlight-thing-delay-seconds 1)
       (setq highlight-thing-what-thing 'symbol)
       ;; customize face hi-yellow

       ;; highlight all identical 'words in view
       (when (package-installed-p 'key-chord)
                  (key-chord-define-global "\\'" (function highlight-thing-mode))
                  (key-chord-define-global "#" (function highlight-thing-mode)))

       (setq highlight-thing-mode-temporary nil)

       (defun highlight-thing-mode-temporary-on ()
         "switch the tepmorary switched off mode on again (if it was on)"
         (interactive)
         (if highlight-thing-mode-temporary
             (progn
               (setq highlight-thing-mode-temporary nil)
               (highlight-thing-mode 1)
               (highlight-thing-schedule-timer))))

       (defun highlight-thing-mode-temporary-off ()
         "switch highlight thing mode temporary off (if it was on)"
         (interactive)
         (let ((hlmode highlight-thing-mode))
           (if hlmode
               (progn 
                 (setq highlight-thing-mode-temporary t)
                 (highlight-thing-remove-last)
                 (highlight-thing-mode 0))
             )))

       ))
   #+END_SRC
** highlight symbol
   #+BEGIN_SRC emacs-lisp
     (req-package highlight-symbol
       :bind (("C-c h" . highlight-symbol))
       :config 
       (progn 
         (setq  highlight-symbol-foreground-color "Gray52")))
   #+END_SRC
** bookmarking (needs hydra)
   #+BEGIN_SRC emacs-lisp
     (req-package bm
       :bind
       ( "C-c b t" . bm-toggle)
       ( "C-c b n" . bm-next)
       ( "C-c b p" . bm-previous)
       ( "C-c b s" . bm-show) 
       ( "C-c b S" . bm-show-all)
       ( "C-c b r" . bm-bookmark-regexp)
       ( "C-c b A" . bm-bookmark-annotate)
       ( "C-c b a" . bm-bookmark-show-annotation))
   #+END_SRC
** additional functions
   #+BEGIN_SRC emacs-lisp
     (when (functionp #'nxml-pretty-format)
     (defun gb/replace-buffer-with-yank ()
       "replace the whole buffer with the first item on the kill ring"
       (interactive)
       (erase-buffer)
       (yank)
       (if (string/starts-with (buffer-substring 1 6) "<?xml")
           (nxml-pretty-format))))
   #+END_SRC
** aggressive indent mode (also used by parinfer) 
   automatically indents all while typing 
   #+BEGIN_SRC emacs-lisp
   (req-package aggressive-indent
     :config
     (progn ;; (global-aggressive-indent-mode 1) ;; enable mode for all programming modes
            (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
            ;;(add-to-list 'aggressive-indent-excluded-modes 'clojure-mode)
            ;;(add-to-list 'aggressive-indent-excluded-modes 'emacs-lisp-mode)
            )) ;; disable mode for ...
   #+END_SRC
** with editor
   #+BEGIN_SRC emacs-lisp
   (req-package with-editor
     :require async)
   #+END_SRC
** selected (provide special keybindings if selections are active)
   - https://github.com/Kungsgeten/selected.el
   #+BEGIN_SRC emacs-lisp 
     (req-package selected
       :init (progn
         (add-hook 'org-mode-hook 'selected-minor-mode)
         (add-hook 'prog-mode-hook 'selected-minor-mode))
       :bind (:map selected-keymap
              ("a" . mc/mark-all-like-this)
              ("d" . downcase-region)
              ("i" . indent-region)
              ("m" . mc/mark-more-like-this-extended)
              ("q" . selected-off)
              ("u" . upcase-region)
              ("w" . count-words-region)
              ("<" . mc/mark-previous-like-this)
              (">" . mc/mark-next-like-this))
       :config
       (progn ))
   #+END_SRC
* language specific stuff
** langtool (very! elaborate spellchecking)
   - instrument languagetool (see [[https://www.languagetool.org/][here]])
     installed via 'brew install languagetool'
   - description see [[https://github.com/mhayashi1120/Emacs-langtool][here]]
   - TODO: change interface to use json (thus some other details can be used for display)
     json parsing with elisp see [[http://tess.oconnor.cx/2006/03/json.el][here]]
     adjustments to (langtool--process-filter) will have to be made, in order to parse json results
   #+BEGIN_SRC emacs-lisp
     (when languagetool-installed
       (req-package langtool
         :require s
         :commands (langtool-check
                    langtool-check-buffer
                    langtool-check-done
                    langtool-switch-default-language
                    langtool-show-message-at-point
                    langtool-correct-buffer)
         :init
         (progn
           (defun langtool-autoshow-detail-popup (overlays)
             (when (require 'popup nil t)
               ;; Do not interrupt current popup
               (unless (or popup-instances
                           ;; suppress popup after type `C-g` .
                           (memq last-command '(keyboard-quit)))
                 (let ((msg (langtool-details-error-message overlays)))
                   (popup-tip msg)))))
           (setq langtool-autoshow-message-function
                 'langtool-autoshow-detail-popup)
           )
         :config
         (when (is-_nix-p)
           (let ((jar-file (concat (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/^CP=\\(.*\\)/\\1/p'")) "/languagetool-commandline.jar")))
             (cond ((file-exists-p jar-file) (setq langtool-language-tool-jar jar-file))
                   ((file-exists-p "/usr/share/languagetool") (setq langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*"))
                   (t (message (format "ERROR: langtool jar not found at '%s' nor in '/usr/share/languagetool'" jar-file))))))
         (when (is-macos-p)
           (let ((jar-file (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/.*-jar.\\(.*\\) \".*/\\1/p'"))))
             (if (file-exists-p jar-file)
                 (progn
                   (message "OK: langtool jar file found")
                   (setq langtool-language-tool-jar jar-file))
               (message (format "ERROR: langtool jar not found at '%s'" jar-file)))))

         (setq langtool-default-language "en-US")
         (setq langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))))
   #+END_SRC
** flyspell
   installation of ispell german dictionary:
   - arch linux:
     #+BEGIN_SRC bash :tangle no
     sudo pacman -S aspell-en aspell-de
     #+END_SRC
   - mac:
     - download from https://www.j3e.de/ispell/igerman98/
     - unpack, edit make file (remove unnecessary languages), execute make
     - copy *.hash from subdir ispell into /usr/local/Cellar/ispell/3.4.00/lib/ispell/ (e.g. de_DE.hash)
     - create link 'ln -s de_DE.hash deutsch.hash'
     - TODO: make gb/switch-dictionary use a variable for hooks that are all called when registration took place! langtool then only registers
       an additional hook. the hook should use well defined languages as parameters to let each hook what exactly to set
   #+BEGIN_SRC emacs-lisp
     (req-package flyspell
       :require org
       :init (progn
       (defun gb/activate-ispell-in-org-mode ()
         "activate ispell and try to select to right language (e.g. `#+language: de')
       disable spell checking if `#+PROPERTY: spellcheck no' is set"
         (let* ((spellCheck (gb/org-global-prop-value "spellcheck")))
           (if (string= spellCheck "no")
               (progn (flyspell-mode 0))
             (require 'ox)
             (let* ((fileLang (plist-get (org-export--get-inbuffer-options) :language)))
               (if (string= fileLang "de")
                        (ispell-change-dictionary "deutsch8")
                      (ispell-change-dictionary "english"))
                    (turn-on-flyspell)))))

       ;; switch between german and english dicionary
       (defun  gb/switch-dictionary()
         (interactive)
         (let* ((oldLang ispell-current-dictionary)
                (newLang (if (string= oldLang "deutsch8") "english" "deutsch8"))
                (oldLangtool (if (boundp 'langtool-default-language) langtool-default-language nil))
                (newLangtool (if (string= oldLangtool "de") "en-US" "de")))
           (ispell-change-dictionary newLang)
           (if (boundp 'langtool-default-language) (setq langtool-default-language newLangtool))
           (message "Dictionary switched from `%s' to `%s'" oldLang newLang)))

       (add-hook 'message-mode-hook 'turn-on-flyspell)
       (add-hook 'org-mode-hook 'gb/activate-ispell-in-org-mode)
       )
       :bind (("C-x l" . gb/switch-dictionary))
       :config
       (progn
       (require 'ox)
       (setq ispell-dictionary "deutsch8")
       (setq ispell-local-dictionary "deutsch8")
       (setq flyspell-default-dictionary "deutsch8")

       ;; for programmiong modes, switch to english and activate flyspell-prog-mode
       ;; (dolist (hook '(prog-mode-hook))
       ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "english")(flyspell-prog-mode 1)))))

       ;; for orgmode, switch to english and activate flyspell
       ;; (dolist (hook '(org-mode-hook))
       ;;   (add-hook hook (lambda () (flyspell-mode 1))))

       ;; for mails, switch to german dictionary and activate flyspell
       ;; (dolist (hook '(message-mode-hook))
       ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "deutsch8")(flyspell-mode 1)))))

       ;; don't print error message for every mispelled word found
       (setq flyspell-issue-message-flag nil)


       ))
   #+END_SRC
** dictionary
   - description [[http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary][here]]
   - downloaded from [[https://github.com/gucong/emacs-sdcv][here]]
   - use dictionary in startdict format from ~/.stardict/dic
   #+BEGIN_SRC emacs-lisp
     (if (file-exists-p "~/.emacs.d/additionals/sdcv-mode.el")
         (req-package sdcv-mode
           :commands sdcv-search
           :load-path "~/.emacs.d/additionals"))
   #+END_SRC
** look up definition
   - 'H-d' (it's fn-d on mac) will lookup (english) definition of the word at point
   - 'H-D' will query for the word to find the definition for
   #+BEGIN_SRC emacs-lisp
     (req-package define-word
       :bind (("H-d" . define-word-at-point)
              ("H-D" . define-word)))
   #+END_SRC
* auto complete, help, man etc.
** which key
#+BEGIN_SRC emacs-lisp
  (req-package which-key
    :config
    (progn
    (bind-key "C-h y" #'which-key-show-top-level)
    (which-key-mode)
    (which-key-setup-side-window-right)
    (validate-setq which-key-side-window-max-width 0.4)
    (setq which-key-max-description-length 45)
    (setq which-key-popup-type 'side-window)
    ))
#+END_SRC
** keyfreq
   #+BEGIN_SRC emacs-lisp
     (req-package keyfreq
       :config
       (progn
       (keyfreq-mode 1)
       (keyfreq-autosave-mode 1)
       ;; use M-x keyfreq-show to show the frequency of key usages
       ))
   #+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (req-package company-try-hard
    :require company
    :config
      (progn
      (global-set-key (kbd "M-TAB") #'company-try-hard)
      (global-set-key (kbd "<C-tab>") #'company-try-hard)
      (define-key company-active-map (kbd "M-TAB") #'company-try-hard)
      ))
  ;; enable company mode anywhere
  (req-package company
    :init (progn
      (add-hook 'after-init-hook 'global-company-mode))
    :config
    (progn
      (setq company-show-numbers t)
      ;; use numbers 0-9 to select company completion candidates
      (let ((map company-active-map))
        (mapc (lambda (x) (define-key map (format "%d" x)
                       `(lambda () (interactive) (company-complete-number ,x))))
              (number-sequence 0 9)))

      (setq company-minimum-prefix-length 4)
      (setq company-tooltip-limit 15)
      (setq company-tooltip-flip-when-above t)
      (setq company-dabbrev-downcase nil) ;; make company suggestions case sensitive (no downcase conversion)
      (setq company-backends
            (quote
             (company-capf company-shell company-bbdb company-semantic company-files
                           company-dabbrev-code company-gtags company-etags company-keywords
                           company-oddmuse company-dabbrev)))
      (setq company-dabbrev-code-modes
            (quote
             (prog-mode
              batch-file-mode
              css-mode
              ;; erlang-mode
              ;; haskell-mode
              ;; jde-mode
              ;; lua-mode
              ;; python-mode
              clojure-mode
              ;; scala-mode
              )))

      (custom-set-faces
       '(company-echo-common ((t (:inherit company-echo :foreground "black"))))
       '(company-preview ((t (:foreground "black"))))
       '(company-preview-common ((t (:foreground "tomato2"))))
       '(company-tooltip ((t (:background "gold2" :foreground "black"))))
       '(company-tooltip-selection ((t (:background "gray23" :foreground "white"))))
       '(company-tooltip-common ((t (:foreground "firebrick4"))))
       '(company-tooltip-annotation ((t (:foreground "gray40")))))


      ))

  (req-package company-statistics
    :require company
    :init
    (progn
      (add-hook 'after-init-hook 'company-statistics-mode)))

  (req-package company-quickhelp
    :require company
    :config
    (progn
      (company-quickhelp-mode 1)
      (setq company-quickhelp-use-propertized-text t)
      (setq company-quickhelp-max-lines 60)
      ))
#+END_SRC
** company flx
   #+BEGIN_SRC emacs-lisp
     (req-package company-flx
       :require company
       :config
       (with-eval-after-load 'company (add-hook 'company-mode-hook (lambda () (add-to-list 'company-backends 'company-capf))) (company-flx-mode +1)))
   #+END_SRC
** IMPLEMENT company-shell 
   - provide company help for fish (or other shell) completions within modes like (fish-mode, shell-mode)
   #+BEGIN_SRC emacs-lisp
     (req-package company-shell
       :require company
       :config (add-to-list 'company-backends 'company-shell))
   #+END_SRC
** helm-company
   #+BEGIN_SRC emacs-lisp
     (req-package helm-company
       :require helm company
       :bind (:map company-mode-map
              ("C-:" . helm-company)
              :map company-active-map
              ("C-:" . helm-company)))
   #+END_SRC
** helm-descbind
   - describe current keybindings with helm interface
   #+BEGIN_SRC emacs-lisp
     (req-package helm-descbinds
       :require helm company
       :bind (("\C-h b" . helm-descbinds)))
   #+END_SRC
** helm-dash
   - add new sources for helm dash via helm-dash-install-docset
   - browse doc set via helm-dash
   #+BEGIN_SRC emacs-lisp
     (req-package helm-dash
       :bind (("\C-z SPC d" . helm-dash-at-point))
       :require helm
       :init (progn
               (defun clojure-dash-doc ()
                 (interactive)
                 (setq-local helm-dash-docsets '("Clojure")))


               (defun java-dash-doc ()
                 (interactive)
                 (setq-local helm-dash-docsets '("Java_SE8")))


               (defun bash-dash-doc ()
                 (interactive)
                 (setq-local helm-dash-docset '("Bash")))


               (add-hook 'clojure-mode-hook 'clojure-dash-doc)
               (add-hook 'java-mode-hook 'java-dash-doc)
               (add-hook 'shell-mode-hook 'bash-dash-doc)
               )
       :config
       (progn
         (if w3m-installed
             (setq helm-dash-browser-func 'w3m-browse-url))
         (setq helm-dash-docsets '("Bash"
                                   "Clojure"
                                   "Docker"
                                   "Emacs Lisp"
                                   "Groovy"
                                   "Groovy JDK"
                                   "Gradle Groovy API"
                                   "Gradle DSL"
                                   "Gradle User Guide"
                                   "Java"
                                   "LaTeX"
                                   "PostgreSQL"
                                   "Vagrant"
                                   "XSLT"))))
    #+END_SRC
*** Installing docsets

    Helm-dash uses the same docsets as Dash. You can install them with
    m-x helm-dash-install-docset for the official docsets or m-x
    helm-dash-install-user-docset for user contributed docsets
    (experimental).

    To install a docset from a file in your drive you can use m-x
    helm-dash-install-docset-from-file'. That function takes as input
    atgzfile that you obtained, starting from a folder named.docset`,
    with the command:

    tar --exclude='.DS_Store' -cvzf <docset name>.tgz <docset name>.docset

    as explained here.
** dash at point
   #+BEGIN_SRC emacs-lisp
     (req-package dash-at-point
       :bind (("C-z SPC h d" . dash-at-point-with-docset)
              ("C-z SPC h D" . dash-at-point)))
   #+END_SRC
** helm-swoop
   #+BEGIN_SRC emacs-lisp
     (req-package helm-swoop
       :bind (("C-S-s" . helm-swoop)
              ("C-M-S-s" . helm-multi-swoop-all))
       :require helm)
   #+END_SRC
** pos tip
   #+BEGIN_SRC emacs-lisp
   (req-package pos-tip)
   #+END_SRC
** help at point
   #+BEGIN_SRC emacs-lisp
   (req-package help-at-pt
     :config
     (progn
       (setq help-at-pt-display-when-idle t)
       (setq help-at-pt-timer-delay 0.1)
       (help-at-pt-set-timer)))
   #+END_SRC
* navigation
** iy-go-to-char
   - prompts for a character and the jumps forward/backward to the next occurrance of that char
#+BEGIN_SRC emacs-lisp
(req-package iy-go-to-char
  :bind (
  ("C-c f" . iy-go-to-char)
  ("C-c F" . iy-go-to-char-backward)))
#+END_SRC
** ace and avy
#+BEGIN_SRC emacs-lisp
  (req-package ace-link
    :require gnus
    :bind (
      ;; bind within org mode
      :map org-mode-map
      ("M-o" . ace-link-org)
      ;; bind within gnus
      :map gnus-summary-mode-map
      ("M-o" . ace-link-gnus)
      :map gnus-article-mode-map
      ("M-o" . ace-link-gnus))
    :config
    (progn
      ;; bind "o" within info, help, woman, eww compilation and custom mode
      (ace-link-setup-default)))

  (req-package ace-window  ;; select open window with one key
    :require key-chord ;; optional, key binding
    :defer t
    :init
    (progn
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (when (package-installed-p 'key-chord)
      (key-chord-define-global "o0"   'ace-window))))

  (req-package ace-flyspell
    :require flyspell avy)
    ;; available commands 'M-x ace-flyspell-jump-word', jump to incorrect spelling via ace
    ;; 'M-x ace-flyspell-dwim', autocorrect word
    ;; 'M-x ace-flyspell-correct-word', no jump but autocorrect

#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package ace-isearch
    :require avy helm-swoop ace-jump-mode
    :disabled t
    :config
    (progn
      (setq ace-isearch-function (quote avy-goto-word-1)) ;; use thus function if only one character was searched for
      ;; (setq ace-isearch-input-length 3) ;; start helm swoop at a length of 3 characters
      ;; (setq ace-isearch-jump-delay 0.35) 
      (setq ace-isearch-use-jump (quote printing-char))

      ;; Enable global ace-isearch mode:
      (global-ace-isearch-mode +1)

      ;; Enable ace-isearch minor mode:
      ;; (ace-isearch-mode +1)

      (when (package-installed-p 'bind-key)
        ;; when in search mode, hit C-' to jump to single char!
        (bind-key "C-'" 'ace-isearch-jump-during-isearch isearch-mode-map)

        (bind-key "C-S-s" 'isearch-forward)
        (bind-key "C-S-r" 'isearch-backward))))

#+END_SRC
#+BEGIN_SRC emacs-lisp
  (req-package avy
    :bind (("C-S-SPC" . avy-goto-char-timer)
           ("C-c SPC" . avy-goto-char-timer)
           ("C-c C-SPC" . avy-goto-char-timer)
           ("C-x SPC" . avy-pop-mark)
           ("C-x C-SPC" . avy-pop-mark))
    :config
    (progn
      (setq avy-background t)
      (setq avy-keys (number-sequence ?a ?z))
      (custom-set-faces
       '(avy-lead-face ((t (:foreground "red"))))
       '(avy-lead-face-0 ((t (:foreground "orange"))))
       '(avy-lead-face-1 ((t (:foreground "yellow"))))
       '(avy-lead-face-2 ((t (:foreground "white")))))))



  (req-package avy-zap
    :require avy
    :bind
      (("M-Z" . avy-zap-to-char-dwim)
       ("M-z" . avy-zap-up-to-char)))


#+END_SRC
** ace popup menu
   - display regular popup windows (like the one upon C-c $ to correct mispelled words) as a text window (in separate emacs window)
   #+BEGIN_SRC emacs-lisp
   (req-package avy-menu)
   (req-package ace-popup-menu
     :require avy avy-menu
     :config (ace-popup-menu-mode 1))
   #+END_SRC
** search cursor left
   - C-RET after searching via C-s will leave cursor at start of match
   - RET after searching via C-s will leave cursor at end of match
   #+BEGIN_SRC emacs-lisp
     (define-key isearch-mode-map [(control return)]
       #'isearch-exit-other-end)
     (defun isearch-exit-other-end ()
       "Exit isearch, at the opposite end of the string."
       (interactive)
       (isearch-exit)
       (goto-char isearch-other-end))
   #+END_SRC
** visible mark
   - make the last (2) marks visible (orange, yellow)
   - C-x C-x exchanges point and mark, spanning a region between the two
   - C-space sets the mark, marks are put into a ring
   - back-button allows navigation throught the mark buffer positions
   - STATUS: produces errors on post command hooks (default is disabled)
   #+BEGIN_SRC emacs-lisp
     (req-package visible-mark
       :init
       (defface visible-mark-active ;; put this before (require 'visible-mark)
         '((((type tty) (class mono)))
           (t (:background "magenta"))) "")
       (setq visible-mark-max 2)
       (setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))
       (defun gb/toggle-visible-mark-mode ()
         "toggle visible mark mode"
         (if (bound-and-true-p visible-mark-mode)
             (visible-mark-mode -1)
           (visible-mark-mode t)))
       :config
       ;; (global-visible-mark-mode 1)
       ;; or add (visible-mark-mode) to specific hooks
       )
   #+END_SRC
** back-button
#+BEGIN_SRC emacs-lisp
  (req-package back-button
    :defer 3
    :require hydra smartrep
    :config
    (progn

    ;;--------------------------------------------------------------------------------
      (defhydra hydra-navigate-history ()
        "
              Navigate through location history
              ---------------------------------
              [_p_] back local    [_n_] forward local
              [_P_] back global   [_N_] forward global
              ^ ^                 [_q_] quit

          %s(hydra-combine-functions-w-key-bindings 
            '((\"    back local     \" . back-button-local-backward)
              (\"    back global    \" . back-button-global-backward)
              (\"    forward local  \" . back-button-local-forward)
              (\"    forward global \" . back-button-global-forward)))
              "
        ("p" back-button-local-backward :color green)
        ("P" back-button-global-backward )
        ("n" back-button-local-forward )
        ("N" back-button-global-forward )
        ("q" (message "Abort") :exit t))

    (back-button-mode 1)))
#+END_SRC
** jumplist
#+BEGIN_SRC emacs-lisp
  (req-package jumplist
    :bind (
    ("C-," . jumplist-previous)
    ("C-." . jumplist-next))
    :config
    (custom-set-variables
     '(jumplist-hook-commands
       '(helm-swoop helm-for-files helm-find-files
         dired-jump
         find-file
         isearch-forward-regexp isearch-forward 
         end-of-buffer beginning-of-buffer
         elisp-slime-nav-find-elisp-thing-at-point
         find-tag
         eclim-java-find-declaration eclim-java-find-references eclim-java-find-generic eclim-java-find-type
         cider-find-resource cider-find-file cider-find-var cider-find-var-file))))
#+END_SRC
** region-state
   - Show the number of chars/lines or rows/columns in the region
#+BEGIN_SRC emacs-lisp
  (req-package region-state
    :config
    (region-state-mode 1))
#+END_SRC
** goto last change
#+BEGIN_SRC emacs-lisp
(req-package goto-chg
  :bind (
  ("C-c b ," . goto-last-change)
  ("C-c b ." . goto-last-change-reverse)))
#+END_SRC
** smart scan (jump to next/prev of symbol)
#+BEGIN_SRC emacs-lisp
  (req-package smartscan
    :config
    (progn
    (global-smartscan-mode +1)
    (setq smartscan-symbol-selector "symbol")))
  ;; (smartscan-mode 1)
  ;; use M-p to jump to previous location of that symbol
  ;; use M-n to jump to net location of that symbol
#+END_SRC
** anzu (searching regexp with hit count)
   #+BEGIN_SRC emacs-lisp
     ;; display # of matches in modeline when searching
     (req-package anzu
       :config
       (global-anzu-mode +1))
   #+END_SRC
** other (recentf, uniquify)
#+BEGIN_SRC emacs-lisp
  ;; These customizations make it easier for you to navigate files,
  ;; switch buffers, and choose options from the minibuffer.

  ;; "When several buffers visit identically-named files,
  ;; Emacs must give the buffers distinct names. The usual method
  ;; for making buffer names unique adds <2>, <3>, etc. to the end
  ;; of the buffer names (all but one of them).
  ;; The forward naming method includes part of the file's directory
  ;; name at the beginning of the buffer name
  ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html
  (req-package uniquify
    :config
    (setq uniquify-buffer-name-style 'forward))

  ;; Turn on recent file mode so that you can more easily switch to
  ;; recently edited files when you first start emacs
  (req-package recentf
    :ensure t
    :config
    (progn
    (setq recentf-save-file (concat user-emacs-directory ".recentf"))
    (recentf-mode 1)
    (setq recentf-exclude (list "^.*/\\.emacs\\.d/.*"))
    (setq recentf-max-menu-items 40)))
#+END_SRC
** swiper
   #+BEGIN_SRC emacs-lisp
   (req-package ivy)
   (req-package swiper
     :require ivy)
   #+END_SRC
** counsel
   #+BEGIN_SRC emacs-lisp
     (req-package counsel
       :require swiper
       ;; :bind (("M-y" . counsel-yank-pop)
       ;;        :map ivy-minibuffer-map
       ;;        ("M-y" . ivy-next-line))
       :config
       (progn
         (bind-key "M-y" #'counsel-yank-pop ) ;; no :bind, since counsel needs to be loaded for magit
         (bind-key "M-y" #'ivy-next-line ivy-minibuffer-map )
         (setq counsel-grep-swiper-limit 3000000)))
   #+END_SRC
** highlight-thing
   #+BEGIN_SRC emacs-lisp
     (req-package highlight-thing
       :init
       (progn
         (defun gb/toogle-highlight-what-thing ()
           "toggle highlight-thing-what-thing between word and symbol.
     highlight thing mode will be switched off during toggle
     and then reactivated, if it was active before."
           (interactive)
           (let (old-highlight-thing-mode highlight-thing-mode)
             (highlight-thing-mode -1)
             (if (equal 'symbol highlight-thing-what-thing)
                 (setq highlight-thing-what-thing 'word)
               (setq highlight-thing-what-thing 'symbol))
             (if old-highlight-thing-mode 
                 (highlight-thing-mode 1))))
         (setq highlight-thing-what-thing 'symbol)))
   #+END_SRC
** minimap
   #+BEGIN_SRC emacs-lisp
   (req-package minimap
     :bind (("s-m" . minimap-mode))
     :config
     (progn
       (setq minimap-major-modes (quote (prog-mode org-mode nxml-mode)))
       (setq minimap-window-location (quote right))
       (custom-set-faces '(minimap-active-region-background ((t (:background "gray23")))))))
 #+END_SRC
* programming language related
** functional-editing
*** OBSOLETE parinfer (currently disabled)
    - State "OBSOLETE"   from "TODO"       [2016-12-18 Sun 09:47]
    - M-x parinfer-toggle-mode
    - use indent to actually infer parenthesis
    - CAREFUL, THIS IS DESTRUCTIVE TO NOT CORRECTLY INDENTED LISP CODE!
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package parinfer
        :disabled t
        :init
        (progn
          (add-hook 'clojure-mode-hook #'parinfer-mode)
          (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
          (add-hook 'eval-expression-minibuffer-setup-hook #'parinfer-mode)
          (add-hook 'ielm-mode-hook             #'parinfer-mode)
          (add-hook 'lisp-mode-hook             #'parinfer-mode)
          (add-hook 'lisp-interaction-mode-hook #'parinfer-mode)
          (add-hook 'scheme-mode-hook           #'parinfer-mode)))
    #+END_SRC
*** eros (display result of eval as overlay)
    - shows eval-last-sexp as overlay behind the expression evaluated (instead of only minibuffer)
    #+BEGIN_SRC emacs-lisp 
      (req-package eros
        :config 
        (progn 
          (eros-mode 1)))
    #+END_SRC
*** eldoc mode
    - is automatically turned on in emacs 25.x
    #+BEGIN_SRC emacs-lisp
   ;; eldoc-mode shows documentation in the minibuffer when writing code
   ;; http://www.emacswiki.org/emacs/ElDoc
   ;; (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
   ;; (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
   ;; (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)    
    #+END_SRC
    #+BEGIN_SRC emacs-lisp
      ;; function that displays eldoc message into a pos-tip
      (defun gb/eldoc-display-message (format-string &rest args)
        "Display eldoc message near point."
        (when format-string  
          (pos-tip-show (apply 'format format-string args) :TIMEOUT 1)))
      ;; make sure that eldoc calls own function
      ;; (setq eldoc-message-function #'gb/eldoc-display-message)
      ;; restore original
      ;; (setq eldoc-message-function #'eldoc-minibuffer-message)

    #+END_SRC
*** eldoc overlay mode
    - displays eldoc in an overlay right before cursor
    - does this all the time, after some delay.
    - this may become anoying
    #+BEGIN_SRC emacs-lisp
      (req-package eldoc-overlay-mode
        :commands eldoc-overlay-mode)
    #+END_SRC
*** paredit
 #+BEGIN_SRC emacs-lisp
   ;; Automatically load paredit when editing a lisp file
   ;; More at http://www.emacswiki.org/emacs/ParEdit
   (req-package paredit
     :init
     (progn
       (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
       (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
       (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
       (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
       (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
       (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
       (add-hook 'clojure-mode-hook          #'enable-paredit-mode)))

   ;; (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)

 #+END_SRC
*** elisp slime nav
    #+BEGIN_SRC emacs-lisp
      ;; allows navigation M-. and M-, to jump to definition and return back
      (req-package elisp-slime-nav
        :init
        (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
          (add-hook hook 'elisp-slime-nav-mode))
        )
    #+END_SRC
*** IMPLEMENT lispy
    when cursor is positioned on opening parenthesis or right behind closing parenthesis, special keybinding is applied
    (see also https://github.com/abo-abo/lispy)
**** general keybindings
***** [      move to first enclosing opening parenthesis
***** ]      move to first enclosing closing parenthesis 
      )      
***** C-1    display function doc inline (only if connected to nrepl)
***** C-2    display function parameters of current thing at point (repl connected)
***** }      open square brackets "[]"
***** {      open curly brackets "{}"
***** (      open brackets "()"
***** "      open quotes '""'
**** special keybindings
***** >      barf in
***** <      barf out
  #+BEGIN_SRC emacs-lisp
    (req-package lispy
     :bind (("C-1" . lispy-describe-inline)) ;; make C-1 available even without lispy mode!
     :require hydra
     :config
     (custom-set-faces
       '(lispy-face-hint ((t (:background "gray20" :foreground "#fff3bc")))))
     )
  #+END_SRC
** clojure
*** clojure
 #+BEGIN_SRC emacs-lisp
   ;;;;
   ;; Clojure
   ;;;;


   ;; A little more syntax highlighting
   (req-package clojure-mode-extra-font-locking
     :defer 3
     :require clojure-mode)

   (req-package clojure-mode
     :require subword ;; optional, when active, clojure switches to this minor mode too
     flycheck ;; optional, when active, clojure switches to this minor mode too
     paredit ;; optional, when active, clojure switches to this minor mode too
     hideshow ;; for folding namespaces (see below)
     key-chord ;; for defining folding with hide show
     hydra 
     :interpreter "clojure"
     :mode "\\.clj\\'"
     :init (progn
       ;; Enable paredit for Clojure
       (when (package-installed-p 'paredit)
         (add-hook 'clojure-mode-hook 'enable-paredit-mode))

       (when (package-installed-p 'flycheck)
         (add-hook 'clojure-mode-hook 'flycheck-mode))

       ;; This is useful for working with camel-case tokens, like names of
       ;; Java classes (e.g. JavaClassName)
       (when (package-installed-p 'subword)
         (add-hook 'clojure-mode-hook 'subword-mode))

       ;; turn on eldoc for clojure mode
       (add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)

       ;; syntax hilighting for midje
       (add-hook 'clojure-mode-hook
                 (lambda ()
                   (setq inferior-lisp-program "lein repl")
                   (font-lock-add-keywords
                    nil
                    '(("(\\(facts?\\)"
                       (1 font-lock-keyword-face))
                      ("(\\(background?\\)"
                       (1 font-lock-keyword-face))))
                   (define-clojure-indent (fact 1))
                   (define-clojure-indent (facts 1))))

     (defun gb/hs-clojure-mode-hook ()
       (interactive)
       (hs-minor-mode 1)
       (key-chord-define clojure-mode-map "q1" #'hs-toggle-hiding)
       (gb/hs-clojure-hide-namespace-and-folds))

     (add-hook 'clojure-mode-hook #'gb/hs-clojure-mode-hook)
       )
     :config
     (progn
       ;; define hydras

    ;;--------------------------------------------------------------------------------
      (defhydra hydra-all-clojure-refactorings ()
        "all clojure refactorings as hydra menu"
        ("c" hydra-cljr-code-menu/body "code refactorings" :exit t)
        ("n" hydra-cljr-ns-menu/body "namespace refactorings" :exit t)
        ("p" hydra-cljr-project-menu/body "project refactorings" :exit t)
        ("t" hydra-cljr-toplevel-form-menu/body "top level form refactorings" :exit t))

     (defun gb/hs-clojure-hide-namespace-and-folds ()
       "Hide the first (ns ...) expression in the file, and also all
   the (^:fold ...) expressions."
       (interactive)
       (hs-life-goes-on
        (save-excursion
          (goto-char (point-min))
          (when (ignore-errors (re-search-forward "^(ns "))
            (hs-hide-block))

          (while (ignore-errors (re-search-forward "\\^:fold"))
            (hs-hide-block)
            (next-line)))))

     ))
 #+END_SRC
*** flycheck-clojure
    #+BEGIN_SRC emacs-lisp
      (req-package flycheck-clojure
        :require flycheck clojure-mode)
    #+END_SRC
*** cider
 #+BEGIN_SRC emacs-lisp
   ;;;;
   ;; Cider
   ;;;;
   (req-package cider
     :commands cider-jack-in
     :require clojure-mode
     company ;; optional for completion
     flycheck-clojure ;; optional for checking on the fly
     rainbow-delimiters ;; optional minor mode to switch on
     paredit ;; optional paredit minor mode to switch to
     spinner
     :bind (:map clojure-mode-map
         ("C-c C-v" . cider-start-http-server)
         ("C-M-r" . cider-refresh)
         ("C-c u" . cider-user-ns)
         :map cider-mode-map
         ("C-c C--" . cider-eval-expression-at-point-in-repl)
         ("C-c u" . cider-user-ns))
     :init (progn
       ;; provides minibuffer documentation for the code you're typing into the repl
       (add-hook 'cider-mode-hook 'turn-on-eldoc-mode)

       ;; add company hooks
       (when (package-installed-p 'company)
         (add-hook 'cider-repl-mode-hook #'company-mode)
         (add-hook 'cider-mode-hook #'company-mode))

       ;; enable paredit in your REPL
       (when (package-installed-p 'paredit) (add-hook 'cider-repl-mode-hook 'paredit-mode))

       ;; make delimiters colorful
       (when (package-installed-p 'rainbow-delimiters)  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

       ;; Replace return key with newline-and-indent when in cider mode.
       (add-hook 'cider-mode-hook '(lambda () (local-set-key (kbd "RET") 'newline-and-indent)))

       ;; Use clojure mode for other extensions
       (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
       (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
       ;; (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode)) ;; might collide with clojure mode check of current major mode!!
       (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))

       (autoload 'cider--make-result-overlay "cider-overlays")

       (defun endless/eval-overlay (value point)
         (cider--make-result-overlay (format "%S" value)
                                     :where point
                                     :duration 'command)
         ;; Preserve the return value.
         value)

       (advice-add 'eval-region :around
                   (lambda (f beg end &rest r)
                     (endless/eval-overlay
                      (apply f beg end r)
                      end)))

       (advice-add 'eval-last-sexp :filter-return
                   (lambda (r)
                     (endless/eval-overlay r (point))))

       (advice-add 'eval-defun :filter-return
                   (lambda (r)
                     (endless/eval-overlay
                      r
                      (save-excursion
                        (end-of-defun)
                        (point)))))

       ;; these help me out with the way I usually develop web apps
       (defun cider-start-http-server ()
         (interactive)
         (cider-load-current-buffer)
         (let ((ns (cider-current-ns)))
           (cider-repl-set-ns ns)
           (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
           (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))

       (defun cider-refresh ()
         (interactive)
         (cider-interactive-eval (format "(user/reset)")))

       (defun cider-user-ns ()
         (interactive)
         (cider-repl-set-ns "user"))


       (defun cider-eval-expression-at-point-in-repl ()
         (interactive)
         (let ((form (cider-defun-at-point)))
           ;; Strip excess whitespace
           (while (string-match "\\`\s+\\|\n+\\'" form)
             (setq form (replace-match "" t t form)))
           (set-buffer (cider-get-repl-buffer))
           (goto-char (point-max))
           (insert form)
           (cider-repl-return)))

       )
     :config
     (progn

       ;; make sure that nrepl does not automatically scroll down!
       (setq cider-repl-scroll-on-output nil)
       ;; use pretty print output in repl
       (setq cider-repl-use-pretty-printing t)

       ;; go right to the REPL buffer when it's finished connecting
       (setq cider-repl-pop-to-buffer-on-connect t)

       ;; When there's a cider error, show its buffer and switch to it
       (setq cider-show-error-buffer t)
       (setq cider-auto-select-error-buffer t)

       ;; Where to store the cider history.
       (setq cider-repl-history-file (concat user-emacs-directory "cider-history"))
       ;; keep that much history
       (setq cider-repl-history-size 1000)
       ;; Wrap when navigating history.
       (setq cider-repl-wrap-history t)

       ;; Version of clojure to auto-inject into REPL.
       (setq cider-jack-in-auto-inject-clojure (quote latest))


       ;; do flycheck setup for clojure
       (when (package-installed-p 'flycheck-clojure)  (flycheck-clojure-setup))


       ))
 #+END_SRC
*** helm-cider
    #+BEGIN_SRC emacs-lisp
      (req-package helm-cider
        :require helm cider
        :config
        (helm-cider-mode 1))
    #+END_SRC
*** litable
 #+BEGIN_SRC emacs-lisp
     ;; To start this up, simply enable the litable minor mode in the buffer by calling 
     ;; M-x litable-mode.
     (req-package litable
       :require clojure-mode)

     ;; Litable keeps a list of pure functions as a safeguard for unwanted evaluations. 
     ;; A function must first be accepted into this list (using M-x litable-accept-as-pure)
     ;; before it can be evaluated on-the-fly. You should take care of what function you accept
     ;; as pure to avoid any unfortunate accidents. Also, note that the pure functions list
     ;; persists across sessions.

 #+END_SRC
*** clojars
    - search clojars for libraries (M-x clojars)
 #+BEGIN_SRC emacs-lisp
 (req-package clojars
   :require clojure-mode)
 #+END_SRC
*** expectations
 #+BEGIN_SRC emacs-lisp :tangle no
   ;;================================================== clojure
   ;; clojure expectations mode
;;   (req-package expectations-mode
;;     :require clojure-mode
;;     :config
;;     (setenv "EXPECTATIONS_COLORIZE" "false"))
 #+END_SRC
*** clj-refactor
 #+BEGIN_SRC emacs-lisp
   (req-package inflections)
   (req-package peg)
   (req-package edn
     :require peg)
   (req-package clj-refactor
     :defer t ;; this defer is valid, since via init the loading is ensured 
     :require hydra s seq yasnippet paredit multiple-cursors clojure-mode cider edn inflections
     :init
     (defun gb/clojure-mode-hook ()
       (clj-refactor-mode 1)
       (yas-minor-mode 1) ; for adding require/use/import
       (cljr-add-keybindings-with-prefix "C-c C-m"))

     (add-hook 'clojure-mode-hook #'gb/clojure-mode-hook))
 #+END_SRC
*** typed clojure
 #+BEGIN_SRC emacs-lisp
   (req-package typed-clojure-mode
     :require clojure-mode subword
     :defer t ;; this defer is valid, since via init the loading is ensured 
     :init
     (add-hook 'clojure-mode-hook 'typed-clojure-mode))
 #+END_SRC
*** org babel clojure
    #+BEGIN_SRC emacs-lisp

    #+END_SRC
** cypher mode (neo4j)
 #+BEGIN_SRC emacs-lisp
 (req-package cypher-mode
   :defer 5)
 #+END_SRC
** eclim eclipse emacs integration (disabled)
 #+BEGIN_SRC emacs-lisp :tangle no
   (req-package eclim
     :disabled t
     :config
     (global-eclim-mode)
     (custom-set-variables
       '(eclim-eclipse-dirs '("/Applications/Eclipse.app/Contents/Eclipse"))
       '(eclim-executable "/Applications/Eclipse.app/Contents/Eclipse/plugins/org.eclim_2.5.0/bin/eclim")))

   (req-package company-emacs-eclim
     :require eclim company
     :disabled t
     :config
     (company-emacs-eclim-setup)
     (global-company-mode t))

   (req-package eclimd
     :require eclim
     :disabled t)
 #+END_SRC
** elixir
   #+BEGIN_SRC emacs-lisp
   (req-package elixir-mode
     :defer 5)
   #+END_SRC
** elm
   #+BEGIN_SRC emacs-lisp
   (req-package elm-mode
     :defer 5)
   #+END_SRC
** erlang
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package erlang)
   #+END_SRC
**** erlang company
     #+BEGIN_SRC emacs-lisp :tangle no
     (req-package ivy-erlang-complete
       :requre ivy counsel erlang async)
     (req-package company-erlang
       :require erlang ivy-erlang-complete company)
     #+END_SRC
** groovy
   #+BEGIN_SRC emacs-lisp
     (req-package groovy-mode
       :commands groovy-mode
       :init
       (progn
         ;; make sure for some labeled parameters in groovy to indent with 4
         (add-hook 'groovy-mode-hook
                   (lambda ()
                     (c-set-offset 'label 4)))))

   #+END_SRC
** haskell
   - installed via 'brew cask install haskell-platform'
   - uninstalled old version via 'uninstall-hs only 7.8.3'
   #+BEGIN_SRC emacs-lisp  :tangle no
   (req-package haskell-mode)
   #+END_SRC
*** flycheck
    #+BEGIN_SRC emacs-lisp :tangle no
    (req-package flycheck-haskell
      :require haskell-mode flycheck)
    #+END_SRC
** web-mode
   #+BEGIN_SRC emacs-lisp
   (req-package web-mode
     :mode (("\\.phtml\\'" . web-mode)
            ("\\.tpl\\.php\\'" . web-mode)
            ("\\.[agj]sp\\'" . web-mode)
            ("\\.as[cp]x\\'" . web-mode)
            ("\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.dhtml\\'" . web-mode)
            ("\\.html?\\'" . web-mode))
     :config
     (progn
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)))
   #+END_SRC
** typescript
   #+BEGIN_SRC emacs-lisp
     ;; run ts repl in typescript-mode, allowing to send expressions to the interpreter
     ;; M-x run-ts ;; starts a comint buffer with repl
     (req-package ts-comint
       :require typescript-mode
       :init
         (add-hook 'typescript-mode-hook
            (lambda ()
              (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
              (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
              (local-set-key (kbd "C-c b") 'ts-send-buffer)
              (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
              (local-set-key (kbd "C-c l") 'ts-load-file-and-go))))

     (req-package typescript-mode
       :mode (("\\.ts\\'" . typescript-mode)))

     (req-package tide
       :require typescript-mode
       :init (progn
         (add-hook 'typescript-mode-hook #'gb/setup-tide-mode)
         (add-hook 'js2-mode-hook #'gb/setup-tide-mode)
         ;; (add-hook 'tide-mode-hook #'gb/setup-tide-mode)
         (add-hook 'web-mode-hook
                   (lambda ()
                     (when (string-equal "tsx" (file-name-extension buffer-file-name))
                       (gb/setup-tide-mode))))
         )
       :config
       (progn
         (defun gb/setup-tide-mode ()
           (interactive)
           (tide-setup)
           (flycheck-mode +1)
           (setq flycheck-check-syntax-automatically '(save mode-enabled))
           (eldoc-mode +1)
           (tide-hl-identifier-mode +1)
           (company-mode +1)
           (subword-mode +1)
           (setq typescript-indent-level 2))

         ;; aligns annotation to the right hand side
         (setq company-tooltip-align-annotations t)

         ;; use 2 for indent
         (setq typescript-indent-level 2)

         (setq json-reformat:indent-width 2)
         (setq js-indent-level 2)
         ;; formats the buffer before saving
         ;; (add-hook 'before-save-hook 'tide-format-before-save)

         ;; (flycheck-add-next-checker 'javascript-eslint 'jsx-tide 'append)
         ))
   #+END_SRC
** java script
 #+BEGIN_SRC emacs-lisp
   ;; (req-package tagedit)
   (req-package js2-mode
     :mode (("\\.js\\'" . js2-mode)
            ("\\.jsx?\\'" . js2-jsx-mode))
     :config (setq js-indent-level 2))
   ;; (req-package js
   ;;   :require flycheck tagedit
   ;;   :defer 5
   ;;   :config
   ;;   (add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
   ;;   (when (package-installed-p 'subword)
   ;;     (add-hook 'js-mode-hook 'subword-mode)
   ;;     (add-hook 'html-mode-hook 'subword-mode))
   ;;   (when (package-installed-p 'flycheck)
   ;;     (add-hook 'js-mode-hook 'flycheck-mode))
   ;;   (setq js-indent-level 2)
   ;;   (eval-after-load "sgml-mode"
   ;;     '(progn
   ;;        (require 'tagedit)
   ;;        (tagedit-add-paredit-like-keybindings)
   ;;        (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))


   ;;   ;; coffeescript
   ;;   (add-to-list 'auto-mode-alist '("\\.coffee.erb$" . coffee-mode))
   ;;   (when (package-installed-p 'subword)
   ;;     (add-hook 'coffee-mode-hook 'subword-mode))
   ;;   (add-hook 'coffee-mode-hook 'highlight-indentation-current-column-mode)
   ;;   (add-hook 'coffee-mode-hook
   ;;             (defun coffee-mode-newline-and-indent ()
   ;;               (define-key coffee-mode-map "\C-j" 'coffee-newline-and-indent)
   ;;               (setq coffee-cleanup-whitespace nil)))
   ;;   (custom-set-variables
   ;;    '(coffee-tab-width 4)))
 #+END_SRC
** java
*** jde (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Add java development extension to loadpath
     ;;  (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp")
     ;;  (load "jde")

     ;; (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp/")
     ;; (req-package jde 
     ;;   :disabled t
     ;;   :loader :path
     ;;   :config
     ;;   (defadvice custom-buffer-create  (after jde-set-default-dir-to-project-dir (options &optional name description) activate)
     ;;     "When customizing jde path variables set the default directory to the jde project file directory. This makes file completion work for relative paths."
     ;;     (when (and (listp options) ;; we want options to look like (list (list symbol 'custom-variable)), see customize-variable
     ;;                (eq (length options) 1)
     ;;                (listp (car options))
     ;;                (eq (length (car options)) 2)
     ;;                (or (eq 'custom-variable (cadar options)) (eq 'jde-custom-variable (cadar options))))
     ;;       (let ((symbol (caar options)))
     ;;         (if (memq symbol '(jde-global-classpath jde-sourcepath));; or we could use (jde-symbol-p symbol)
     ;;             ;; stolen from jde-project-file: find the project file where this symbol is saved
     ;;             (let* ((project-file-paths (nreverse (jde-find-project-files default-directory))))
     ;;               (when project-file-paths
     ;;                 (when (jde-save-needs-saving-p symbol project-file-paths)
     ;;                   ;; set the current directory to the directory the project file is in, ie the root for relative paths
     ;;                   (setq default-directory (expand-file-name ".." (caar (get symbol 'jde-project)))))))))))
     ;;   )

     ;; ;; (global-set-key (kbd "C-<tab>") 'jde-complete);; currently overshadowed by yasnippets


   #+END_SRC
*** java decompiler
    #+BEGIN_SRC emacs-lisp :tangle no
      ;; (add-to-list 'load-path "~/.emacs.d/java/")
      ;; (req-package javad
      ;;   :require javap-mode
      ;;   :loader :path
      ;;   :defer 5
      ;;   :config
      ;;   ;; allows viewing decompiled version of a class file if jad is installed!
      ;;   ;;(load "~/.emacs.d/java/javad.el")

      ;;   (defun javad-find-class (&rest args)
      ;;     (interactive)
      ;;     (if (not (string= ".class" (substring (buffer-file-name) -6 nil)))
      ;;         nil
      ;;       (message "Show class as: [b]ytecode, [d]ecompiled or [i]dentity?")
      ;;       (let ((resp (read-char)))
      ;;         (cond
      ;;          ((= resp 98) (progn (javap-buffer) nil))
      ;;          ((= resp 100) (progn (javad-buffer) nil))
      ;;          (t nil))
      ;;         (let ((buff (current-buffer)))
      ;;           (switch-to-buffer buff)))))

      ;;   (add-hook 'find-file-hook 'javad-find-class)
      ;;   )
    #+END_SRC
*** java programming mode
    #+BEGIN_SRC emacs-lisp
     (req-package javap-mode
       :defer 5)   
    #+END_SRC
** php 
 #+BEGIN_SRC emacs-lisp :tangle no
   (req-package php-mode
     
     :init
     ;; make sure that indentation of arrays is more readable
     (add-hook 'php-mode-hook (lambda ()
                                (defun ywb-php-lineup-arglist-intro (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (+ (current-column) c-basic-offset))))
                                (defun ywb-php-lineup-arglist-close (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (current-column))))
                                (c-set-offset 'arglist-intro 'ywb-php-lineup-arglist-intro)
                                (c-set-offset 'arglist-close 'ywb-php-lineup-arglist-close))))


 #+END_SRC
** python
 #+BEGIN_SRC emacs-lisp
   (req-package python)
   (req-package find-file-in-project
     :require ivy)
   (req-package elpy
     :require org flycheck find-file-in-project python
     :mode (("\\.py\\'" . python-mode))
     :init
     (add-hook 'python-mode-hook #'elpy-enable)
     (add-hook 'python-mode-hook #'flycheck-mode))
 #+END_SRC
** scala ensime (enhanced scala mode for emacs, currntely disabled)
 #+BEGIN_SRC emacs-lisp :tangle no
 (req-package ensime
   :require sbt-mode
   :commands ensime
   :init
   (add-hook 'scala-mode-hook 'ensime-mode))
 #+END_SRC
** xml
   #+BEGIN_SRC emacs-lisp
     (req-package nxml-mode
       :mode (("\\.xslt\\'" . nxml-mode)
              ("\\.xml\\'" . nxml-mode)))
     (req-package xml+
       :require dash)
   #+END_SRC
* programming related
** editorconfig
   #+BEGIN_SRC emacs-lisp
      (req-package editorconfig
       :config (editorconfig-mode 1))
   #+END_SRC
** flymake
   #+BEGIN_SRC emacs-lisp
   (req-package flymake)
   (req-package flymake-easy
     :require flymake)
   (req-package flymake-yaml
     :require flymake-easy
     :init (add-hook 'yaml-mode-hook 'flymake-yaml-load))
   (req-package flymake-shell
     :require flymake-easy
     :init (add-hook 'sh-set-shell-hook 'flymake-shell-load))
   (req-package flymake-json
     :require flymake-easy
     :init (add-hook 'js-mode-hook 'flymake-json-maybe-load))
   #+END_SRC
** flycheck
   #+BEGIN_SRC emacs-lisp
     (req-package flycheck
       :config
       (progn
         (define-key flycheck-mode-map flycheck-keymap-prefix nil)
         (setq flycheck-keymap-prefix (kbd "C-c k"))
         (define-key flycheck-mode-map flycheck-keymap-prefix
           flycheck-command-map)
         ;; (add-hook 'after-init-hook 'global-flycheck-mode)
         ))
     (req-package flycheck-tip
       :require flycheck)
     (req-package flycheck-pos-tip
       :require flycheck
       :config
       ;; (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
       (flycheck-pos-tip-mode)
       (setq flycheck-tip-avoid-show-func nil))
   #+END_SRC
** projects
*** perspective
 #+BEGIN_SRC emacs-lisp
   (req-package perspective
     ;; switch perspective mode on, always
     :config
     (progn
       (persp-mode 1)
       (custom-set-faces
        '(persp-selected-face ((t (:foreground "Grey70")))))))
 #+END_SRC
*** projectile
    - see [[http://batsov.com/projectile/][here]]
 #+BEGIN_SRC emacs-lisp
 (req-package projectile
    :config
   ;; projectile everywhere!
   ;; (projectile-global-mode)
   )
 #+END_SRC
*** persp-projectile
 #+BEGIN_SRC emacs-lisp
   (req-package persp-projectile
     :require projectile perspective helm
     :bind (
       ;; switch project on super-s
       :map  projectile-mode-map
       ("s-s" . helm-projectile-switch-project)))
 #+END_SRC
** git
*** magithub
    #+BEGIN_SRC emacs-lisp :tangle no
    (if hub-installed
    (req-package magithub
      :require magit ghub+ apiwrap
      :defer 40
      :config
      (progn (magithub-feature-autoinject t))))
    #+END_SRC
*** magit (and more)
 #+BEGIN_SRC emacs-lisp
   (req-package ediff
     :config
     ;; make sure that ediff session does not open control window in separate frame, which mixes up exwm
     (setq ediff-window-setup-function (quote ediff-setup-windows-plain)))

      ;; TODO move this function to some general function pool
      (defun gb/display-buffer-fullframe (buffer alist)
        "Display BUFFER in fullscreen.

           ALIST is a `display-buffer' ALIST.

           Return the new window for BUFFER."
        (let ((window (display-buffer-pop-up-window buffer alist)))
          (when window
            (delete-other-windows window))
          window))

      (req-package magit-popup
        :require async)
      (req-package magit
        :require counsel helm async dash with-editor git-commit magit-popup
        :commands magit-status
        :bind (
          ("C-c v s" . magit-status)
          :map magit-mode-map
          ("C-x f" . counsel-git))
        :init (progn
          (defun gb/disable-smartscan ()
            ""
            (smartscan-mode -1))

          (add-hook 'magit-mode-hook 'gb/disable-smartscan))
        :config
        (require 'magit-mode)
        (setq magit-completing-read-function 'helm--completing-read-default)  ;; magit-ido-completing-read)
        (setq magit-fetch-arguments (quote ("--prune")))
        (setq magit-item-highlight-face nil)
        (setq magit-last-seen-setup-instructions "1.4.0")
        (setq magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n200")))
        (setq magit-pull-arguments (quote ("--rebase")))
        (setq magit-use-overlays nil)

        ;; make sure that magit closes all other windows on the frame
        (when (fboundp 'gb/display-buffer-fullframe)
          (add-to-list 'display-buffer-alist
                       `(,(rx "*magit: ")
                         (gb/display-buffer-fullframe)
                         (reusable-frames . nil)))))

      ;; show git relevant change info in the fringe of the frame
      ;; git-gutter-fringe works with nlinum-mode !
      (req-package git-gutter
        :config
        (progn
          (custom-set-faces
           '(git-gutter:unchanged ((t (:background "orange4")))))))

      (req-package git-gutter-fringe
        :require git-gutter
        :config (global-git-gutter-mode +1))

      (req-package magit-gh-pulls
        :require magit
        :disabled t
        :defer 40
        :init
        (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))

      (req-package magit-filenotify
        :require magit
        :disabled t
        :defer 40
        :init
        (add-hook 'after-save-hook 'magit-after-save-refresh-status)
        (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))

      ;; use automatic file notification to update magit status buffer
      ;; (add-hook 'magit-status-mode-hook 'magit-filenotify-mode )
      ;; currently no file notification package is available
      ;; Activate the mode inside the magit-status buffer by calling M-x magit-filenotify-mode [RET]. Repeat the same step to deactivate it again.
      ;; To always enable the mode when opening the magit-status buffer add magit-filenotify-mode to the magit-status-mode-hook.

      (req-package magit-gitflow
        :require magit
        :defer 40
        :init
        (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
      ;; C-f in magit status buffer will invoke gitflow action selector.

      (req-package git-blamed
        ) ;; enter git-blamed-mode colors background of lines according to commit (and should echo some info depending on cursor)

      (req-package git-timemachine
        :commands git-timemachine
        :config
        (defun gb/git-timemachine-show-selected-revision ()
          "Show last (current) revision of file."
          (interactive)
          (let (collection)
            (setq collection
                  (mapcar (lambda (rev)
                            ;; re-shape list for the ivy-read
                            (cons (concat (substring (nth 0 rev) 0 7) "|" (nth 5 rev) "|" (nth 6 rev)) rev))
                          (git-timemachine--revisions)))
            (ivy-read "commits:"
                      collection
                      :action (lambda (rev)
                                (git-timemachine-show-revision rev)))))

        (defun gb/git-timemachine ()
          "Open git snapshot with the selected version.  Based on ivy-mode."
          (interactive)
          (unless (featurep 'git-timemachine)
            (require 'git-timemachine))
          (git-timemachine--start #'gb/git-timemachine-show-selected-revision)))


 #+END_SRC
*** magit imerge
    - will allow for incremental merges
    - adds 'i' on the merge popup itself for starting incremental merges
    - incremental merges have the benefit of having minimal conflicts during one merging session,
      whenever one merge conflict is resolved, this can be persisted in the repo (can be published, left off, picked up again ...)
    - for more information look [[https://github.com/mhagger/git-imerge][here]]
    #+BEGIN_SRC emacs-lisp
      (if git-imerge-installed
      (req-package magit-imerge
        :require magit))
    #+END_SRC
*** magit lfs
    #+BEGIN_SRC emacs-lisp
    (when git-lfs-installed 
      (req-package magit-lfs
        :defer 40
        :require magit))
    #+END_SRC
** gitignore (creation with helm)
   simply call helm-gitignore and select language for which to create this gitignore
 #+BEGIN_SRC emacs-lisp
   (req-package helm-gitignore
     :commands helm-gitignore
     :require helm)
 #+END_SRC
** IMPLEMENT code library
   - [ ] add code mappings (java, clojure)
   - [ ] eval usefulness
 #+BEGIN_SRC emacs-lisp
   (req-package code-library)
 #+END_SRC
** speedbar (currently disabled, see neotree)
 #+BEGIN_SRC emacs-lisp :tangle no
   (req-package sr-speedbar
     :require bind-key
     :config
     ;;================================================== sr-speedbar
     (setq sr-speedbar-right-side nil) ;; put on left side
     (setq sr-speedbar-default-width 50)
     (setq sr-speedbar-auto-refresh nil)
     (setq speedbar-use-images nil)
     (setq speedbar-update-flag nil)
     (setq speedbar-indentation-width 2)
     (setq speedbar-show-unknown-files t)

     (sr-speedbar-open) ;; gnus shows errors if speedbar was not open once (maybe because of the advice following delete other window)
     (sr-speedbar-toggle) ;; but since I dont want it to show in the beginning its toggled to hide
     ;; (other-window 1) ;; move cursor on to the scratch buffer
     ;; (enlarge-window-horizontally 32) ;; make sure that the "main" window is larger than the speed bar window (even when maximized later on)

     ;; adjustments for speedbar behaviour (speedbar is not becoming main window!)
     (defadvice delete-other-windows (after my-sr-speedbar-delete-other-window-advice activate)
       "Check whether we are in speedbar, if it is, jump to next window."
       (let ()
         (when (and (sr-speedbar-window-exist-p sr-speedbar-window)
                    (eq sr-speedbar-window (selected-window)))
           (other-window 1)
           )))
     (ad-enable-advice 'delete-other-windows 'after 'my-sr-speedbar-delete-other-window-advice)
     (ad-activate 'delete-other-windows)
     ;; (bind-key "s-a" 'sr-speedbar-toggle)
     )
 #+END_SRC
** markdown
   - see usage documentation on [[http://jblevins.org/projects/markdown-mode/][homepage]]
   #+BEGIN_SRC emacs-lisp
   (req-package markdown-mode
     :commands (markdown-mode gfm-mode)
     :mode (("\\.text\\'" . markdown-mode)
            ("\\.markdown\\'" . markdown-mode)
            ("README\\.md\\'" . gfm-mode)
            ("\\.md\\'" . markdown-mode))
     :config
     (progn))
   #+END_SRC
** markdown code block edit
   - allows C-' in a markdown code block to edit code in a separate buffer (like org mode does)
   #+BEGIN_SRC emacs-lisp
     (req-package edit-indirect)
     (req-package markdown-edit-indirect
       :require markdown-mode edit-indirect
       :config
       (progn
         (eval-after-load 'markdown-mode
           '(define-key markdown-mode-map (kbd "C-c '") 'markdown-edit-indirect))))
   #+END_SRC
** plantuml
   - https://github.com/skuro/plantuml-mode
   #+BEGIN_SRC emacs-lisp 
       (custom-set-variables
        '(org-plantuml-jar-path (concat user-emacs-directory "plantuml.jar"))
        '(plantuml-jar-path (concat user-emacs-directory "plantuml.jar")))
     (req-package plantuml-mode
       :require org
       :mode ("\\.\\(puml\\|plantuml\\)\\'" . plantuml-mode)
       :config
       ;; (autoload 'plantuml-mode "plantuml-mode" nil t)
       (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
       ;; (add-to-list 'auto-mode-alist '("\\.puml$" . plantuml-mode))
       ;;(add-to-list 'auto-mode-alist '("\\.plantuml$" . plantuml-mode))
       )
     (req-package flycheck-plantuml
        :require flycheck plantuml-mode
        :defer t
        :init
        (flycheck-plantuml-setup)
          ;; (add-to-list 'puml-mode-hook #'(lambda () (message "enable flycheck")))
        )
   #+END_SRC
** dumb jump to definition
    - C-M g    jump to definition
    - C-M p    jump back
    - C-M q    like jump but shows tooltip
    #+BEGIN_SRC emacs-lisp
    (req-package dumb-jump
      :config
      (dumb-jump-mode))
    #+END_SRC
** cucumber tests for emacs
   mode for editing cucumber tests (*.feature)
   see [[https://github.com/ecukes/ecukes][here]]
   example project [[file:~/devel/emacs/Cask][here]]
   #+BEGIN_SRC emacs-lisp
   (req-package feature-mode
     :defer 7)
   (req-package ecukes
     :defer 7)
   (req-package espuds
     :defer 7)
   #+END_SRC
* shell
** eshell
   #+begin_src emacs-lisp 
     ;; provide eldoc within eshell (and some more help)
     (req-package esh-help
       :require eshell
       :config (setup-esh-help-eldoc))
     ;; provide z command in eshell  
     (req-package eshell-z
       :require eshell)
     (req-package eshell
       :config
       (progn
         (setq eshell-cmpl-autolist t)
         (setq eshell-cmpl-cycle-completions nil)
         (setq eshell-show-lisp-completions t)

         (defun pcmpl-git-commands ()
           "Return the most common git commands by parsing the git output."
           (with-temp-buffer
             (call-process-shell-command "LC_ALL=en_US git" nil (current-buffer) nil "help" "--all")
             (goto-char 0)
             (search-forward "available git commands")
             (let (commands)
               (while (re-search-forward
                       "^[[:blank:]]+\\([[:word:]-.]+\\)[[:blank:]]*\\([[:word:]-.]+\\)?"
                       nil t)
                 (push (match-string 1) commands)
                 (when (match-string 2)
                   (push (match-string 2) commands)))
               (sort commands #'string<))))

         (defconst pcmpl-git-commands (pcmpl-git-commands)
           "List of `git' commands.")

         (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
           "The `git' command to run to get a list of refs.")

         (defun pcmpl-git-get-refs (type)
           "Return a list of `git' refs filtered by TYPE."
           (with-temp-buffer
             (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
             (goto-char (point-min))
             (let (refs)
               (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
                 (push (match-string 1) refs))
               (nreverse refs))))

         (defun pcmpl-git-remotes ()
           "Return a list of remote repositories."
           (split-string (shell-command-to-string "git remote")))

         (defun pcomplete/git ()
           "Completion for `git'."
           ;; Completion for the command argument.
           (pcomplete-here* pcmpl-git-commands)
           (cond
            ((pcomplete-match "help" 1)
             (pcomplete-here* pcmpl-git-commands))
            ((pcomplete-match (regexp-opt '("pull" "push")) 1)
             (pcomplete-here (pcmpl-git-remotes)))
            ;; provide branch completion for the command `checkout'.
            ((pcomplete-match "checkout" 1)
             (pcomplete-here* (append (pcmpl-git-get-refs "heads")
                                      (pcmpl-git-get-refs "tags"))))
            (t
             (while (pcomplete-here (pcomplete-entries))))))

         (defun company-eshell-history (command &optional arg &rest ignored)
           (interactive (list 'interactive))
           (cl-case command
             (interactive (company-begin-backend 'company-eshell-history))
             (prefix (and (eq major-mode 'eshell-mode)
                          (let ((word (company-grab-word)))
                            (save-excursion
                              (eshell-bol)
                              (and (looking-at-p (s-concat word "$")) word)))))
             (candidates (remove-duplicates
                          (->> (ring-elements eshell-history-ring)
                               (remove-if-not (lambda (item) (s-prefix-p arg item)))
                               (mapcar 's-trim))
                          :test 'string=))
             (sorted t)))

         ;; (add-to-list 'company-backends 'company-eshell-history)
         ))
   #+end_src
** settings
   #+BEGIN_SRC emacs-lisp
     ;; make sure M-x shell opens into currently open window (and does not open a new one)
     (add-to-list 'display-buffer-alist
                  '("^\\*shell.*\\*$" . (display-buffer-same-window)))
     (require 'comint) ;; part of emacs
     (setq comint-password-prompt-regexp
             (concat comint-password-prompt-regexp
                     "\\|^.* passphrase.*\\'"))

     (setq-default sh-basic-offset 2)
     (setq-default sh-indentation 2)

     (setq warning-suppress-types '((undo discard-info)))
   #+END_SRC
** tmux (disabled for now)
   - enables interaction with tmux sessions
   - see https://github.com/syohex/emacs-emamux
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package emamux
       :config
       ;; (global-set-key (kbd "C-z") emamux:keymap)
       (custom-set-variables
        '(emamux:completing-read-type 'helm)))
   #+END_SRC
** shell here
   #+BEGIN_SRC emacs-lisp
     ;; open a shell at the current directory
     (req-package shell-here
       :bind (("C-c s !" . shell-here)))
     ;;      (define-key (current-global-map) "\C-c!" 'shell-here) ;
   #+END_SRC
** shell ansi colors configuration (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package ansi-color
       :init (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
       :config
       (setq ansi-color-names-vector
             ["black" "tomato" "PaleGreen2" "gold1"
              "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])
       (setq ansi-color-map (ansi-color-make-color-map))

       (add-to-list 'comint-output-filter-functions 'ansi-color-process-output))
   #+END_SRC
** xterm color
   #+BEGIN_SRC emacs-lisp
        (req-package xterm-color
          :init (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter)
          :config
          (progn (setq comint-output-filter-functions (remove 'ansi-color-process-output comint-output-filter-functions))))
   #+END_SRC
** friendly iteractive shell
   #+BEGIN_SRC emacs-lisp
     (defun shell-fish ()
       "start a friendly interactive shell (fish) within ansi-term"
       (interactive)
       (ansi-term (executable-find "fish")))
   #+END_SRC
** shell (bash) checking
   - built in shell editing mode, explicitly initialized here to enable flycheck-mode
   #+BEGIN_SRC emacs-lisp
     (req-package sh-script
       :require flycheck
       :init
       (add-hook 'sh-mode-hook 'flycheck-mode))
   #+END_SRC
** zshell
   #+BEGIN_SRC emacs-lisp
     (defun start-zsh ()
       "start a  z shell within ansi-term"
       (interactive)
       (ansi-term "/usr/local/bin/zsh"))
   #+END_SRC
* ebooks
  #+BEGIN_SRC emacs-lisp
    (req-package ereader
      :require xml+ dash
      :mode ("\\.epub\\'" . ereader-mode))
  #+END_SRC
* pdf-tooling
  - TODO check whether all that is required tools are installed for pdf tools to function, message if not, install if ok
  #+BEGIN_SRC emacs-lisp
    ;; allow in emacs pdf view/annotate etc.
    ;; if not functional do the following: remove package and restart emacs, then allow rebuild of pdf tooling, restart again
    (if (and make-installed poppler-installed imagemagick-installed)
        (req-package pdf-tools
          :mode ("\\.pdf$" . pdf-view-mode)
          :init (progn
                  ;; (add-hook 'after-init-hook 'pdf-tools-install)
                  ;; (add-hook 'pdf-tools-mode-hook 'pdf-isearch-minor-mode)
                  (add-hook 'pdf-view-mode-hook 'pdf-misc-minor-mode) ;; misc minor mode offset C-c C-p for printing pdf documents


                  ;; copied from http://babbagefiles.blogspot.de/2017/11/more-pdf-tools-tricks.html
                  (add-hook 'pdf-view-mode-hook (lambda ()
                                                  (pdf-view-midnight-minor-mode))) ; automatically turns on midnight-mode for pdfs

                  (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; set the amber profile as default (see below)

                  (defun gb/pdf-no-filter ()
                    "View pdf without colour filter."
                    (interactive)
                    (pdf-view-midnight-minor-mode -1)
                    )

                  ;; change midnite mode colours functions
                  (defun gb/pdf-midnite-original ()
                    "Set pdf-view-midnight-colors to original colours."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-amber ()
                    "Set pdf-view-midnight-colors to amber on dark slate blue."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; amber
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-green ()
                    "Set pdf-view-midnight-colors to green on black."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#00B800" . "#000000" )) ; green
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-colour-schemes ()
                    "Midnight mode colour schemes bound to keys"
                    (local-set-key (kbd "!") (quote gb/pdf-no-filter))
                    (local-set-key (kbd "@") (quote gb/pdf-midnite-amber))
                    (local-set-key (kbd "#") (quote gb/pdf-midnite-green))
                    (local-set-key (kbd "$") (quote gb/pdf-midnite-original))
                    )

                  (add-hook 'pdf-view-mode-hook 'gb/pdf-midnite-colour-schemes)


                  )
          :config
          (progn
            (setq pdf-misc-print-programm "/usr/bin/lp")
            (setq pdf-view-display-size (quote fit-page))
            (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge")))))
  #+END_SRC
* rest
#+BEGIN_SRC emacs-lisp
    (custom-set-variables
     ;; '(canlock-password "0e8b34f24c62bdf6cc5585ec93c62be865aee099")
     '(coffee-tab-width 4)
     '(cursor-in-non-selected-windows nil)
     '(custom-safe-themes
       (quote
        ("84d2f9eeb3f82d619ca4bfffe5f157282f4779732f48a5ac1484d94d5ff5b279" "4848f52f443b88525a4e2fe4f620a20c40fad90a66a953613be90556b9eb7880" "db790b6031dbc390c8b9318b077f5825302dad9d82925f4c70eaddd22825aafa" "141bdb2503f744acaa2bd8defb015f3c8e9e581ff40ec9ae4f3a27917256edaa" "516ef72a7861d71b39bdd8ae3d2c19628abb916a1456ea93a400cc222f87442a" "05b3ea2f5a8d1913eda3a209bb4bd0091c2aa15e4de64e0580f45d2534428568" "e93f05b3616b9e19a79c3ebd107252684bc88ecb77798617e72443b70aae86d5" "c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223" "a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e" "26614652a4b3515b4bbbb9828d71e206cc249b67c9142c06239ed3418eff95e2" "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default)))
     '(desktop-save nil)
     '(desktop-save-mode nil)
     '(gnutls-verify-error nil)
     '(iedit-toggle-key-default nil) ;; disable C-; binding of iedit that is loaded via lispy
  ;;   '(initial-frame-alist (quote ((fullscreen . maximized))))
     '(jde-jdk-doc-url "https://docs.oracle.com/javase/8/docs/api/")
     '(jde-jdk-registry
       (quote
        (("1.8.0_40" . "/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home")
         ("1.7.0_40" . "/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home"))))
     '(malabar-repl-grooysh "/usr/local/bin/groovysh")
     '(recentf-max-saved-items 80)
     '(region ((t (:background "gray45" :inverse-video nil))))
     '(rng-schema-locating-files
       (quote
        ((concat user-emacs-directory "ant-mode/ant-schemas.xml") "schemas.xml" "~/devel/xspec-read-only/editors/emacs/schemas.xml" "/Applications/Emacs.app/Contents/Resources/etc/schema/schemas.xml")))
     '(send-mail-function (quote smtpmail-multi-send-it))
     '(tool-bar-mode nil)
     '(truncate-lines nil)
     '(xslt-process-registered-stylesheets nil))

    (custom-set-faces
     ;; custom-set-faces was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init file should contain only one such instance.
     ;; If there is more than one, they won't work right.
     '(col-highlight ((t (:background "gray63"))))
     '(hi-yellow ((t (:background "gray44"))))
     '(region ((t (:background "gray45" :inverse-video nil))))
     '(popup-isearch-match ((t (:background "RoyalBlue2"))))
     '(term-color-yellow ((t (:background "DarkGoldenrod4" :foreground "#f0c674")))))

    ;; load the color scheme similar to lighttable
    ;; (load-theme 'noctilux t)

    ;; (setq cheat-sheet-locations '("Emacs_Reference_Card.pdf"
    ;;                               "calccard.pdf"
    ;;                               "dired-ref.pdf"
    ;;                               "dired-refcard.gnu.pdf"
    ;;                               "gnus-booklet.pdf"
    ;;                               "gnus-refcard.pdf"
    ;;                               "magitCheatsheet.pdf"
    ;;                               "orgcard.pdf"
    ;;                               "paredit-cheatsheet.pdf"))

    ;; ;; can be either 'right or 'below,
    ;; (setq cheat-sheet-split-mode 'below)

    ;; (defun open-cheat-sheet (file-path)
    ;;   "split depending on customization var cheat-sheet-split-mode and load file from file-path"
    ;;   (cond
    ;;    ((equal cheat-sheet-split-mode 'right) (split-window-right))
    ;;    ((equal cheat-sheet-split-mode 'left) (split-window-left))
    ;;    ;;     ((equal cheat-sheet-split-mode 'above) (split-window-below))
    ;;    ((equal cheat-sheet-split-mode 'below) (split-window-below)))
    ;;   (other-window 1)
    ;;   (find-file file-path)
    ;;   (cond
    ;;    ((equal cheat-sheet-split-mode 'right) (pdf-view-fit-height-to-window))
    ;;    ((equal cheat-sheet-split-mode 'left) (pdf-view-fit-height-to-window))
    ;;    ;;     ((equal cheat-sheet-split-mode 'above) (progn (pdf-view-fit-width-to-window)))
    ;;    ((equal cheat-sheet-split-mode 'below) (pdf-view-fit-width-to-window)))
    ;;   (other-window -1))

    ;; (defun close-cheat-sheet (file-path)
    ;;   "close the cheat sheet that is displayed, deleting the respective window"
    ;;   (with-selected-window
    ;;       (get-buffer-window (get-file-buffer file-path))
    ;;     (delete-window)))

    ;; (defun cheat-sheet-toggle (file-path)
    ;;   "open the given cheatsheet (or close it, if already open)"
    ;;   (let ((fbuf (get-file-buffer file-path)))
    ;;     (if (and fbuf (get-buffer-window fbuf))
    ;;         (close-cheat-sheet file-path)
    ;;       (open-cheat-sheet file-path))))

    ;; (defun cheat-sheet-clojure-toggle ()
    ;;   "open the clojure cheatsheet"
    ;;   (interactive)
    ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/clojure/clojure-cheatsheet-usletter-color.pdf")))

    ;; (defun cheat-sheet-org-toggle ()
    ;;   "open the org-mode cheatsheet"
    ;;   (interactive)
    ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/orgcard.pdf")))

    ;; (defun cheat-sheet-dired-toggle ()
    ;;   "open the dired cheatsheet"
    ;;   (interactive)
    ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/dired-refcard.gnu.pdf")))

    ;; (defun cheat-sheet-magit-toggle ()
    ;;   "open the magit cheatsheet"
    ;;   (interactive)
    ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/magitCheatsheet.pdf")))

    ;; clojure-cheatsheet
    ;; runs with existing repl only:
    ;; M-x clojure-cheatsheet opens a helm like search over severyl clojure concepts/functions etc.

    ;; focus
    ;; M-x focus-mode toggles this mode that focusses only on the construct under the cursor

    ;; helm-ag
    ;; search multi key word with M-x helm-ag


    ;; (add-to-list 'load-path "~/.emacs.d/clomacs/src/elisp/")
    ;; (require 'clomacs)

    ;; (clomacs-defun get-property System/getProperty)
    ;; (message (get-property "java.version"))

    ;; (req-package kanban)

    ;; (add-to-list 'load-path "~/git/local/hoclgen/src/elisp")
    ;; (require 'hoclgen)


    ;; (add-to-list 'load-path "~/.emacs.d/xml-customizations")
    ;; (load "xml-extensions.el")


    ;; C-c C-a annotate the marked region, or the word under point
    ;; annotations are saved in ~/.annotations



    ;; Set the defcustom variables defined in jiralib.el (actually only the jiralib-url is required, as the other 2 are usually computed from it correctly and is the case in the video demo):

    ;; 3 matches for "\bdefcustom\b" in buffer: jiralib.el
    ;;      55:(defcustom jiralib-host ""
    ;;     107:(defcustom jiralib-wsdl-descriptor-url
    ;;     120:(defcustom jiralib-url


    ;; Write your password in ~/.authinfo, with machine being the (computed) jiralib-host, and the port being 80 (even if you are using https for Jira):

    ;; machine JIRALIB-HOST login USERNAME password XXXXX port 80



#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :config
    (setq yas-snippet-dirs
          `(,(concat user-emacs-directory "snippets"))) ;; my snippets library

    ;; (add-hook 'prog-mode-hook #'yas-minor-mode) ;; make it a submode of all programming modes
    ;; (yas-global-mode 1) ;; make it global

    ;; Completing point by some yasnippet key
    (defun yas-ido-expand ()
      "Lets you select (and expand) a yasnippet key"
      (interactive)
      (let ((original-point (point)))
        (while (and
                (not (= (point) (point-min) ))
                (not (string-match "[[:space:]\n]" (char-to-string (char-before)))))
          (backward-word 1))
        (let* ((init-word (point))
               (word (buffer-substring init-word original-point))
               (list (yas-active-keys)))
          (goto-char original-point)
          (let ((key (remove-if-not
                      (lambda (s) (string-match (concat "^" word) s)) list)))
            (if (= (length key) 1)
                (setq key (pop key))
              (setq key (ido-completing-read "key: " list nil nil word)))
            (delete-char (- init-word original-point))
            (insert key)
            (yas-expand)))))


    (when (package-installed-p 'company)

      ;; Add yasnippet support for all company backends
      ;; https://github.com/syl20bnr/spacemacs/pull/179
      (defvar company-mode/enable-yas t
        "Enable yasnippet for all backends.")

      ;; instrument a backend ":with company-yasnippet"
      (defun company-mode/backend-with-yas (backend)
        (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      ;; instrument all existing backends with yasnippet
      (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

      ;; make sure that M-<tab> is available in yas-minor-mode
      (define-key yas-minor-mode-map (kbd "M-<tab>") #'company-try-hard)))
#+END_SRC
** yankpad
   - init (setq yankpad-file "~/yankpad.org")
   - use functions yankpad-map, yankpad-expand
   - see [[https://github.com/Kungsgeten/yankpad][homepage]]
   #+BEGIN_SRC emacs-lisp
     (req-package yankpad
       :init
       (when (package-installed-p 'company)
         ;; If you want to complete snippets using company-mode
         ;; (add-to-list 'company-backends #'company-yankpad)
         )
       :config
       (setq yankpad-file "~/yankpad.org"))
   #+END_SRC
* organizational (org, mail, news)
** elfeed
 #+BEGIN_SRC emacs-lisp
   (req-package elfeed
     :commands elfeed
     :bind (:map elfeed-search-mode-map
            ("l" . recenter-top-bottom))
     :config
     (progn
       (setq elfeed-use-curl t)
       (custom-set-faces
        '(elfeed-search-feed-face ((t (:foreground "NavajoWhite2"))))
        '(elfeed-search-title-face ((t (:foreground "dark gray"))))
        '(elfeed-search-unread-title-face ((t (:inherit elfeed-search-title-face :foreground "DarkOrange2")))))
       ))

   ;; Load elfeed-org
   (req-package elfeed-org
     :require elfeed org dash
     :init (progn
       ;; only programming related books
       (add-hook 'elfeed-new-entry-hook
                 (elfeed-make-tagger :feed-url "pdfbooksplanet"
                                     :entry-link '(not "programming")
                                     :add 'junk
                                     :remove 'unread))

       ;; only programming related books
       (add-hook 'elfeed-new-entry-hook
                 (elfeed-make-tagger :feed-url "BookDL"
                                     :entry-link '(not "programming")
                                     :add 'junk
                                     :remove 'unread))

       (add-hook 'elfeed-new-entry-hook
                 (elfeed-make-tagger :feed-url "lobste\\.rs"
                                     :entry-link '(not "emacs")
                                     :add 'junk
                                     :remove 'unread))

       )
     :config
     (progn

       ;; Initialize elfeed-org
       ;; This hooks up elfeed-org to read the configuration when elfeed
       ;; is started with =M-x elfeed=
       (elfeed-org)


       ;; Optionally specify a number of files containing elfeed
       ;; configuration. If not set then the location below is used.
       ;; Note: The customize interface is also supported.
       (setq rmh-elfeed-org-files (list "~/elfeed.org"))

       ;; show all news one week ago either unread or keep
       (setq-default elfeed-search-filter "@6-months-old +unread")

       (setf url-queue-timeout 30)


       ;; (setq elfeed-search-filter "@6-months-old +unread")
       ))

   (req-package noflet)

   (req-package elfeed-goodies
     :require elfeed popwin noflet ace-jump-mode ;; powerline
     :config
     (progn
       (setq elfeed-goodies/entry-pane-size 0.5)
       (setq elfeed-goodies/powerline-default-separator (quote bar))
       (setq elfeed-goodies/tag-column-width 30)
       (elfeed-goodies/setup)))
 #+END_SRC
** gnus (mail)
*** gnu-firstentry
 #+BEGIN_SRC emacs-lisp
     ;; add support to send from different smtp accounts
     ;; do this before custom variables are set, otherwise send-mail-function won't be set correctly!
     (req-package smtpmail-multi)

     ;; closed by gnu-lastentry!
     (req-package gnus
      :commands gnus
      :require smtpmail-multi mm-decode hydra bbdb
      :bind (
        :map gnus-group-mode-map
        ("<f1>" . hydra-gnus-group/body)
        ("C-c b l" . gnus-bookmark-bmenu-list)
        :map gnus-summary-mode-map
        ("<f1>" . hydra-gnus-summary/body)
        ("C-c b l" . gnus-bookmark-bmenu-list)
        ("C-c b m" . gnus-bookmark-set)
        ("C-c b s" . gnus-bookmark-set)
        :map gnus-article-edit-mode-map
        ("<f1>" . hydra-gnus-article-mime-part/body)
        :map gnus-article-mode-map
        ("<f1>" . hydra-gnus-article-mime-part/body)
        ("C-c b l" . gnus-bookmark-bmenu-list)
        :map message-mode-map
        ("<f1>" . hydra-gnus-article-mime-part/body)
      )
      :init  (progn
        ;; Sign messages by default
        (add-hook 'message-setup-hook 'mml-secure-sign-pgpmime)
   ;; make sure that truncate lines is off and word wrap is on when viewing articels
   (add-hook 'gnus-article-mode-hook
     (lambda ()
       (setq
         fill-column 60
         truncate-lines nil
         word-wrap t)))
        )
      :config ;; closing bracket follows way down !
 #+END_SRC
*** hydra
    #+BEGIN_SRC emacs-lisp
      ;;--------------------------------------------------------------------------------
      (require 'gnus-art)

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-summary ()
        "
              gnus summary
              ------------
              [_W_] : reply w/ original
              [_A_] : reply w/ original and all attachments
              [_v_] : save all mime parts

            %s(hydra-combine-functions-w-key-bindings 
              '((\"  [W] reply w/ original                \" . gnus-summary-wide-reply-with-original)
                (\"  [A] reply w/ original and attachments\" . gnus-summary-mail-forward)
                (\"  [v] save all mime parts              \" . gnus-summary-save-parts)))
            "
        ("W" gnus-summary-wide-reply-with-original :exit t)
        ("A" gnus-summary-mail-forward :exit t)
        ("v" gnus-summary-save-parts :exit t))

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-group ()
        "
             gnus group view
             ---------------
             [_G_]: search in (marked) group(s)  [_r_]: mark by regular expression   
             [_c_]: make a new group             [_m_]: mark this group              
             [_E_]: edit group                   [_U_]: unmark all groups            
              ^ ^                                [_u_]: unmark current group         

            %s(hydra-combine-functions-w-key-bindings
              '((\" [G] search in (marked) group(s) \" . gnus-group-make-nnir-group)
                (\" [c] make new group              \" . gnus-group-make-group)
                (\" [E] edit group                  \" . gnus-group-edit-group)
                (\" [r] mark by regular expression  \" . gnus-group-mark-regexp)
                (\" [m] mark this group             \" . gnus-group-mark-group)
                (\" [U] unmark all groups           \" . gnus-group-unmark-all-groups)
                (\" [u] unmark current group        \" . gnus-group-unmark-group)))
        "
        ("G" gnus-group-make-nnir-group :exit t)
        ("c" gnus-group-make-group :exit t)
        ("E" gnus-group-edit-group :exit t)
        ("r" gnus-group-mark-regexp)
        ("m" gnus-group-mark-group)
        ("U" gnus-group-unmark-all-groups :exit t)
        ("u" gnus-group-unmark-group))

      (defhydra hydra-gnus-article-mime-part ()
        "
                gnus article mime part
                ----------------------
                _o_: save mime part
                _e_: encrypt message
                _s_: sign message

            %s(hydra-combine-functions-w-key-bindings
                '((\"    [o] save mime part \" . gnus-mime-save-part)
                  (\"    [e] encrypt message\" . mml-secure-message-encrypt-pgpmime)
                  (\"    [s] sign message   \" . mml-secure-message-sign-pgpmime)))
              "
        ("o" gnus-mime-save-part)
        ("e" mml-secure-message-encrypt-pgpmime :exit t)
        ("s" mml-secure-message-sign-pgpmime :exit t))

    #+END_SRC
*** vars
    #+BEGIN_SRC emacs-lisp
      (setq gnus-cache-enter-articles nil)
      (setq gnus-cache-remove-articles (quote (dormant)))
      (setq gnus-extra-headers (quote (To Cc Keywords Gcc Newsgroups Content-Type)))
      (setq gnus-gcc-mark-as-read t)
      (setq gnus-large-newsgroup 800)
      (setq gnus-show-threads nil)
      (setq gnus-use-cache t)
      (setq gnus-visible-headers '("^From:" "^Newsgroups:" "^Subject:" "^Date:" "^Followup-To:" "^Reply-To:" "^Organization:" "^Summary:" "^Keywords:" "^To:" "^[BGF]?Cc:" "^Posted-To:" "^Mail-Copies-To:" "^Mail-Followup-To:" "^Apparently-To:" "^Gnus-Warning:" "^Resent-From:" "^X-Sent:" "^X-AnteSpam-Report:"))

      (setq message-send-mail-function (quote smtpmail-multi-send-it))

      ;; reply signed mails with signed mails
      (setq gnus-message-replysign t)
      (setq mm-decrypt-option (quote always))

      ;; nil = use default key to sign
      ;; guided = make sure that whenever signing is necessary, user is queried to select key
      (setq mm-sign-option nil)
      ;; use the sender to select default key
      (setq mml-secure-openpgp-sign-with-sender t)
      (setq mm-verify-option (quote known))
      (setq mml-secure-fail-when-key-problem t)

      (setq mm-fill-flowed nil)
      (setq mm-inline-large-images (quote resize))

      (setq nnmail-extra-headers (quote (To Newsgroups Cc Content-Type)))

      ;; gnus will try to build threads from old headers
      (setq gnus-fetch-old-headers t)
    #+END_SRC
*** gravatar
    - see [[https://www.gnu.org/software/emacs//manual/html_mono/gnus.html#Gravatars][here]]
    #+BEGIN_SRC emacs-lisp
    (setq gnus-treat-from-gravatar 'head) ;; show gravatar in from line
    ;; (setq gnus-treat-mail-gravatar 'head) ;; show gravator in to and cc line
    (setq gnus-gravatar-size 75)          ;; size of gravatar (in pixel)
    #+END_SRC
*** ui
 #+BEGIN_SRC emacs-lisp
   ;; eww background coloring (to prevent light gray background in htlm mails)
   (setq shr-color-visible-luminance-min 80)
   (setq shr-use-fonts nil) ;; don't use proportional fonts


   ;; Gnus formatting and colorizing

   ;; customize org link
   (custom-set-faces '(org-link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
   (custom-set-faces '(org-date ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))

   (copy-face 'default 'mysubject)
   (setq gnus-face-1 'mysubject)

   (copy-face 'default 'mytime)
   (set-face-foreground 'mytime "cornflowerblue")
   (setq gnus-face-2 'mytime)

   (copy-face 'default 'mythreads)
   (set-face-foreground 'mythreads "turquoise")
   (setq gnus-face-3 'mythreads)

   (copy-face 'default 'mygrey)
   (set-face-foreground 'mygrey "blue")
   (setq gnus-face-4 'mygrey)

   (copy-face 'default 'myblack)
   (set-face-foreground 'myblack "gold")
   (setq gnus-face-5 'myblack)

   (copy-face 'default 'mybiggernumbers)
   (set-face-foreground 'mybiggernumbers "seagreen")
   (setq gnus-face-6 'mybiggernumbers)


   (defun gnus-user-format-function-@ (header)
     "Display @ for message with attachment in summary line.
   You need to add `Content-Type' to `nnmail-extra-headers' and
   `gnus-extra-headers', see Info node `(gnus)To From Newsgroups'."
     (let ((case-fold-search t)
           (ctype (or (cdr (assq 'Content-Type (mail-header-extra header)))
                      "text/plain"))
           (indicator " ")
           (header-extra (mail-header-extra header))) ;; <-- check this
       (when  (or (string-match "^text/calendar" ctype) ;; calendar is deeply nested within, but this check works only for top level types
                  (string-match "^multipart/mixed" ctype)) 
         (setq indicator "@"))
       indicator))

   ;; make sure that (safe) inline images are shown in html messages
   (if w3m-installed
       (setq mm-text-html-renderer 'w3m))
   (setq gnus-inhibit-images nil)
   (setq w3m-display-inline-image t)
   (setq mm-html-inhibit-images nil) ;; allow inlining images
   ;; (setq mm-attachment-override-types '("image/.*"
   ;;                    "text/x-vcard"
   ;; 				   "application/pkcs7-mime"
   ;; 				   "application/x-pkcs7-mime"
   ;; 				   "application/pkcs7-signature"
   ;; 				   "application/x-pkcs7-signature"))
   (add-to-list 'mm-attachment-override-types "image/.*")

   ;; provide buttons to select between html message and pure text message!
   (setq gnus-buttonized-mime-types
         '("multipart/alternative" "multipart/signed")
         mm-discouraged-alternatives
         '("text/html" "image/.*"))

   (setq gnus-summary-line-format 
         (concat
          "%*%5{%U%R%z%}" ;; (U)nread (R)eplied (z)??
          "%4{|%}"
          "%2{%-5N%}" ;; (N) article number
          "%4{|%}"
          "%2{%-10&user-date;%}" ;; date
          "%4{|%}"
          "%5{%u&@;%}"  ;; gnus-user-format-function-@ to print @ for messages with attachments
          "%2{ %}%(%-24,24f" ;; (f) prints from (if not ignored address, else to)!
          "%4{|%}"
          "%2{%6k %}%)" ;; (k) human readable size 
          "%4{|%}"
          "%2{ %}%3{%B%}%1{%s%}\n") ;; (s)ubject
          )

   ;; (cond (window-system
   ;;        (setq custom-background-mode 'light)
   ;;        (defface my-group-face-1
   ;;          '((t (:foreground "Red" :bold t))) "First group face")
   ;;        (defface my-group-face-2
   ;;          '((t (:foreground "DarkSeaGreen4" :bold t)))
   ;;          "Second group face")
   ;;        (defface my-group-face-3
   ;;          '((t (:foreground "Green4" :bold t))) "Third group face")
   ;;        (defface my-group-face-4
   ;;          '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
   ;;        (defface my-group-face-5
   ;;          '((t (:foreground "Blue" :bold t))) "Fifth group face")))

   ;; (setq gnus-group-highlight
   ;;       '(((> unread 200) . my-group-face-1)
   ;;         ((and (< level 3) (zerop unread)) . my-group-face-2)
   ;;         ((< level 3) . my-group-face-3)
   ;;         ((zerop unread) . my-group-face-4)
   ;;         (t . my-group-face-5)))

   ;; make the default sorting of all groups to be sorted by date!
   (setq gnus-article-sort-functions '((not gnus-article-sort-by-date)))


   (setq gnus-summary-mode-line-format "Gnus: %p [%A / Sc:%4z] %Z")

   (setq-default
    gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
    gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
    gnus-thread-sort-functions '(gnus-thread-sort-by-date)
    gnus-sum-thread-tree-false-root ""
    gnus-sum-thread-tree-indent " "
    gnus-sum-thread-tree-leaf-with-other " "
    gnus-sum-thread-tree-root ""
    gnus-sum-thread-tree-single-leaf " "
    gnus-sum-thread-tree-vertical "")

   ;; make sure that summary/article are 35%/65% instead of 25%/75% (default)
   ;; (gnus-add-configuration '(article (vertical 1.0 (summary .35 point) (article 1.0))))
   (gnus-add-configuration
    '(article
      (horizontal 1.0 (vertical 50
                           (group 1.0))
               (vertical 1.0
                         (summary 0.35 point)
                         (article 1.0)))))
   (gnus-add-configuration
    '(summary
      (horizontal 1.0 (vertical 50
                 (group 1.0))
       (vertical 1.0
                 (summary 1.0 point)))))


   ;; turn off flowed mode
   (setq fill-flowed-display-column nil)


 #+END_SRC
*** polling new mails
 #+BEGIN_SRC emacs-lisp
     ;; make sure a timeout ends this tries if going offline
     (defadvice gnus-demon-scan-news (around gnus-demon-timeout activate)
       "Timeout for Gnus."
       (with-timeout
           (120 (message "Gnus timed out."))
         ad-do-it))

     ;; after gnus is started run timer to retrieve new mails!
     (setq gnus-startup-hook
           '(lambda ()
              (gnus-demon-add-handler 'gnus-demon-scan-news 15 nil) ; this does a call to gnus-group-get-new-news
              ))

     (defun gnus-frequent-check-new-mail ()
       "make checking mails run every 5 minutes"
       (interactive)
       (gnus-check-mail 5))

     (defun gnus-lazy-check-new-mail ()
       "make checking mails run every hour"
       (interactive)
       (gnus-check-mail 60))

     (defun gnus-normal-check-new-mail ()
       "make checking emails run ever 15 minutes"
       (interactive)
       (gnus-check-mail 15))

     (defun gnus-check-mail (minutes)  
       "make checking mails run every minutes"
       (gnus-demon-remove-handler 'gnus-demon-scan-news)
       (gnus-demon-add-handler 'gnus-demon-scan-news minutes nil)
       (message "now check every %s minutes" minutes))
 #+END_SRC
*** group line format
    #+BEGIN_SRC emacs-lisp
    ;; (M) marked articles
    ;; (S) subscribed group indicator
    ;; (G) group name
    ;; (y) # of unread
    ;; (t) estimated total number of articales
    ;; (D) group description
    (setq gnus-group-line-format "%M%S %-27uG %5y/%-10t %D\n")
    #+END_SRC
*** misc 
 #+BEGIN_SRC emacs-lisp
     (defun message-toggle-gcc ()
       "Insert or remove the \"Gcc\" header."
       (interactive)
       (save-excursion
         (save-restriction
           (message-narrow-to-headers)
           (if (message-fetch-field "Gcc")
               (message-remove-header "Gcc")
             (gnus-inews-insert-gcc)))))

 #+END_SRC
*** gnu-lastentry
 #+BEGIN_SRC emacs-lisp
 ) ;; closes req-package of gnus!
 #+END_SRC
*** nnir (make mails searchable)
**** add keybindings for searching imap groups (currently 'G G' within top top level)
**** construct hydra 
  #+BEGIN_SRC emacs-lisp
    ;; make imap searchable
    ;;(req-package nnir
    ;;  :require gnus)
  #+END_SRC
*** accounts (user specific stuff)
    #+BEGIN_SRC emacs-lisp
      (when mail-accounts-exists
            (req-package mail-accounts
              :loader :path
              :load-path "~/.emacs.d/accounts/"
              :require gnus))
    #+END_SRC
** bbdb
*** bbdb itself
 #+BEGIN_SRC emacs-lisp
     ;; make sure that email addresses are stored in the bbdb (database)

   (req-package bbdb
     :init (progn
     ;; use ; on a message to invoke bbdb interactively
     (add-hook 'gnus-summary-mode-hook
               (lambda ()
                 (define-key gnus-summary-mode-map (kbd ";") 'bbdb-mua-edit-field)
                 )))
     :config

     ;; initialization
     (bbdb-initialize 'gnus 'message)
     (bbdb-mua-auto-update-init 'gnus 'message)

     (setq bbdb-layout (quote full-multi-line))

     ;; size of the bbdb popup
     (setq bbdb-pop-up-window-size 5)

     ;; ask for saving bbdb (t = ask, nil = don't ask, other = always save)
     (setq bbdb-offer-save "yes")

     ;; What do we do when invoking bbdb interactively
     (setq bbdb-mua-update-interactive-p '(query . create))

     ;; make sure we look at every address in a message and not only the
     ;; first one
     (setq bbdb-message-all-addresses t)

     (setq bbdb-address-label-list (quote ("" "home" "work" "other")))
     (setq bbdb-file "~/bbdb")
     (setq bbdb-phone-label-list (quote ("" "home" "work" "cell" "other")))

     )


 #+END_SRC
*** incremental search within bbdb (and more) [[https://github.com/aki2o/bbdb-][link]]
**** to open (during writing mails): M-x bbdb-:start-completion
**** keybinding in that mode is then 
      j ... Go to next record
      k ... Go to previous record
      h ... Go to previous char
      l ... Go to next char
      J ... Scroll down
      K ... Scroll up
      s ... Start incremental search
      S ... Start incremental search with the reverse configuration about using migemo
      a ... Show all record
      t ... Mark current record as To
      c ... Mark current record as Cc
      b ... Mark current record as Bcc
      u ... Unmark current record
      t ... Mark all listed record as To
      c ... Mark all listed record as Cc
      b ... Mark all listed record as Bcc
      u ... Unmark all listed record
      R ... Reload the latest record of BBDB
      q ... Finish with doing nothing
      RET ... Finish with the update of To/Cc/Bcc header (if necessary, open the mail buffer)
  #+BEGIN_SRC emacs-lisp
    (req-package bbdb-
      :require bbdb
      :config
      (bbdb-:setup))
  #+END_SRC
*** csv export/import
 #+BEGIN_SRC emacs-lisp
   (req-package bbdb-csv-import
     :require bbdb)
 #+END_SRC
*** extensive regex search in bbdb
 #+BEGIN_SRC emacs-lisp
   (req-package bbdb-ext
     :require bbdb)
 #+END_SRC
*** DONE popup window for email selection in mail client (seems to be alternative to bbdb-) (deactivated)
    - seems no longer available
 #+BEGIN_SRC emacs-lisp :tangle no
   (req-package bbdb-handy
     :require bbdb
     :config
     (bbdb-handy-enable))
 #+END_SRC
*** export entry as vcard
 #+BEGIN_SRC emacs-lisp
;;   (req-package bbdb-vcard
;;     :require bbdb)
 #+END_SRC
** calendar
 #+BEGIN_SRC emacs-lisp
     (setq calendar-latitude 53.55)
     (setq calendar-longitude 9.99)
     (setq calendar-location-name "Hamburg, D")
     (setq european-calendar-style t)
     (setq calendar-week-start-day 1)
     (setq display-time-24hr-format 1)

     (setq calendar-mark-diary-entries-flag t)
     (setq view-diary-entries-initially t)
     ;; the below had to be done if the given entry was not there before hand
     ;; thus all appointments are marked within the calendar now
     ;; echo "%%(org-diary)" >> ~/diary 

     (add-hook 'calendar-today-visible-hook 'calendar-mark-today) ;; mark today within the calendar view
     (custom-theme-set-faces 'user '(calendar-today ((t :foreground "orange"))))
     (custom-theme-set-faces 'user '(calendar-iso-week-face ((t :foreground "lightblue"))))

     ;; code below prints iso calendar weeks into the calendar
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute 'calendar-iso-week-face nil
                         :height 1.0)
     (setq calendar-intermonth-text
           '(propertize
             (format "%2d"
                     (car
                      (calendar-iso-from-absolute
                       (calendar-absolute-from-gregorian (list month day year)))))
             'font-lock-face 'calendar-iso-week-face))

 #+END_SRC
** IMPLEMENT org
*** org
  #+BEGIN_SRC emacs-lisp
        (req-package org
          :require hydra helm
          :bind (
            :map  org-mode-map
            ("<f1>" . hydra-org-mode/body)
            ("s-i" . helm-org-in-buffer-headings)
            ("RET" . gb/org-smart-return)
            ("C-c l" . org-store-link)
            ("C-c t i" . org-toggle-item))
          :init (progn
          (add-hook 'after-change-major-mode-hook #'gb/activate-properties-in-org-mode)
          (add-hook 'org-mode-hook #'gb/enable-auto-fill-mode)
          ;; (add-hook 'org-mode-hook #'org-sticky-header)

          ;; make sure source blocks are collapsed at first
          ;; and C-x t b expands and recollapses them
          ;; see [[https://emacs.stackexchange.com/questions/7211/collapse-src-blocks-in-org-mode-by-default][here]]
          (defvar gb/org-block-visible nil)
          (defun gb/org-toggle-block-visibility ()
            ""
            (interactive)
            (if gb/org-block-visible
                (org-hide-block-all)
              (org-show-block-all))
            (setq-local gb/org-block-visible (not gb/org-block-visible)))
          (add-hook 'org-mode-hook #'gb/org-toggle-block-visibility)

          (define-key gb/toggle-map "b" #'gb/org-toggle-block-visibility)

          ;; ensure that adjusted save hook is not executed when org edit src save is executed
          (advice-add 'org-edit-src-save :around #'gb/wrap-org-edit-src-save)
          ;; ensure that read only mode is removed when org src edit is started
          (advice-add 'org-edit-special :before #'(lambda (orig-func &rest args) (read-only-mode -1)))


            )
          :config
          (progn
          (require 'ob-clojure)
          (require 'org-inlinetask)

          (defun gb/org-smart-return (&optional ignore)
            "Add new list item, heading or table row with RET.
    A double return on an empty element deletes it.
    Use a prefix arg to get regular RET.
    reference: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/?utm_source=feedburner&utm_medium=twitter&utm_campaign=Feed:+TheKitchinResearchGroup+(The+Kitchin+Research+Group)"
            (interactive "P")
            (if ignore
                (org-return)
              (cond
               ;; Open links like usual
               ((eq 'link (car (org-element-context)))
                (org-open-at-point-global))
               ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
               ;; Johansson!
               ((org-inlinetask-in-task-p)
                (org-return))
               ;; add checkboxes
               ((org-at-item-checkbox-p)
                (org-insert-todo-heading nil))
               ;; lists end with two blank lines, so we need to make sure we are also not
               ;; at the beginning of a line to avoid a loop where a new entry gets
               ;; created with only one blank line.
               ((and (org-in-item-p) (not (bolp)))
                (if (org-element-property :contents-begin (org-element-context))
                    (org-insert-heading)
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")
                  (org-return)))
               ((org-at-heading-p)
                (if (not (string= "" (org-element-property :title (org-element-context))))
                    (progn (org-end-of-meta-data)
                           (org-insert-heading))
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")))
               ((org-at-table-p)
                (if (-any?
                     (lambda (x) (not (string= "" x)))
                     (nth
                      (- (org-table-current-dline) 1)
                      (org-table-to-lisp)))
                    (org-return)
                  ;; empty row
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")
                  (org-return)))
               (t
                (org-return)))))

          (defun gb/wrap-org-edit-src-save (orig-func &rest args)
            "remove save adjusted hook, execute save and add hook again.
    thus this function prevents org-babel tangle and setting the file on r/o when edited in org edit src mode"
            (remove-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
            (let ((res (apply orig-func args)))
              (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
              res))

          (defun gb/org-clock-in-switch-to-state-fn (state)
            "switch TODO to IMPLEMENT if clocking in!"
            (if (equal state "TODO")
                "IMPLEMENT"
              nil))

          (defun gb/org-global-props-key-re (key)
            "Construct a regular expression matching key and an optional plus and eating the spaces behind.
         Test for existence of the plus: (match-beginning 1)"
            (concat "^" (regexp-quote key) "\\(\\+\\)?[[:space:]]+"))

          (defun gb/org-global-props (&optional buffer)
            "Get the plists of global org properties of current buffer."
            (with-current-buffer (or buffer (current-buffer))
              (org-element-map (org-element-parse-buffer) 'keyword (lambda (el) (when (string-equal (org-element-property :key el) "PROPERTY") (nth 1 el))))))

          (defun gb/org-global-prop-value (key)
            "Get global org property KEY of current buffer.
           Adding up values for one key is supported."
            (let ((key-re (gb/org-global-props-key-re key))
                  (props (gb/org-global-props))
                  ret)
              (cl-loop with val for prop in props
                       when (string-match key-re (setq val (plist-get prop :value))) do
                       (setq
                        val (substring val (match-end 0))
                        ret (if (match-beginning 1)
                                (concat ret " " val)
                              val)))
              ret))

          ;; TODO: generalize to all properties
          (defun gb/activate-properties-in-org-mode ()
            (when (string= major-mode "org-mode")
              (let* ((readOnly (gb/org-global-prop-value "readonly")))
                (if (string= readOnly "yes")
                    (setq buffer-read-only t)))))

          ;; set org babel backgrounds for several languages
          (setq org-src-block-faces
                '(("emacs-lisp" (:background "#1b1010"))
                  ("java" (:background "#1b1010"))))

          ;; make sure latex is highlighted in org mode buffers
          ;; `latex'    Highlight LaTeX snippets and environments.
          ;;  `script'   Highlight subscript and superscript.
          ;;  `entities' Highlight entities.
          (setq org-highlight-latex-and-related '(latex script entities))

          ;; make sure that regular font in src block within org is 'white'
          (custom-set-faces '(org-block ((t (:foreground "gray75")))))
          (setq flycheck-keymap-prefix (kbd "C-c k"))

          ;;--------------------------------------------------------------------------------
          (defhydra hydra-org-mode ()
            "
              org mode
              ^-^------------------------------------------------
              _ci_: clock in             _cti_: toggle item
              _co_: clock out
              _cq_: clock cancel/quit
              _cj_: jump to clock
              _cd_: display clock times

              %s(hydra-combine-functions-w-key-bindings
                '((\"  [ci]  clock in            \" . org-clock-in)
                  (\"  [co]  clock out           \" . org-clock-out)
                  (\"  [cq]  clock cancel/quit   \" . org-clock-cancel)
                  (\"  [cj]  jump to clock       \" . org-clock-goto)
                  (\"  [cd]  display clock times \" . org-clock-display)
                  (\"  [cti] toggle item         \" . org-toggle-item)
                  ))
            "
            ("ci" org-clock-in :exit t)
            ("co" org-clock-out :exit t)
            ("cq" org-clock-cancel :exit t)
            ("cj" org-clock-goto :exit t)
            ("cd" org-clock-display :exit t)
            ("cti" org-toggle-item :exit t))


          ;; Resume clocking tasks when emacs is restarted
          (org-clock-persistence-insinuate)

          ;; make sure that clock display will include all times (even last year ...)
          (setq org-clock-display-default-range (quote untilnow))

          ;; Yes it's long... but more is better ;
          (setq org-clock-history-length 35)

          ;; Resume clocking task on clock-in if the clock is open
          (setq org-clock-in-resume t)

          ;; name the drawer to be "clocking"
          (setq org-clock-into-drawer "CLOCKING")

          ;; The format string used when creating CLOCKSUM lines.
          (setq org-duration-format '((special . h:mm)))
          (setq org-time-clocksum-format
            (quote
             (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))) ;; make sure that clock sums in org mode show hours and minutes only (no days)

          ;; Change task state to IMPLEMENT when clocking in (only if in STATE TODO)
          (setq org-clock-in-switch-to-state (function  gb/org-clock-in-switch-to-state-fn))

          ;; mark checked lists a bit differently
          (font-lock-add-keywords
              'org-mode
              `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
              'append)

          (setq org-ellipsis "") ;; make the ... at the end (that indicates folding) be a bit less invasive
          (setq org-hide-leading-stars t) ;; each level only one star
          (setq org-special-ctrl-a/e t) ;; jump to the head text only (not to the star marking the head)

          ;; replace dashes and bullets with utf-8 bullet
          ;; (font-lock-add-keywords 'org-mode
          ;;                         '(("^ +\\([-*]\\) "
          ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) ""))))))

          ;; make level headings larger / bold
          ;; (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
          ;;                             ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
          ;;                             ((x-list-fonts "Verdana")         '(:font "Verdana"))
          ;;                             ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
          ;;                             (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
          ;;      (base-font-color     (face-foreground 'default nil 'default))
          ;;      (headline           `(:inherit default :weight bold )))

            (custom-theme-set-faces 'user
          ;;                          `(org-document-title ((t ( :height 1.5 :underline nil))))
          ;;                          `(org-level-8 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-7 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-6 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-5 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-4 ((t (:foreground "#a97167"))))
          ;;                          `(org-level-3 ((t (:foreground "#4fa8a8" ,@headline))))
          ;;                          `(org-level-2 ((t (:foreground "#989848" ,@headline :height 1.1))))
                                    `(org-level-1 ((t (:foreground "#de935f")))))


          ))
  #+END_SRC
*** org mobile
    - this will put all org files (known to the system) into the transfer folder which is not what I want, I don't want all files to be
      synced via Dropwizard
    - could be tamed to not use all agenda files!
    #+BEGIN_SRC emacs-lisp
      (req-package org-mobile
        :commands org-mobile-pull org-mobile-push
        :require org
        :config
        (progn
        ;; Set to the location of your Org files on your local system
        (setq org-directory "~")
        ;; Set to the name of the file where new notes will be stored
        (setq org-mobile-inbox-for-pull "~/org-dropbox/flagged.org")
        ;; Set to <your Dropbox root directory>/MobileOrg.
        (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
        ;; make sure that no agenda files are put into tranfer folder
        (setq org-mobile-files (quote ("~/notes.synced.org")))
        ;; (setq org-mobile-agendas nil)

        ;; used for encryption of org mode files
        (let ((auth-map (jde-read-properties-file "~/.org-mobile.auth.gpg")))
          (setq org-mobile-encryption-password (gethash "org-mobile-encryption-secret" auth-map)))
        ;; make sure encryption is used
        (setq org-mobile-use-encryption t)
        ))
    #+END_SRC
*** org capture
    - for capture templates see [[http://orgmode.org/manual/Template-elements.html#Template-elements]]
    - intro for capture templates see http://cestlaz.github.io/posts/using-emacs-23-capture-1/
  #+BEGIN_SRC emacs-lisp
    (req-package org-capture
      :require org
      :bind ("C-c c" . org-capture)
      :init (progn
        ;;
        (defun gb/org-file-lineno-store-link ()
          "provide function that stores a file link with line number (when matching the wanted major mode)"
          (cond
           ((string-match "\\(emacs-lisp-mode\\|nxml-mode\\)" (format "%s" major-mode))
            (let* ((link (format "file:%s::%d" (file-truename buffer-file-name)
                                 (line-number-at-pos))))
              (org-store-link-props
               :type "file"
               :link link)))))

        ;; when storing a file link, store line number with it (when matching the wanted major mode)
        (add-hook 'org-store-link-functions 'gb/org-file-lineno-store-link)
        )
      :config
      (progn 

        (setq org-default-notes-file "~/notes.org")

        ;; TODO: define additional capture templates
        (setq org-capture-templates
              (append '(("t" "Todo" entry (file+headline "~/notes.org" "Tasks") "* TODO %?\n  %i\n  %a"))
                      org-capture-templates))

        ;; make sure that org templates for ical export into org agenda works
        ;; (gnus-calendar-insinuate-org-templates)


        ;; necessary, else an error is reported during org-magit-store-link
        ;; (setq with-editor-file-name-history-exclude nil)
        ))
  #+END_SRC
*** org agenda
  #+BEGIN_SRC emacs-lisp
    (req-package org-agenda
      :require org helm ;; agenda-accounts are option
      :config
      (progn

        ;;don't show tasks as scheduled if they are already shown as a deadline
        (setq org-agenda-skip-scheduled-if-deadline-is-shown t)

        ;;don't give a warning colour to tasks with impending deadlines
        ;;if they are scheduled to be done
        (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))

        ;;don't show tasks that are scheduled or have deadlines in the
        ;;normal todo list
        (setq org-agenda-todo-ignore-deadlines (quote all))
        (setq org-agenda-todo-ignore-scheduled (quote all))

        ;; sort agend entries by,
        ;; time-up       : Put entries with time-of-day indications first, early first
        ;; category-up   : Sort alphabetically by category, A-Z.
        ;; priority-down : Sort numerically by priority, high priority first.
        ;; category-keep : Keep the default order of categories, corresponding to the sequence in org-agenda-files.
        (setq org-agenda-sorting-strategy
              '((agenda time-up category-up)
                (todo priority-down todo-state-up category-down)
                (tags priority-down category-keep)
                (search category-keep)))

        ;; show repeated org agenda entries only once
        (setq org-agenda-show-future-repeats nil)

        ;;open agenda in current window
        (setq org-agenda-window-setup (quote current-window))
        ;;warn me of any deadlines in next 7 days
        (setq org-deadline-warning-days 7)
        ;; set only org agenda files that are currently reachable!
        ;; jump between these files <C-'>
        ;; these files are used for org agenda display of dates/todos etc.

        ;; show a fortnite
        (setq org-agenda-span 14)

        ;; include all diary events into org-agenda view
        (setq org-agenda-include-diary t) ;; this includes the holidays, too


        ;; make sure that a todo cannot switch to done, if one of its descendants is not done yet
        (setq org-enforce-todo-dependencies t)
        ;; make sure that todo cannot switch to done if a checkbox within its descendants is not checked!
        (setq org-enforce-todo-checkbox-dependencies t)

        ;; customize todo lists
        (setq org-todo-keywords
              '((sequence "TODO"               ;; currently to do task
                          "IMPLEMENT(i!)"      ;; currently implementing this to do
                          "TEST(t@/!)"         ;; currently testing this to do
                          "ACCEPT(a@/!)"       ;; accepted by tester
                          "PLANNED"            ;; planned as future task
                          "|"                  ;; separates todo from done state
                          "OBSOLETE(o!)"       ;; now obosolete 
                          "CARRY OVER(c!)"     ;; carried over to new to do
                          "DONE(d!)"           ;; finally done
                          )))
        (setq org-todo-keyword-faces
              '(("PLANNED" . "lightblue")
                ("TODO" . "red") 
                ("IMPLEMENT" . (:foreground "orange" :weight bold))
                ("TEST" . "yellow")
                ("ACCEPT" . (:foreground "gray" :weight bold))
                ("OBSOLETE" . "darkgreen")
                ("CARRY OVER" . "brown")
                ("DONE" . "green")))))

  #+END_SRC
*** org agenda user specific stuff
    #+BEGIN_SRC emacs-lisp
      (when agenda-accounts-exists
        (req-package agenda-accounts
          :require org org-agenda
          :loader :path
          :load-path "~/.emacs.d/accounts/"
          :config
          (progn
            (bind-key "i" #'gb/org-agenda-diary-entry org-agenda-keymap) ;; don't use :bind, since loading should be done before actully hitting this key!
            (defun gb/org-agenda-diary-entry ()
              "enter a new date into diary and allow selection of which calendar this should go into"
              (interactive)
              ;; now select and set org-agenda-diary-file
              (let* ((filename (helm-comp-read "calendar: " gb/org-calendar-files)) ;; <- provided by agenda-accounts
                     (fullname (concat "~/" filename)))
                (if (file-exists-p fullname)
                    (setq org-agenda-diary-file fullname)))
              (org-agenda-diary-entry)))))
    #+END_SRC
*** ical accept invitations into calendar
    allow to accept invitations and record these into the org-capture-file
    #+BEGIN_SRC emacs-lisp
      ;; (add-to-list 'load-path "~/.emacs.d/ical-event-master/")
      ;; (req-package gnus-calendar

      ;;   :loader :path
      ;;   :require org
      ;;   :config
      ;;   (gnus-calendar-setup)
      ;;   ;; to enable optional iCalendar->Org sync functionality
      ;;   ;; NOTE: both the capture file and the headline(s) inside must already exist
      ;;   ;; remove entry from org capture templates (which are used to actually insert the invitation)
      ;;   (setq org-capture-templates (-remove (lambda (x) (string= gnus-calendar-org-template-name (second x))) org-capture-templates))
      ;;   ;; put all new events into agenda.org which is synced with the itemis work calendar (not private)
      ;;   (setq gnus-calendar-org-capture-file "~/agenda.org")
      ;;   ;; heading-1 within the org file, under which the events are created
      ;;   (setq gnus-calendar-org-capture-headline '("Calendar"))
      ;;   ;; do the setup with the given values
      ;;   (gnus-calendar-org-setup))
    #+END_SRC
*** gcal (see [[https://github.com/myuhe/org-gcal.el][link]]) currently not in use (may be useful if authentification used by org-caldav is no longer accessible)
    - BEFORE EXECUTING "org-gcal-sync", execute "org-gcal-fetch"
    - org-gcal-sync: sync org files with calendars
    - org-gcal-fetch: initially fetch all calendar events into org files (before fetch, the org files should be completely empty!)
    - org-gcal-post-at-point: post/edit org block at point to google calendar
    - org-gcal-referesh-token: refresh oauth token (expires in 1h)
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (req-package org-gcal
        :require calendar-accounts org
        :commands org-gcal-sync org-gcal-fetch org-gcal-post-at-point org-gcal-refresh-token
        :config
        (progn 
            (require 'calendar-accounts)
            (gb/load-calendar-credentials))))
    #+END_SRC
*** caldav sync
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (req-package org-caldav
        :require org calendar-accounts oauth2
        :commands org-caldav-sync
        :config
        (setq org-icalendar-timezone "Europe/Berlin")
        (setq org-caldav-delete-org-entries 'never)
        (setq org-caldav-delete-calendar-entries 'never)
        (setq org-caldav-debug-level 3)

        (require 'calendar-accounts)
        (gb/load-calendar-credentials)

        ;; redefine sync to cal
        (require 'org-caldav)
        ;;(setq org-caldav-url 'google)

        ;; make sure cal is not deleted
        (defun org-caldav-delete-event (uid)
          "Delete event UID from calendar.
      Returns t on success and nil if an error occurs.  The error will
      be caught and a message displayed instead."
          (message "executing patched version of org-caldav-delete-event")
          (org-caldav-debug-print 1 (format "(Deleting) event UID %s." uid))
          (condition-case err
              (progn
                ;; (url-dav-delete-file (concat (org-caldav-events-url) uid org-caldav-uuid-extension))
                t)
            (error
             (progn
               (message "Could not delete URI %s." uid)
               (org-caldav-debug-print 1 "Got error while removing UID:" err)
               nil))))

        ;; make sure that update never deletes from calendar
        (defun old-org-caldav-update-events-in-cal (icsbuf)
          "Update events in calendar.
      ICSBUF is the buffer containing the exported iCalendar file."
          (message "executing patched version of org-caldav-update-event-in-cal")
          (org-caldav-debug-print 1 "=== Updating events in calendar")
          (with-current-buffer icsbuf
            (widen)
            (goto-char (point-min))
            (let ((events (append (org-caldav-filter-events 'new-in-org)
                                  (org-caldav-filter-events 'changed-in-org)))
                  (counter 0)
                  (url-show-status nil)
                  (event-etag (org-caldav-get-event-etag-list))
                  uid)
              ;; Put the events via CalDAV.
              (dolist (cur events)
                (setq counter (1+ counter))
                (if (eq (org-caldav-event-etag cur) 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Was already put previously." (car cur)))
                  (org-caldav-debug-print 1
                                          (format "Event UID %s: Org --> Cal" (car cur)))
                  (widen)
                  (goto-char (point-min))
                  (while (and (setq uid (org-caldav-get-uid))
                              (not (string-match (car cur) uid))))
                  (unless (string-match (car cur) uid)
                    (error "Could not find UID %s" (car cur)))
                  (org-caldav-narrow-event-under-point)
                  (org-caldav-cleanup-ics-description)
                  (org-caldav-maybe-fix-timezone)
                  (org-caldav-set-sequence-number cur event-etag)
                  (message "Putting event %d of %d" counter (length events))
                  (if (org-caldav-put-event icsbuf)
                      (org-caldav-event-set-etag cur 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Error while doing Org --> Cal" (car cur)))
                    (org-caldav-event-set-status cur 'error)
                    (push (list org-caldav-calendar-id (car cur)
                                'error 'error:org->cal)
                          org-caldav-sync-result))))
              ;; Get Etags
              (setq event-etag (org-caldav-get-event-etag-list))
              (dolist (cur events)
                (let ((etag (assoc (car cur) event-etag)))
                  (when (and (not (eq (org-caldav-event-status cur) 'error))
                             etag)
                    (org-caldav-event-set-etag cur (cdr etag))
                    (push (list org-caldav-calendar-id (car cur)
                                (org-caldav-event-status cur) 'org->cal)
                          org-caldav-sync-result)))))
            ;; Remove events that were deleted in org 
            (let ((events (org-caldav-filter-events 'deleted-in-org))
                  (url-show-status nil)
                  (counter 0))
              (dolist (cur events)
                (setq counter (1+ counter))
                (message "(no really) deleting event %d from %d" counter (length events))
                ;; (org-caldav-delete-event (car cur))
                (push (list org-caldav-calendar-id (car cur)
                            'deleted-in-org 'removed-from-cal)
                      org-caldav-sync-result)
                (setq org-caldav-event-list
                      (delete cur org-caldav-event-list))))
            ;; Remove events that could not be put
            (dolist (cur (org-caldav-filter-events 'error))
              (setq org-caldav-event-list
                    (delete cur org-caldav-event-list)))))

        ))
    #+END_SRC
*** accounts for calendar sync
    #+BEGIN_SRC emacs-lisp
      (when calendar-accounts-exists
          (req-package calendar-accounts
            :require org
            :loader :path
            :load-path "~/.emacs.d/accounts/"))
    #+END_SRC
*** german holidays into calendar
    #+BEGIN_SRC emacs-lisp
      (req-package german-holidays
        :require org
        :config
        ;; (setq holiday-other-holidays holiday-german-holidays)
        ;; make sure that the right holidays are used (and no others)
        (setq calendar-holidays holiday-german-holidays))
        ;; (setq calendar-holidays
        ;;       (append (if (boundp 'local-holidays) local-holidays '())  
        ;;               (if (boundp 'other-holidays) other-holidays '())
        ;;               holiday-german-holidays)))
    #+END_SRC
*** org bullets
 #+BEGIN_SRC emacs-lisp
 (req-package org-bullets
   :require org
   :init
   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
   :config
   (setq org-bullets-bullet-list '("" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "")))
 #+END_SRC
*** level 3
**** level 4
***** level 5
****** level 6
******* level 7
******** level 8
********* level 9
********** level 10
*********** level 11
************ level 12
************* level 13
************** level 14
*** password manager
 #+BEGIN_SRC emacs-lisp
   (req-package org-password-manager
     :bind (:map org-mode-map
                 ("C-c s b" . gb/browse-to-link-property)
                 ("C-c s u" . org-password-manager-get-username)
                 ("C-c s p" . org-password-manager-get-password)
                 ("C-c s g" . org-password-manager-generate-password))
     :require org
     :config
     (defun gb/browse-to-link-property ()
       "get the property ':LINK:' from the entry at point and browse to url given as value"
       (interactive)
       (browse-url (org-entry-get (point) "LINK" t))))
 #+END_SRC
*** hide passwords in org files
    - loaded from [[https://raw.githubusercontent.com/jekor/hidepw/master/hidepw.el][here]]
    - hides passwords in password manager (any entry with ':PASSWORD:')
    #+BEGIN_SRC emacs-lisp
      (if (file-exists-p "~/.emacs.d/additionals/hidepw.el")
          (req-package hidepw
            :loader :path
            :load-path "~/.emacs.d/additionals/"
            :require org
            :init (progn
              (add-hook 'org-mode-hook  'hidepw-mode)
              )
            :config
            (progn
              (setq hidepw-pattern ":.*PASS.*: \\(.*\\)")
              ))
        (message "WARNING: hidepw.el not found. passwords will not be hidden in gpg files."))
    #+END_SRC
*** export modules (e.g. ox-confluence)
 #+BEGIN_SRC emacs-lisp
   ;;      (add-to-list 'load-path "~/.emacs.d/org-mode-exports/")
   ;;      (req-package ox-confluence
   ;;        :require org
   ;;        :commands org-confluence-export-as-confluence
   ;; ;;       :load-path "~/.emacs.d/org-mode-exports/"
   ;;        :loader :path)
 #+END_SRC
*** personal blogs
    - expects ~/Document/blog/org-jekyll.el to exist
    - download from [[http://github.com/juanre/org-jekyll][here]]
    - documentation [[http://juanreyero.com/open/org-jekyll/index.html][here]]
 #+BEGIN_SRC emacs-lisp
   (if (file-exists-p "~/Documents/blog/org-jekyll.el")
       (req-package org-jekyll
         :require org
         :defer 3
         :load-path "~/Documents/blog"))
 #+END_SRC
*** make org export use better highlighting with htmlize
 #+BEGIN_SRC emacs-lisp
    (req-package htmlize
      :defer 30)
 #+END_SRC
*** IMPLEMENT helm org rifle
**** find keybindings
  #+BEGIN_SRC emacs-lisp
    (req-package helm-org-rifle
       :require helm org
       :commands helm-org-rifle helm-org-rifle-directories helm-org-rifle-files)
  #+END_SRC
**** available functions
***** helm-org-rifle
      searches all open org files
***** helm-org-rifle-current-buffer
      searches the current buffers org file
***** helm-org-rifle-directories
      Shows results from selected directories; with prefix, recursively.
***** helm-org-rifle-files
      Shows results from selected files.
*** org appt (notification of agenda items)
    #+BEGIN_SRC emacs-lisp
      (req-package appt
        :require org
        :defer 20
        :init (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view
        :config
        (setq appt-time-msg-list nil)    ;; clear existing appt list
        (setq appt-display-interval '10) ;; warn every 10 minutes from t - appt-message-warning-time
        (setq
         appt-message-warning-time '10  ;; send first warning 10 minutes before appointment
         appt-display-mode-line nil     ;; don't show in the modeline
         appt-display-format 'window)   ;; pass warnings to the designated window function
        (appt-activate 1)                ;; activate appointment notification
        (display-time)                   ;; activate time display

        (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
        (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly

        ;; set up the call to terminal-notifier
        (defvar gb/appt-notifier-path "/usr/local/bin/terminal-notifier")  

        (defun gb/appt-send-notification (title msg)
          (shell-command (concat gb/appt-notifier-path " -message " msg " -title " title)))

        ;; designate the window function for my-appt-send-notification
        (defun gb/appt-display (min-to-app new-time msg)
          (gb/appt-send-notification 
           (format "'Appointment in %s minutes'" min-to-app)    ;; passed to -title in terminal-notifier call
           (format "'%s'" msg)))                                ;; passed to -message in terminal-notifier call

        (setq appt-disp-window-function (function gb/appt-display)))

    #+END_SRC
*** org review
    #+BEGIN_SRC emacs-lisp
      (req-package org-review
        :commands org-review-insert-next-review org-review-insert-last-review
        :require org)
    #+END_SRC
*** org ref
    - see https://github.com/jkitchin/org-ref
    #+BEGIN_SRC emacs-lisp
      (req-package org-ref
        :commands org-ref-insert-link
                  org-ref-helm-insert-ref-link
                  org-ref-list-of-tables
                  org-ref-list-of-figures
                  org-ref-helm-insert-label-link
        :require org helm-bibtex pdf-tools ivy hydra helm)
    #+END_SRC
*** org clip
    - ox-clip-formatted-copy copies selected region of org mode file as rtf into clipboard for insertion into e.g. open office
    #+BEGIN_SRC emacs-lisp
    (req-package ox-clip
      :commands ox-clip-formatted-copy
      :require org htmlize)
    #+END_SRC
*** org babel
    #+BEGIN_SRC emacs-lisp
       ;; set jar path for ditaa
       ;; sh 'brew info ditaa | grep -oe "/usr/local[^ ]*"' produces path to /usr/local/Cellar/ditaa/0.10
       ;; within this dir the file INSTALL_RECEIPT.json exists.
       ;; within this json file, under the key source.version.stable = '0.10' the version string is accessible
       ;; thus the org-ditaa-jar-path can be constructed (which is true for mac os brew systems)
       (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.10/libexec/ditaa0_10.jar") ;; "/usr/local/bin/ditaa"

       ;; set sed command for org babel
       (setq org-babel-sed-command "/usr/local/opt/gnu-sed/libexec/gnubin/sed")

       (setq org-src-fontify-natively t)

       ;; (addToList org-babel-shell-names "fish")

       ;; do not ask for confirmation when executing functions in org babel
       ;; (setq org-confirm-babel-evaluate nil)
       ;; Disable confirmation question when evaluating (C-c C-c) these languages
       (defun gb/org-confirm-babel-evaluate (lang body)
         (not (or (string= lang "plantuml")
                  ;; ... add more above this line when needed ...
                  )))
       (setq org-confirm-babel-evaluate 'gb/org-confirm-babel-evaluate)

       ;; redisplay images after org babel execute
       (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)


      ;;    - original source http://www.holgerschurig.de/en/emacs-init-tangle/
      (defun gb/speedy-emacs-init-tangle (filename)
        "This function will write all source blocks from FILENAME into
      ~/.emacs.d/init.el that are ...

      - not marked as =tangle: no=
      - doesn't have the TODO state =CANCELLED=
      - have a source-code of =emacs-lisp="
        (require 'org)
        (let* ((body-list ())
               (output-file "~/.emacs.d/init.el")
               (org-babel-default-header-args (org-babel-merge-params org-babel-default-header-args
                                                                      (list (cons :tangle output-file)))))
          (message "Writing %s ..." output-file)
          (save-restriction
            (save-excursion
              (org-babel-map-src-blocks filename
                                        (let* ((info (org-babel-get-src-block-info 'light))
                                               (tfile (cdr (assq :tangle (nth 2 info))))
                                               (match))
                                          (save-excursion
                                            (catch 'exit
                                              (org-back-to-heading t)
                                              (when (looking-at org-outline-regexp)
                                                (goto-char (1- (match-end 0))))
                                              (when (looking-at (concat " +" org-todo-regexp "\\( +\\|[ \t]*$\\)"))
                                                (setq match (match-string 1)))))
                                          (unless (or (string= "no" tfile)
                                                      (string= "CANCELED" match)
                                                      (not (string= "emacs-lisp" lang)))
                                            (add-to-list 'body-list body)))))
            (with-temp-file output-file
              (insert (format ";; Don't edit this file, edit '%s' instead ...\n\n" filename))
              (insert (apply 'concat (reverse body-list)))
              (emacs-lisp-mode)
              (condition-case nil
                  (check-parens)
                ;; error case is not executed even though user-error should be signaled if an error occurs
                (user-error (with-current-buffer (generate-new-buffer "*Generated init.el*")
                         (insert-file output-file)
                         (emacs-lisp-mode)
                         (check-parens)
                         (switch-to-buffer "*Generated init.el*")))))
            (message "Wrote %s ..." output-file))))

       ;; execute org babel if current major mode is org-mode
       ;; and the file has source code regions
       ;; and the file defines a header-args property with value :tangle ...
       ;; if this file writes into ~/.emacs.d/init.el then gb/speedy-emacs-init-tangle is used
       (defun gb/tangle-on-save-org-mode-file()
         (when (string= major-mode "org-mode")
           (progn
             (let ((has-source-regions (gb/buffer-contains-string "^ *#\\+BEGIN_SRC"))
                   (should-tangle (gb/buffer-contains-string "^#\\+PROPERTY: +header-args +:tangle"))
                   (target-is-initel (gb/buffer-contains-string (concat "^#\\+PROPERTY: +header-args +:tangle +" (regexp-quote "~/.emacs.d/init.el")))))
               (if (and has-source-regions should-tangle)
                   (progn
                     (when (package-installed-p 'yankpad)
                       (remove-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))
                     (when (package-installed-p 'pretty-mode)
                       (global-pretty-mode -1))
                     (when ligatures-enabled
                       (remove-hook 'prog-mode-hook
                                    #'add-fira-code-symbol-keywords))

                     (message "executing org-babel-tangle ...")
                     (if target-is-initel
                         (gb/speedy-emacs-init-tangle (buffer-file-name))
                       (let ((inhibit-message t))
                         (org-babel-tangle)))
                     (message "executing org-babel-tangle ... done.")

                     (when ligatures-enabled
                       (add-hook 'prog-mode-hook
                                 #'add-fira-code-symbol-keywords))
                     ;; check whether readonly should be applied again
                     ;; only if currently not in detailed edit mode
                     (gb/activate-properties-in-org-mode)
                     ;; the following currently takes about 3 seconds (which I don't want to spend)
                     ;;(when (package-installed-p 'pretty-mode)
                     ;;  (global-pretty-mode 1))
                     (when (package-installed-p 'yankpad)
                       (add-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))))))))

       ;; execute org babel on safe (if major mode is org-mode
       (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)

       ;; set default header args for plantuml
       (setq org-babel-default-header-args:PlantUML
             '((:results . "file") (:exports . "results") (:noweb . "yes") (:cmdline . "-charset UTF-8")))

       ;; use cider as backend for clojure
       (setq org-babel-clojure-backend (quote cider))

       ;; function is renamed to ...x (since it should not collide with impl. in org)
       (require 'ob-clojure) ;; load this first, then define the new function
       (defun org-babel-execute:clojure (body params)
         "Execute a block of Clojure code with Babel. Changes by GB"
         (let ((expanded (org-babel-expand-body:clojure body params))
               result)
           (cl-case org-babel-clojure-backend
             (cider
              (require 'cider)
              (let ((result-params (cdr (assq :result-params params))))
                (setq result
                      (nrepl-dict-get
                       (nrepl-sync-request:eval
                        expanded (cider-current-connection)) ;; <------------- change in cider api
                       (if (or (member "output" result-params)
                               (member "pp" result-params))
                           "out"
                         "value")))))
             (slime
              (require 'slime)
              (with-temp-buffer
                (insert expanded)
                (setq result
                      (slime-eval
                       `(swank:eval-and-grab-output
                         ,(buffer-substring-no-properties (point-min) (point-max)))
                       (cdr (assq :package params)))))))
           (org-babel-result-cond (cdr (assq :result-params params))
             result
             (condition-case nil (org-babel-script-escape result)
               (error result)))))

       ;; enable all languages listed below within org babel
       (when (version<= "9.0.5" (org-version))
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((java . t)
          (clojure . t)
          (ditaa . t)
          (dot . t)
          ;; (elixir . t)
          (emacs-lisp . t)
          (gnuplot . t)
          (groovy . t)
          (latex . t) ;; needs org-edit-latex
          ;; (max . t) ;; maxima
          (plantuml . t)
          ;; (prolog . t)
          (python . t)
          (scala . t)
          (scheme . t)
          (sed . t)
          (shell . t)
          ;; (sml . t) ;; standard ml
          (sql . t))))

    #+END_SRC
**** org babel lfe
     - use e.g. '#+BEGIN_SRC lfe :session mysession'
     - see [[https://github.com/zweifisch/ob-lfe][homepage]]
     #+BEGIN_SRC emacs-lisp
     (req-package ob-lfe
       :defer 10
       :require org)
     #+END_SRC
**** org babel mongo
     - use with following parameters for begin_src block
       :db        Database name
       :host      Host
       :port      Port
       :user	  Username
       :password  Password
       :mongoexec Mongo executable
     - see [[https://github.com/krisajenkins/ob-mongo][homepage]]
     #+BEGIN_SRC emacs-lisp
     (req-package ob-mongo
       :defer 10
       :require org)
     #+END_SRC
**** org babel redis
     - use e.g. '#+BEGIN_SRC redis db: 127.0.0.1:6379'
     - see [[https://github.com/stardiviner/ob-redis][homepage]]
     #+BEGIN_SRC emacs-lisp
     (req-package ob-redis
       :defer 10
       :require org)
     #+END_SRC
**** org babel translate
     - translate a babel source code e.g. '#+BEGIN_SRC translate :src de :dest it'
     - src can be omitted (is then auto)
     - see [[https://github.com/krisajenkins/ob-translate][homepage]]
     #+BEGIN_SRC emacs-lisp
     (req-package ob-translate
       :defer 10
       :require org)
     #+END_SRC
**** org babel typescript
     #+BEGIN_SRC emacs-lisp
     (req-package ob-typescript
       :defer 10
       :require org)
     #+END_SRC
**** org babel kotlin
     #+BEGIN_SRC emacs-lisp
     (req-package ob-kotlin
       :defer 10
       :require org)
     #+END_SRC
**** org babel elixir
     #+BEGIN_SRC emacs-lisp
     (req-package ob-elixir
       :defer 10
       :require org)
     #+END_SRC
**** org babel browser
     #+BEGIN_SRC emacs-lisp
     (req-package ob-browser
       :defer 10
       :require org)
     #+END_SRC
*** ob async
    - add ':async t' to #begin_src header, execution of block (C-c C-c within babel block) executes asynchronously)
    - see [[https://github.com/astahlman/ob-async][here]]
    #+BEGIN_SRC emacs-lisp
    (req-package ob-async
       :require org async)
    #+END_SRC
*** adaptive warp
    #+BEGIN_SRC emacs-lisp
      (req-package adaptive-wrap)
    #+END_SRC
*** insertion of web images
    - allow insertion of images via url, which automatically downloads
      into a local folder and creates a link within the org file
      [[https://github.com/tashrifsanil/org-easy-img-insert]]
    #+BEGIN_SRC emacs-lisp
      (req-package org-easy-img-insert
        :require org
        :bind ("C-c i" . org-easy-img-insert)
        :config (progn))
    #+END_SRC
*** org reveal (presentation)
    #+BEGIN_SRC emacs-lisp
    (req-package ox-reveal
      :defer 10
      :require org htmlize
      :config
      (progn
        (setq org-reveal-root "./reveal.js"))) ;; look into local folder
    #+END_SRC
*** org table sticky headers
    - see [[https://github.com/cute-jumper/org-table-sticky-header][home page]]
    - headers of org tables stay in the header line while scrolling them out of view
    #+BEGIN_SRC emacs-lisp
      (req-package org-table-sticky-header
        :defer 10
        :require org
        :init
        (progn (add-hook 'org-mode-hook 'org-table-sticky-header-mode)))
    #+END_SRC
*** org pdfview links
    - see [[https://github.com/markus1189/org-pdfview][homepage]]
    - executing M-x org-store-link within pdf-view-mode, will store a link that can be inserted into org mode via C-c C-l
    - when opening this link, pdf-view-mode is opened instead of system default pdf viewer!
    #+BEGIN_SRC emacs-lisp
      (progn
        (defun ensure-org-pdfview ()
          "ensure that package org-pdfview is loaded"
          (require 'org-pdfview))
        (when (fboundp 'org-mode)
          (add-hook 'org-mode-hook #'ensure-org-pdfview))
        (when (fboundp 'pdf-view-mode)
          (add-hook 'pdf-view-mode-hook #'ensure-org-pdfview)))

      (req-package org-pdfview
        :require org pdf-tools)
    #+END_SRC
*** org magit
    #+BEGIN_SRC emacs-lisp
    (req-package orgit
      :require org magit
      :defer 40)
    #+END_SRC
** slack (disabled)
 #+BEGIN_SRC emacs-lisp :tangle no

   (req-package slack
     :ensure t
     :disabled t
     :init           
     (setq slack-enable-emoji t) ;; if you want to enable emoji, default nil
     ;; (setq slack-room-subscription '(clojurians itemisHamburg))

     :config  
     (slack-start)
     (let* ((auth-map (jde-read-properties-file "~/.slack-auth.properties.gpg")))
       (slack-register-team
        :name "itemis-hh"
        :default t
        :client-id (gethash "slack-client-id" auth-map)
        :client-secret (gethash "slack-client-secret" auth-map)
        :token (gethash "slack-token" auth-map)
        :subscribed-channels '(general random))
       (slack-register-team
        :name "clojurians"
        :client-id (gethash "slack-client-id" auth-map)
        :client-secret (gethash "slack-client-secret" auth-map)
        :token (gethash "slack-token" auth-map)
        :subscribed-channels '(cider clojure-hamburg))
       ))


 #+END_SRC
* ido (disabled, now using helm)
** ido itself (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
    (req-package ido
      :disabled t
      :config
      ;; ido-mode allows you to more easily navigate choices. For example,
      ;; when you want to switch buffers, ido presents you with a list
      ;; of buffers in the the mini-buffer. As you start to type a buffer's
      ;; name, ido will narrow down the list of buffers to match the text
      ;; you've typed in
      ;; http://www.emacswiki.org/emacs/InteractivelyDoThings
      (ido-mode t)

      ;; This allows partial matches, e.g. "tl" will match "Tyrion Lannister"
      (setq ido-enable-flex-matching t)

      ;; Turn this behavior off because it's annoying
      (setq ido-use-filename-at-point nil)

      ;; Don't try to match file across all "work" directories; only match files
      ;; in the current directory displayed in the minibuffer
      (setq ido-auto-merge-work-directories-length -1)

      ;; Includes buffer names of recently open files, even if they're not
      ;; open now
      (setq ido-use-virtual-buffers t)

      (defface ivy-current-match
        '((((class color) (background light))
           :background "#1a4b77" :foreground "white")
          (((class color) (background dark))
           :background "#65a7e2" :foreground "black"))
        "Face used by Ivy for highlighting first match.")

      (setq ivy-display-style 'fancy)
      )
#+END_SRC
** ido grid (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package ido-grid-mode
    :require ido
    :disabled t
    :config
    ;; ido-grid-mode-max-columns 2
    ;; ido-grid-mode-min-columns 2
    (setq ido-grid-mode-max-rows 15
          ido-grid-mode-min-rows 10
          ido-grid-mode-max-columns 4
          ido-grid-mode-prefix-scrolls t
          ido-grid-mode-scroll-down #'ido-grid-mode-next-row
          ido-grid-mode-scroll-up #'ido-grid-mode-previous-row
          ido-grid-mode-order 'Row-mode ;; order is rows -> columns (t = columns -> rows)
          ido-grid-mode-start-collapsed nil) ;; collapsed = 1 row, on <tab> expand (if more than one is available)
    (ido-grid-mode 1))
#+END_SRC
** ido vertical (currently disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package ido-vertical-mode
    :disabled t
    :require ido
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))
#+END_SRC
** ido ubiquitous (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package ido-ubiquitous
       :require ido
       :disabled t
       :config 
       ;; This enables ido in all contexts where it could be useful, not just
       ;; for selecting buffer and file names
       (ido-ubiquitous-mode 1))   
   #+END_SRC
** flex ido (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
    (req-package flx-ido
      :require ido org
      :disabled t
      :config
    (flx-ido-mode 1)
    (ido-mode 1)
    (ido-everywhere 1)
    ;; disable ido faces to see flx highlights.
    (setq ido-enable-flex-matching t)
    (setq ido-use-faces nil)
    (setq org-completion-use-ido t))   
   #+END_SRC
* helm
** helm
#+BEGIN_SRC emacs-lisp
  (req-package async) ;; TODO: add all async requirements, otherwise this will not work
  (req-package popup)
  ;;(req-package helm-core
  ;;  :require async)
  (req-package helm
    :require
    async
    popup
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("s-f" . helm-for-files)
           ("C-x s-f" . helm-for-files)
           ("C-x C-b" . helm-buffers-list)
           ("C-s-i" . helm-semantic-or-imenu)
           ;; resume previous helm session whatever it was, with the selection that was active then
           ;; helm-resume
           )
    :init (progn
      ;; register new function
      (add-hook 'helm-minibuffer-set-up-hook
                'gb/helm-hide-minibuffer-maybe)
    )
    :config
    (progn
      ;; ignore files in boring file rexp list
      ;; make sure keyboard entry is displayed in header line of helm buffer
      (setq helm-echo-input-in-header-line t)

      ;; make sure that minibuffer stays untouched if entry is displayed in top of helm buffer
      (defun gb/helm-hide-minibuffer-maybe ()
        "Hide minibuffer in Helm session if we use the header line as input field."
        (when (with-helm-buffer helm-echo-input-in-header-line)
          (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
            (overlay-put ov 'window (selected-window))
            (overlay-put ov 'face
                         (let ((bg-color (face-background 'default nil)))
                           `(:background ,bg-color :foreground ,bg-color)))
            (setq-local cursor-type nil))))


      (helm-mode 1)
      (setq helm-display-function 'pop-to-buffer)
      (require 'helm-locate)
      (setq helm-locate-command "locate %s %s")
      (custom-set-faces
       '(match ((t (:background "#1d1f21" :foreground "DarkGoldenrod1" :inverse-video nil)))))
      (setq helm-split-window-default-side 'right)
      (setq helm-buffer-max-length nil)
      (setq helm-ff-skip-boring-files t)
      (require 'helm-files)
      (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/elpa/.*")
      (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/.*autoloads\.elc?$")
      (add-to-list 'helm-boring-file-regexp-list "TAGS$")
      (add-to-list 'helm-boring-file-regexp-list "ido\.last$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*cache\.elc?$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*bookmarks$")
      (add-to-list 'helm-boring-file-regexp-list "News/KILL$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/\.session$")
      (add-to-list 'helm-boring-file-regexp-list "\.newsrc$")
      (add-to-list 'helm-boring-file-regexp-list "\.newsrc\.eld$")
      (add-to-list 'helm-boring-file-regexp-list "\.elfeed/index$")
      (setq helm-M-x-always-save-history t)))
#+END_SRC
** helm cmd t
   #+begin_src emacs-lisp
     (req-package helm-cmd-t
       :bind (("s-r" . helm-cmd-t)
              ("s-t" . helm-cmd-t-repos))
       :config
       (setq helm-cmd-t-candidate-number-limit 60))
   #+end_src
** helm git grep
   #+begin_src emacs-lisp 
     (req-package helm-ls-git
       :require helm
       :bind (:map magit-mode-map
                   ("s-f" . helm-ls-git-ls)))
   #+end_src
   #+BEGIN_SRC emacs-lisp
     (req-package helm-git-grep 
       :require helm
       :bind (("C-c g" . helm-git-grep)
              :map isearch-mode-map
              ("C-c g" . helm-git-grep-from-isearch)
              :map helm-map
              ("C-c g" . helm-git-grep-from-helm))
       ;; :config
       ;; (bind-key "C-c g" 'helm-git-grep)       
       ;; ;; Invoke `helm-git-grep' from isearch.
       ;; (bind-key "C-c g" 'helm-git-grep-from-isearch isearch-mode-map)
       ;; ;; Invoke `helm-git-grep' from other helm.
       ;; (bind-key "C-c g" 'helm-git-grep-from-helm helm-map)
       )
   #+END_SRC
** helm projectile
#+BEGIN_SRC emacs-lisp
  (req-package helm-projectile
    :require helm projectile
    :config
    (helm-projectile-on)) ;; enable helm projectile key bindings, helm-projectile-off restores old keybindings
#+END_SRC
** sort helm with flex
   - helm candidates are sorted using flx (more fuzzy sorting)
 #+BEGIN_SRC emacs-lisp
   (req-package helm-flx
     :require helm
     :config
     (progn
       (helm-flx-mode +1)
       ;; optional fuzzy matching for helm-M-x
       (setq helm-M-x-fuzzy-match t) 

       (setq helm-bookmark-show-location t)
       (setq helm-completion-in-region-fuzzy-match t)
       (setq helm-file-cache-fuzzy-match t)
       (setq helm-mode-fuzzy-match t)
       ;; ---
       (setq helm-ff-fuzzy-matching t)
       ;; only possible in unix environments (adds -b to locate)
       ;; (setq helm-locate-fuzzy-match t)
       (setq helm-etags-fuzzy-match t)
       (setq helm-recentf-fuzzy-match t)
       (setq helm-imenu-fuzzy-match t)
       (setq helm-buffers-fuzzy-matching t)
       (setq helm-lisp-fuzzy-completion t)
       (setq helm-apropos-fuzzy-match t)
       (setq helm-company-fuzzy-match t)
       (setq helm-projectile-fuzzy-match t)
       (setq helm-locate-library-fuzzy-match t)))
 #+END_SRC
** helm extensions
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package helm-ext
     :require helm
     :config
     (progn
       (helm-ext-ff-enable-skipping-dots nil) ;; skip . and .. directory entries in non-empty directories :: nil because renaming from dired to other open dir would not work
       (helm-ext-ff-enable-zsh-path-expansion t) ;; allow for /h/q/f/b to expand to /home/qjp/foo/bar
       (helm-ext-ff-enable-auto-path-expansion t) ;; expansion is done during typing
       (helm-ext-minibuffer-enable-header-line-maybe t) ;; allow helm expansion in mini buffer (using header line to do so)
       ;; additional command ace-jump-helm-line
       ))
   #+END_SRC
* vagrant docker ansible
** docker
#+BEGIN_SRC emacs-lisp
  (req-package docker
    :commands docker-machines docker-volumes docker-images docker-containers
    :config
    (progn
      (setenv "DOCKER_TLS_VERIFY" "1")
      (setenv "DOCKER_HOST" "tcp://192.168.99.100:2376")
      (setenv "DOCKER_CERT_PATH" "~/.docker/machine/machines/docker-host-4gb-2cpu")
      (setenv "DOCKER_MACHINE_NAME" "docker-host-4gb-2cpu")))
  (req-package docker-tramp
    :require docker)
#+END_SRC
** vagrant
#+BEGIN_SRC emacs-lisp
  (req-package vagrant
    :commands vagrant-up vagrant-edit vagrant-status)
  (req-package vagrant-tramp
    :defer 20
    :require vagrant
    :commands vagrant-tramp-term)
#+END_SRC
** ansible
*** ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package ansible
        :defer 30
        :commands ansible)
    #+END_SRC
*** ansible-doc (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (req-package ansible-doc
      :defer 30
      :commands ansible-doc ansible-doc-mode)
    #+END_SRC
*** company-ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (req-package company-ansible
      :defer 30
      :require company)
    #+END_SRC
* imenu
  - display imenu in separate buffer (through 'M-x imenu-list-minor-mode')
  - https://github.com/bmag/imenu-list
  #+BEGIN_SRC emacs-lisp
    (req-package imenu-list)
    (req-package imenu+)
  #+END_SRC
* imenu-anywhere
  show ido/helm menu for all etags of currently open buffers
  the commands are
  - imenu-anyhwere
  - helm-imenu-anywhere
  #+BEGIN_SRC emacs-lisp
    (req-package imenu-anywhere
      :bind (("s-i" . helm-imenu-anywhere)
             ("s-I" . helm-imenu-anywhere)))
  #+END_SRC
* crux (disabled)
  - look at https://github.com/bbatsov/crux for additional functions that might be of interest
#+BEGIN_SRC emacs-lisp :tangle no
(req-package crux
   :disabled t
   :bind (("C-u s-f" . crux-recentf-ido-find-file)) ;; recent file selection with ido
)
#+END_SRC
* flycheck-tip
#+BEGIN_SRC emacs-lisp
  (req-package flycheck-tip)
#+END_SRC
* hydra
#+BEGIN_SRC emacs-lisp
  (req-package hydra
    :bind (
           ( "<f1>" . hydra-allhydras/body) ;; globally defined, can be locally redefined
           ( "<M-f1>" . hydra-allhydras/body) ;; always jump to the global hydra
           ;; make buffer specific f1 bindings
           ;; :map org-agenda-mode-map
           ;; ( "<f1>" . hydra-org-agenda-view/body )
           )
    :config



    ;;--------------------------------------------------------------------------------
    ;; (when (package-installed-p 'org)
    ;;   (defun org-agenda-cts ()
    ;;     (ignore-errors
    ;;       (let* ((args (get-text-property
    ;;                     (min (1- (point-max)) (point))
    ;;                     'org-last-args)))

    ;;         (nth 2 args))))

    ;;   ;; currently not functional (probably because of hydra update)
    ;;   (defhydra hydra-org-agenda-view ()
    ;;     "
    ;;         org agenda view
    ;;         ------------------------------------------------------
    ;;         _d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
    ;;         _w_: ?w? week       _[_: inactive      _A_: arch-files
    ;;         _t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
    ;;         _m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
    ;;         _y_: ?y? year       _q_: quit          _L__l__c_: ?l?

    ;;       %s(hydra-combine-functions-w-key-bindings
    ;;         '((\"  [d]   day      \" . org-agenda-day-view)
    ;;           (\"  [w]   week     \" . org-agenda-week-view)
    ;;           (\"  [t]   fortnight\" . org-agenda-fortnight-view)
    ;;           (\"  [m]   month    \" . org-agenda-month-view)
    ;;           (\"  [y]   year     \" . org-agenda-year-view)
    ;;           (\"  [lLc] log mode \" . org-agenda-log-mode)
    ;;           (\"  [f]   follow   \" . org-agenda-follow-mode)
    ;;           (\"  [aA]  archive  \" . org-agenda-archives-mode)
    ;;           (\"  [r]   report   \" . org-agenda-clockreport-mode)
    ;;           (\"  [e]   entry    \" . org-agenda-entry-text-mode)
    ;;           (\"  [g]   grid     \" . org-agenda-toggle-time-grid)
    ;;           (\"  [D]   diary    \" . org-agenda-toggle-diary)
    ;;           ))
    ;;       "
    ;;     ("SPC" org-agenda-reset-view)
    ;;     ("d" org-agenda-day-view
    ;;      (if (eq 'day (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("w" org-agenda-week-view
    ;;      (if (eq 'week (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("t" org-agenda-fortnight-view
    ;;      (if (eq 'fortnight (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("m" org-agenda-month-view
    ;;      (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("y" org-agenda-year-view
    ;;      (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("l" org-agenda-log-mode
    ;;      (format "% -3S" org-agenda-show-log))
    ;;     ("L" (org-agenda-log-mode '(4)))
    ;;     ("c" (org-agenda-log-mode 'clockcheck))
    ;;     ("f" org-agenda-follow-mode
    ;;      (format "% -3S" org-agenda-follow-mode))
    ;;     ("a" org-agenda-archives-mode)
    ;;     ("A" (org-agenda-archives-mode 'files))
    ;;     ("r" org-agenda-clockreport-mode
    ;;      (format "% -3S" org-agenda-clockreport-mode))
    ;;     ("e" org-agenda-entry-text-mode
    ;;      (format "% -3S" org-agenda-entry-text-mode))
    ;;     ("g" org-agenda-toggle-time-grid
    ;;      (format "% -3S" org-agenda-use-time-grid))
    ;;     ("D" org-agenda-toggle-diary
    ;;      (format "% -3S" org-agenda-include-diary))
    ;;     ("!" org-agenda-toggle-deadlines)
    ;;     ("["
    ;;      (let ((org-agenda-include-inactive-timestamps t))
    ;;        (org-agenda-check-type t 'timeline 'agenda)
    ;;        (org-agenda-redo)))
    ;;     ("q" (message "Abort") :exit t)))

    ;;--------------------------------------------------------------------------------
    (defhydra hydra-profiler ()
      "
          profiler
          ^-^-------------------^-^-----------------
          _s_: start profiler   _r_: profiler report
          _e_: end profiler
        "
      ("s" profiler-start :exit t)
      ("e" profiler-stop :exit t)
      ("r" profiler-report :exit t))

    ;;--------------------------------------------------------------------------------
    (when (package-installed-p 'dash) 
      (defhydra hydra-dash ()
        "
           dash
           ^-^---------------------^-^--------------------------
           _h_ helm dash at point  _d_ dash at point
           ^ ^                     _D_ dash at point with docset

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [h] helm dash at point     \" . helm-dash-at-point)
              (\"  [d] dash at point          \" . dash-at-point)
              (\"  [D] dash at point w/ docset\" . dash-at-point-with-docset)))
        "
        ("h" helm-dash-at-point :exit t)
        ("d" dash-at-point :exit t)
        ("D" dash-at-point-with-docset :exit t)
        ))

    ;;--------------------------------------------------------------------------------
    (when (package-installed-p 'avy-zap)
      (defhydra hydra-avy ()
        "
          avy
          ^-^-------------------^-^-----------------
          _z_: zap up to char        _c_: jump to word 
          _Z_: zap to including char _l_: jump to line
          ^ ^                        _i_: jump to char within line

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [z] zap up to char       \" . avy-zap-up-to-char)
              (\"  [Z] zap to including char\" . avy-zap-to-char-dwim)
              (\"  [c] jump to word         \" . avy-goto-word-1)
              (\"  [l] jump to line         \" . avy-goto-line)
              (\"  [i] jump to char w/i line\" . avy-goto-char-in-line)))
        "
        ("c" avy-goto-word-1 :exit t)
        ("z" avy-zap-to-char :exit t)
        ("Z" avy-zap-to-char-dwim :exit t)
        ("l" avy-goto-line :exit t)
        ("i" avy-goto-char-in-line :exit t))) 

  (defhydra hydra-ui-info ()
       "
         ui-info
         -----------------------------
         _=_: what cursor position (C-u for font information)

         %s(hydra-combine-functions-w-key-bindings
            '((\" [=] what cursor position \" . what-cursor-position))))

       "
       ("=" what-cursor-position :exit t))

    ;;--------------------------------------------------------------------------------
    ;; TODO: install only those hydras that are actually defined
    (defhydra hydra-allhydras ()
      "
          list of all hydras
          ^--^------------------------^-^---------------
          _cr_: clojure refactoring   _m_ : multi cursor
          _n_ : navigate              _gm_: gnus mime
          _oa_: org agenda view       _gs_: gnus summary
          _om_: org mode              _gg_: gnus group
          _pp_: emacs profiler        _a_ : avy
          _i_ : ivy                   _d_ : dash
          _u_ : ui info
          ^ ^                         _q_ : quit
        "
      ("a" hydra-avy/body :exit t)
      ("cr" hydra-all-clojure-refactorings/body :exit t)
      ("m" hydra-multiple-cursors/body :exit t)
      ("n"  hydra-navigate-history/body :exit t)
      ("gs"  hydra-gnus-summary/body :exit t)
      ("gm" hydra-gnus-article-mime-part/body :exit t)
      ("gg" hydra-gnus-group/body :exit t)
      ("oa" hydra-org-agenda-view/body :exit t)
      ("om" hydra-org-mode/body :exit t)
      ("pp" hydra-profiler/body :exit t)
      ("i" hydra-ivy/body :exit t)
      ("d" hydra-dash/body :exit t)
      ("u" hydra-ui-info/body :exit t)
      ("q" (message "Abort") :exit t))

    )  
#+END_SRC
* TEST clear-text (mode that makes you use only the 1000 most common english words)
#+BEGIN_SRC emacs-lisp
  (req-package clear-text
    :commands clear-text-mode)
#+END_SRC
* guide keys (disabled)
** alternative to which-key
*** can be tuned to react to certain prefixes only
*** can be tuned to highlight displayed shortcuts based on regular expressions
*** [[https://github.com/kai2nenobu/guide-key]]
#+BEGIN_SRC emacs-lisp :tangle no
(req-package guide-key
  :disabled t
  :init
  (setq guide-key/guide-key-sequence '("C-c C-x"))
  (guide-key-mode 1))
(req-package guide-key-tip
  :disabled t
  :require guide-key)
#+END_SRC
* gnuplot
** major mode to edit .gp files and drive gnuplot directly from there
#+BEGIN_SRC emacs-lisp
  (req-package gnuplot
    :mode ( "\\.gp\\'" . gnuplot-mode)
    :commands gnuplot-mode
    :config
    (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
    (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot-mode" t))
#+END_SRC
** alternative (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package gnuplot-mode
    :disabled t)
#+END_SRC
* graphviz dot
#+BEGIN_SRC emacs-lisp
  (req-package graphviz-dot-mode
    :commands graphviz-dot-mode
    
    :config
    (setq graphviz-dot-view-command "xdot %s"))
#+END_SRC
* backup
** backup edited files
   #+BEGIN_SRC emacs-lisp
     ;; Write backup files to own directory
     (setq backup-directory-alist `(("." . ,(expand-file-name "~/file-backups")))
           backup-by-copying t
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC
** backup with version control and helm
  all files saved are automatically backed up using git.
  with M-x helm-backup while within the open file, old
  versions can be ediffed with the current
#+BEGIN_SRC emacs-lisp
  (req-package helm-backup
    :defer 10
    :init
    (add-hook 'after-save-hook 'helm-backup-versioning))
#+END_SRC
* latex (auctex)
** auctex
   #+BEGIN_SRC emacs-lisp
     (req-package tex-mode
       :require flymake
       :init (progn
         ;; latex, activate flyspell
         (add-hook 'TeX-mode-hook (lambda () (progn (flyspell-mode 1))))

         ;; activate auto fill mode
         (add-hook 'TeX-mode-hook #'gb/enable-auto-fill-mode)

         ;; make sure that flymake works with latex installation on mac
         (defun flymake-get-tex-args (file-name)
           (list "pdflatex" (list "-file-line-error" "-draftmode" "-interaction=nonstopmode" file-name)))
         (add-hook 'TeX-mode-hook (lambda () (flymake-mode 1)))       )
       :config
       (progn
         (setq TeX-auto-save t)
         (setq TeX-parse-self t)
         (setq TeX-save-query nil)

         (global-prettify-symbols-mode)

         ))
   #+END_SRC
** company for auctex
   - see [[https://github.com/alexeyr/company-auctex/][here]]
   - adds company backend for latex proposals
   #+BEGIN_SRC emacs-lisp
     (req-package company-auctex
       :require tex-mode company yasnippet
       :config (company-auctex-init))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (req-package company-math
       
       :require company tex-mode
       :init (add-hook 'TeX-mode-hook 'gb/latex-mode-setup)
       :config
       ;; local configuration for TeX modes
       (defun gb/latex-mode-setup ()
         (setq-local company-backends
                     (append '((company-math-symbols-latex company-latex-commands))
                             company-backends)))

       )
   #+END_SRC
** bibtex
   - check https://nickhigham.wordpress.com/2016/01/06/managing-bibtex-files-with-emacs/
   #+BEGIN_SRC emacs-lisp
     (req-package parsebib)
     (req-package let-alist)
     (req-package biblio-core
       :require let-alist seq dash)
     (req-package biblio
       :require biblio-core)
     (req-package helm-bibtex
       :require helm parsebib dash biblio)
   #+END_SRC
** latex extra
   - see [[https://github.com/Malabarba/latex-extra][here]]
   - add some extra navigation (C-c C-n/p next/previous, a/e beginning/end, f/b same level forward/back, u up one level)
   - content folding (tab)
   - white space handling (C-c C-q : fill paragraph similar to M-q)
  #+BEGIN_SRC emacs-lisp
    (req-package latex-extra
      :require tex-mode
      :init (add-hook 'LaTeX-mode-hook #'latex-extra-mode))
  #+END_SRC
** do previewing with "M-x latex-preview-pane-mode"
   updates preview on every save
   disable by calling the same command again
  #+BEGIN_SRC emacs-lisp
    (req-package latex-preview-pane
      :require tex-mode
      :commands latex-preview-pane-mode
      :config
      (progn
        ;; (require 'pdf-tools)
        (latex-preview-pane-enable)
        (require 'latex-preview-pane)
        ;;    NOTES: adjustments had to be made so that preview works with pdf-tools:
        (defun latex-preview-pane-update-p () 
          (if (eq (lpp/invoke-pdf-latex-command) 1)
              (progn
                (lpp/display-backtrace)
                (remove-overlays)
                (lpp/line-errors-to-layovers (lpp/line-errors))
                )
        
            (let ((pdf-filename (replace-regexp-in-string "\.tex$" ".pdf" (lpp/buffer-file-name)))
                  (tex-buff (current-buffer))
                  (pdf-buff (replace-regexp-in-string "\.tex" ".pdf" (buffer-name (get-file-buffer (lpp/buffer-file-name))))))
              (remove-overlays)
              ;; if the file doesn't exist, say that the file isn't available due to error messages
              (if (file-exists-p pdf-filename)
                  (if (eq (get-buffer pdf-buff) nil)
                      (set-window-buffer (lpp/window-containing-preview) (find-file-noselect pdf-filename))
                    (progn 
                      (set-window-buffer (lpp/window-containing-preview) pdf-buff) 
                      (switch-to-buffer-other-window pdf-buff)
                      (doc-view-revert-buffer nil t)
                      (revert-buffer :NOCONFIRM t) ;; gb 20161117: added such that pdf-tools work, too!
                      (switch-to-buffer-other-window tex-buff) 
                      ))
            
                ))))
        ))
  #+END_SRC
* bookmark+
   #+BEGIN_SRC emacs-lisp
     ;; adds lots of functions all starting with bmkp
     (req-package bookmark+)
   #+END_SRC
* dired
** configuration
   #+BEGIN_SRC emacs-lisp
     (req-package dired
       :commands dired
       :bind (("C-x d" . dired)
              :map dired-mode-map
              ("e" . gb/dired-ediff-files))
       :init
         (add-hook 'dired-mode-hook 'auto-revert-mode)
       :config
     (setq dired-dwim-target t) ;; try to guess the directory to use for dired
     (setq dired-listing-switches "-Alh") ;; default switches for ls to be used for dired listing
     (setq diredp-hide-details-propagate-flag t) ;; opening subfolders inherit details flag (shown/hidden)
     (if gnu-ls-installed
       (setq insert-directory-program gnu-ls-bin-path))

     ;; snippet from https://oremacs.com/2017/03/18/dired-ediff/
     (defun gb/dired-ediff-files ()
       "ediff two marked files (no questions asked)"
       (interactive)
       (let ((files (dired-get-marked-files))
             (wnd (current-window-configuration)))
         (if (<= (length files) 2)
             (let ((file1 (car files))
                   (file2 (if (cdr files)
                              (cadr files)
                            (read-file-name
                             "file: "
                             (dired-dwim-target-directory)))))
               (if (file-newer-than-file-p file1 file2)
                   (ediff-files file2 file1)
                 (ediff-files file1 file2))
               (add-hook 'ediff-after-quit-hook-internal
                         (lambda ()
                           (setq ediff-after-quit-hook-internal nil)
                           (set-window-configuration wnd))))
           (error "no more than 2 files should be marked")))))
   #+END_SRC
** dired ls (lisp emulation)
   #+BEGIN_SRC emacs-lisp
     ;; useful in environments where ls is not a native program (e.g. windows)
     ;; allows usage of dired and ls switches
     (unless gnu-ls-installed
       (req-package ls-lisp
         :config
         (progn
           (setq ls-lisp-use-insert-directory-program nil)
           (setq ls-lisp-ignore-case 't))))
   #+END_SRC
** dired quick sort
   #+BEGIN_SRC emacs-lisp
   (when gnu-ls-installed
     (req-package dired-quick-sort
       :require dired hydra
       :config
       (dired-quick-sort-setup)))
   #+END_SRC
** dired sort
   #+BEGIN_SRC emacs-lisp
     ;; popup dialog from dired buffer to set (sort) switches of ls command
     (req-package dired-sort-menu
       :require dired ls-lisp
       :commands dired-sort-dialog)
   #+END_SRC
** dired+
   #+BEGIN_SRC emacs-lisp
  ;; adds lots of functions all starting with diredp-
  (req-package dired+)
   #+END_SRC
** dired rainbow
   #+BEGIN_SRC emacs-lisp
     (req-package dired-rainbow
       :require dired) ;; Extended file highlighting according to its type 
   #+END_SRC
** dired subtree
   #+BEGIN_SRC emacs-lisp
     (req-package dired-subtree
       :require dired
       :bind (:map dired-mode-map
              ("TAB" . dired-subtree-toggle)
              ("[" . dired-subtree-up))
       :commands dired-subtree-toggle) ;; toggle subtree open/close M-x dired-subtree-toggle
   #+END_SRC
* stripe-buffer
  add stripes to background of dired (or any other mode)
  #+BEGIN_SRC emacs-lisp
    (req-package stripe-buffer
      :init (progn
      (add-hook 'dired-mode-hook 'turn-on-stripe-buffer-mode)
      ;; (add-hook 'dired-mode-hook 'stripe-listify-buffer)
      )
      :config
      (custom-set-faces
       '(stripe-highlight ((t (:background "gray15")))))
      )
  #+END_SRC
* figlet (text->ascii art)
  - 'M-x figlet' to enter a text that is transformed into asci art
  - C-u will allow the selection of the font additionally
  #+BEGIN_SRC emacs-lisp
  (req-package figlet
    :commands figlet)
  #+END_SRC
* suggest
  execute "M-x suggest" opens suggest mode
  define input, expected output and it will provide an emacs-lisp function that does exactly that
  (e.g. input = "Hello", output = "hello", result = (downcase "Hello") ;=> "hello")
  #+BEGIN_SRC emacs-lisp
    (req-package suggest
      :commands suggest)
  #+END_SRC
* visual regexp
  #+BEGIN_SRC emacs-lisp
    (req-package visual-regexp)
    (req-package visual-regexp-steroids
      :require visual-regexp
      :config
      (progn 
        ;; bind key is used within config section, since vr/... are functions of visual-regexp which
        ;; are adviced by visual-regexp-steroids. If used within :bind-key, this package is not loaded!!
        (bind-key "M-%" #' vr/query-replace)
        ;; ("C-c r" . vr/replace)
        ;; ("C-r" . vr/isearch-backward)
        ;; ("C-s" . vr/isearch-forward)
        (bind-key "C-c m" #'vr/mc-mark)
        (setq vr/default-regexp-modifiers (quote (:I t :M t :S nil :U nil)))))
  #+END_SRC
* language server protocol mode
  #+BEGIN_SRC emacs-lisp
  (req-package lsp-mode
    :commands lsp-mode)
  #+END_SRC
* exwm (emacs window manager)
  - C-c C-q <next key>: results in next key being send to the x-application unmodified
  - [[https://github.com/ch11ng/exwm/wiki/Configuration-example][example configuration]]
  #+BEGIN_SRC emacs-lisp
    (when (string= "ok" (s-trim (shell-command-to-string "cat ~/.xinitrc | grep -q -e '^exec .*emacs' && echo 'ok'")))
      (req-package exwm)
      (req-package exwm-config
        :require exwm
        :config
        (exwm-config-default)

        (if (shell-command-to-string "ps -A | grep VBoxClient")
            (message "OK: VBoxClient seems to be running, thus clipboard sharing is probably active")
          (message "ERROR: VBoxClient is not running! Clipboard sharing is not available"))

        (defun gb/start-if-not-running (filename)
          "start this program if not already running"
          (let* ((program (file-name-base filename))
                 (is-executable (file-executable-p filename))
                 (is-running (not (string-empty-p (shell-command-to-string (concat "ps -A | grep " program))))))
            (cond ((and is-executable is-running) (message (format "OK: %s already running." program)))
                  (is-executable (progn (message (format "OK: starting %s." program))
                                        (start-process-shell-command filename nil)))
                  (t (message (format "WARNING: program %s could not be run." filename))))
            ))

        ;; make sure multi monitor support is active
        ;; TODO run xrandr to check whether multiple monitors are active
        (when (string= "2" (s-trim (shell-command-to-string "xrandr --listmonitors | grep \"Monitors\" | awk '{ print $2; }'")))
          (progn
            (message "Starting multimonitor support for exwm.")
            (require 'exwm-randr)
            (setq exwm-randr-workspace-output-plist '(0 "VGA-1" 1 "VGA-2"))
            (add-hook 'exwm-randr-screen-change-hook
                      (lambda ()
                        (start-process-shell-command
                         "xrandr" nil "xrandr --output VGA-2 --left-of VGA-1 --auto")))
            (exwm-randr-enable)))

        ;; The following example demonstrates how to set a key binding only available
        ;; in line mode. It's simply done by first push the prefix key to
        ;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
        ;; The example shorten 'C-c q' to 'C-q'.
        (push ?\C-q exwm-input-prefix-keys)
        (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

        (exwm-input-set-simulation-keys
         '(
           ;; movement
           ([?\C-b] . left)
           ([?\M-b] . C-left)
           ([?\C-f] . right)
           ([?\M-f] . C-right)
           ([?\C-p] . up)
           ([?\C-n] . down)
           ([?\C-a] . home)
           ([?\C-e] . end)
           ([?\M-v] . prior)
           ([?\C-v] . next)
           ([?\C-d] . delete)
           ([?\C-k] . (S-end delete))
           ;; cut/paste.
           ([?\C-w] . ?\C-x)
           ([?\M-w] . ?\C-c)
           ([?\C-y] . ?\C-v)
           ;; other
           ([?\C-g] . escape)
           ;; search
           ([?\C-s] . ?\C-f)))

        ;; enable system tray which is displayed in the message area all the way to the right
        (require 'exwm-systemtray)
        (exwm-systemtray-enable)

        ;; somehow the switch of workspace fails if some graphic program (like eclipse or chromium) is running
        ;; this does not fix the problem, though

        ;; start pasystray from within emacs, starting it within xinitrc does not work
        (add-hook 'exwm-init-hook
                  (lambda () (gb/start-if-not-running "/usr/bin/pasystray")))

        ;; make sure the buffer is named after the program that is run
        ;; (add-hook 'exwm-update-class-hook
        ;;           (lambda ()
        ;;             (exwm-workspace-rename-buffer exwm-class-name)))

        ;; ensure that eclipse does not use simulation keys, since i have emacs binding enabled in eclipse
        ;; (add-hook 'exwm-manage-finish-hook
        ;;           (lambda ()
        ;;             (when (and exwm-class-name
        ;;                        (or ;; (string= exwm-class-name "Chromium")
        ;;                         (string= (downcase exwm-class-name) "eclipse")
        ;;                         ))
        ;;               (progn
        ;;                 ;; (setq-local exwm-input-prefix-keys '(?\C-l))
        ;;                 (exwm-input-set-local-simulation-keys nil)))))
        ))
  #+END_SRC
* currently evaluated
** eshell auto suggestion
   #+BEGIN_SRC emacs-lisp
   (req-package esh-autosuggest
     :require company)
   #+END_SRC
** dimmer
   - dim non selected buffers (slightly)
   #+BEGIN_SRC emacs-lisp
   (req-package dimmer
     :config (dimmer-activate))
   #+END_SRC
** eldoc-olverlay
   - display eldoc as inline overlay
   - switch on per mode via `M-x eldoc-overlay-mode`
   #+BEGIN_SRC emacs-lisp
   (req-package eldoc-overlay)
   #+END_SRC
** eterm-256color
   - see [[http://github.com/dieggsy/eterm-256color][here]]
   #+BEGIN_SRC emacs-lisp
   (req-package eterm-256color
     :init (add-hook 'term-mode-hook #'eterm-256color-mode))
   #+END_SRC
** pcre2el (replace regular expression syntax with more readable one)
   - see here
   #+BEGIN_SRC emacs-lisp
   (req-package pcre2el
     :config (pcre-mode 1))
   #+END_SRC
** helm-exwm (allow for helm based change of exwm buffers)
   - see [[https://github.com/emacs-helm/helm-exwm][here]]
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package helm-exwm
     :require exwm)
   #+END_SRC
** indent-info (deactivated)
   - allows for display of current indent settings in the mode line
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package indent-info
     :config (global-indent-info-mode 1))
   #+END_SRC
** company lsp
   #+BEGIN_SRC emacs-lisp
   (req-package company-lsp
     :require company lsp-mode
     :config (push 'company-lsp company-backends))
   #+END_SRC
** iy-goto-char
   - C-c f <char> : goto the next occurrance of <char>. <char> can then be repeatedly pressed to move on to the next after that
     #+BEGIN_SRC emacs-lisp
       (req-package iy-go-to-char
         :bind (("C-c f" . iy-go-to-char)
                ("C-c F" . iy-go-to-char-backward))
         )
     #+END_SRC
** helpful
   - allow for additional help information for functions
   #+BEGIN_SRC emacs-lisp
     (req-package helpful
       :commands (helpful-macro helpful-function helpful-command helpful-variable helpful-at-point)
       :bind ("s-h" . helpful-at-point))
   #+END_SRC
** edit-at-point
   - edit(copy,cut..) current things(word,symbol..) under cursor
   #+BEGIN_SRC emacs-lisp
   (req-package edit-at-point)
   #+END_SRC
** eno, ace like copy, cut, past and move
   #+BEGIN_SRC emacs-lisp
     (req-package eno
       :require dash edit-at-point
       :bind
         (("M-s-w j" . eno-word-goto) ;; Meta super w as leader key
          ("M-s-w c" . eno-word-copy)
          ("M-s-w t" . eno-word-cut)
          ("M-s-w p" . eno-word-paste)
          ("M-s-b j" . eno-symbol-goto)
          ("M-s-b c" . eno-symbol-copy)
          ("M-s-b t" . eno-symbol-cut)
          ("M-s-b p" . eno-symbol-paste)
          ("M-s-s j" . eno-str-goto)
          ("M-s-s c" . eno-str-copy)
          ("M-s-s t" . eno-str-cut)
          ("M-s-s p" . eno-str-paste)
          ("M-s-l j" . eno-line-goto)
          ("M-s-l c" . eno-line-copy)
          ("M-s-l t" . eno-line-cut)
          ("M-s-l p" . eno-line-paste)
          ("M-s-p j" . eno-paren-goto)
          ("M-s-p c" . eno-paren-copy)
          ("M-s-p t" . eno-paren-cut)
          ("M-s-p p" . eno-paren-paste)))
   #+END_SRC
** flycheck inline
   - display flycheck error messages inline (not as popup)
   - check whether this clashes with other flycheck packages (like flycheck-tip and flycheck-pos-tip)
   #+BEGIN_SRC emacs-lisp
     (req-package flycheck-inline
       :require flycheck
       :init (progn
       (add-hook 'text-mode-hook #'flycheck-inline-enable)
       (add-hook 'prog-mode-hook #'flycheck-inline-enable)
       )
       :config
       ;; (flycheck-inline-mode 1) ;; see readme
       )
   #+END_SRC
** flymd
   - opens firefox to display a live view of the markdown in the buffer.
     saving the buffer does automatically update the browser view of it!
   #+BEGIN_SRC emacs-lisp
     (if chromium-installed
         (req-package flymd
           :commands flymd-flyit
           :config
           ((progn )
            ;; make (setq  )ure firefox is opened, since flymd-flyit does not work with chrome!
            (defun gb/flymd-browser-function (url)
              (let ((browse-url-browser-function 'browse-url-firefox))
                (browse-url url)))
            (setq flymd-browser-(or  )pen-function 'gb/flymd-browser-function))))
   #+END_SRC
** pixel-scroll (pixel wise scrolling) currently disabled
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; currently on the load path by .emacs.d/additionals
     (if (not  (file-exists-p "~/.emacs.d/additionals/pixel-scroll.el"))
         (message "WARNING: pixel-scroll.el does not exist, it will not be installed")
       (progn
         (message "OK: pixel-scroll.el locally found, will be installed")
         (req-package pixel-scroll
           :load-path "~/.emacs.d/additionals/"
           :require sublimity-scroll
           :config
           (progn
             (require 'sublimity-scroll)
             ;; redefine pre command for speed up of n no pre commands are present
             (defun sublimity--pre-command ()
               (save-excursion (goto-char (window-start)) (setq sublimity--prev-lin (string-to-number (format-mode-line "%l"))))
               (setq
                     sublimity--prev-col (window-hscroll)
                     sublimity--prev-buf (current-buffer)
                     sublimity--prev-wnd (selected-window)
                     sublimity--prepared t)
               (sublimity--run-hooks sublimity--pre-command-functions))
             (setq gb/modeline-enabled t)
             (defun gb/modeline ()
               ""
               (if gb/modeline-enabled
                   (spaceline-ml-main)))
             (defun sublimity-scroll--vscroll-effect (lins)
               (save-excursion
                 (let* ((pixel-scroll-last-line (and (not (equal major-mode 'org-mode)) (> (abs lins) 5)))
                        (speeds (sublimity-scroll--gen-speeds (if pixel-scroll-last-line (* (signum lins) (- (abs lins) 1)) lins)))
                        (cursor-type (and (not sublimity-scroll-hide-cursor) cursor-type)))
                   ;; (message (concat "scroll: " (number-to-string lins) ", at: " (number-to-string (nlinum--line-number-at-pos))))
                   ;; (message pixel-scroll-last-line)
                   (sublimity-scroll--vscroll (- lins))
                   (setq gb/modeline-enabled nil)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (gb/modeline)))))
                   (dolist (speed speeds)
                     (progn
                       (sublimity-scroll--vscroll speed)
                       (force-window-update (selected-window))
                       (redisplay)))
                   (setq gb/modeline-enabled t)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (spaceline-ml-main)))))
                   (if  (and (> lins 0) pixel-scroll-last-line)
                       (progn (pixel-scroll-up 1)))
                   (if (and (< lins 0) pixel-scroll-last-line)
                       (pixel-scroll-down 1))
                   )))))))
   #+END_SRC
** helm google
   #+BEGIN_SRC emacs-lisp
   (req-package helm-google
     :commands helm-google helm-google-suggest
     :require helm) ;; quick google searches, really ?
   #+END_SRC
** ivy swiper hydra
   #+BEGIN_SRC emacs-lisp
   (req-package ivy-hydra
     :require hydra ivy) ;; adds an hydra for ivy/swiper TODO: include into own hydras
   #+END_SRC
** ripgrep over directory trees
   #+BEGIN_SRC emacs-lisp
   (req-package ripgrep
     :commands ripgrep-regexp) ;; allow M-x ripgrep-regexp (search in directory + subdirectories)
   #+END_SRC
** elisp refs (find references to elisp functions....)
   #+BEGIN_SRC emacs-lisp
   (req-package elisp-refs) ;; allow M-x elisp-refs-...
   #+END_SRC
** company bib tex
   #+BEGIN_SRC emacs-lisp
   (req-package company-bibtex
     :require company tex-mode) ;; add bibtex references using company
   #+END_SRC
** cider stuff
   #+BEGIN_SRC emacs-lisp
   ;; C-c C-t (hydra for test in cider)
   ;; C-c M-r (hydra for repl)
   ;; C-c M-t (test)
   ;; C-c C-d (hydra for documentation)
   (req-package cider-hydra ;; adds hydras
     :require hydra cider)
   (req-package cider-decompile ;; decompilation extension for cider [https://github.com/clojure-emacs/cider-decompile]
     :defer 5
     :require cider javap-mode)
   (req-package cider-profile ;; CIDER profiling support [https://github.com/thunknyc/nrepl-profile]
     :defer 10
     :require cider
     :init
     (progn
       (add-hook 'cider-mode-hook 'cider-profile-mode)
       (add-hook 'cider-repl-mode-hook 'cider-profile-mode)))
   ;; adds bookmarking functionality (that is used by dired+, too)
   #+END_SRC
** window / frame tiling
   #+BEGIN_SRC emacs-lisp
   (req-package tile
     :commands tile tile-select tile-frames-horizontal tile-frames-vertically tile-frames-top-to-bottom tile-frames-side-by-side) ;; see [https://github.com/IvanMalison/tile], tiles windows into predefined setups
   #+END_SRC
** bug hunter
   #+BEGIN_SRC emacs-lisp
   (req-package bug-hunter ;; allows via commands to hunt bugs in emacs lisp files see https://github.com/Malabarba/elisp-bug-hunter

     :commands bug-hunter-file bug-hunter-init-file)

   #+END_SRC
** flycheck scala (deactivated, ensime provides all functionality needed here)
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; install flycheck for scala
   (req-package flycheck-scala-sbt
     :require ensime flycheck
     :defer t
     :init
     (progn
       (add-hook 'scala-mode-hook 'flycheck-scala-sbt-init)))

   ;; allow detection of language
   #+END_SRC
** natural language detection
   #+BEGIN_SRC emacs-lisp
   (req-package language-detection
     :commands language-detection-buffer)
   #+END_SRC
** butler (jenkins interface for emacs)
   #+BEGIN_SRC emacs-lisp
     (req-package butler
       :commands butler-status
       :config
       (progn
         ;; add server to the list
         ;; (add-to-list 'butler-server-list
         ;;          '(jenkins "SERVER-NAME"
         ;;                    (server-address . "https://jenkins-address")
         ;;                    (server-user . "user")
         ;;                    (server-password . "pass")))

         ;; add server with authfile
         ;; (add-to-list 'butler-server-list
         ;;              '(jenkins "SERVER-NAME"
         ;;                        (server-address . "https://jenkins-addres")
         ;;                        (auth-file . "~/.authinfo.gpg")))
         ;; The following line should exist in ~/.authinfo.gpg:
         ;; machine SERVER-NAME login USERNAME password PASSWORD
         ))
   #+END_SRC
** mode for unix tool pass
   #+BEGIN_SRC emacs-lisp
   (req-package passmm
     :commands passmm-list-passwords)
   #+END_SRC
** wolfram (currently disabled)
   - check [[https://github.com/hsjunnesson/wolfram.el][link]]
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package wolfram)
   #+END_SRC
** yaml
   #+BEGIN_SRC emacs-lisp
   (req-package yaml-mode
     :mode (("\\.yml\\'" . yaml-mode)
            ("\\.yaml\\'" . yaml-mode)))
   (req-package yaml-tomato
     :require yaml-mode
     :commands (yaml-tomato-show-current-path yaml-tomato-copy))
   #+END_SRC
** agda (deactivated)
   - 'agda-mode locate' will provide the path to agda.el which in turn holds all code to actually implement the agda mode.
   - this will however not readly integrate smoothly with req-package but is alright for the time being I guess.
   #+BEGIN_SRC emacs-lisp :tangle no
     (load-file (let ((coding-system-for-read 'utf-8))
                     (shell-command-to-string "agda-mode locate")))
   #+END_SRC
** historian
   #+BEGIN_SRC emacs-lisp
   (req-package historian)
   #+END_SRC
** org-brain
   organize org files within org-brain-path into somthing like a mindmap / wiki that can be browsed
   check the [[https://github.com/Kungsgeten/org-brain][home page]]
   #+BEGIN_SRC emacs-lisp
     (req-package org-brain
       :require org dash helm-org-rifle
       :commands org-brain-open org-brain-visualize org-brain-insert-link
       :config
       (progn
         (setq org-brain-path "~/brain")
         (if (not (file-exists-p org-brain-path))
             (make-directory org-brain-path t))
         (defun helm-org-rifle-brain ()
           "Rifle files in `org-brain-path'."
           (interactive)
           (helm-org-rifle-directories (list org-brain-path)))))
   #+END_SRC
** org edit latex (edit latex code in separate buffer)
   - see [[https://github.com/et2010/org-edit-latex][here]]
   #+BEGIN_SRC emacs-lisp
   (req-package org-edit-latex
     :require org tex-mode
     :defer 60)
   #+END_SRC
** helm books
   - allows searching for book titles using the google book api with helm
   #+BEGIN_SRC emacs-lisp
   (req-package helm-books
     :commands helm-books)
   #+END_SRC
** symbol-overlay
   - see [[https://github.com/wolray/symbol-overlay/][here]]
   - add some keylinks
   - allow highlighting of symbols
   #+BEGIN_SRC emacs-lisp
   (req-package symbol-overlay
     :config (setq symbol-overlay-colors '("dodger blue" "spring green" "orchid" "salmon")))
   #+END_SRC
** smart hungry delete
   - possible replacement for hungry-delete
   - do smart delete of spaces
   #+BEGIN_SRC emacs-lisp
     (req-package smart-hungry-delete
       :bind (("S-<backspace>" . smart-hungry-delete-backward-char)
   		      ("C-S-d" . smart-hungry-delete-forward-char)))
   #+END_SRC
** org recent headings
   - keep a list of lru org headings to choose from
   #+BEGIN_SRC emacs-lisp
     (req-package org-recent-headings
       :require org
       :bind (("M-s-^" . org-recent-headings-helm)) ;; equivalent to M-s-i
       :config
       (progn
         (org-recent-headings-mode)))
   #+END_SRC
** org sticky headers
   - keep last header of org in head line displayed if other wise scrolling out of view
   - problematic, sometimes org-sticky-header is empty
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package org-sticky-header
     :require org)
   #+END_SRC
** lsp with source-graph language servers
   #+BEGIN_SRC emacs-lisp
   ;; (req-package lsp-go :require lsp-mode)
   ;; (req-package lsp-haskell :require lsp-mode)
   (req-package lsp-java
     :defer 10
     :require lsp-mode)
   ;; (req-package lsp-python :require lsp-mode)
   ;; (req-package lsp-rust :require lsp-mode)
   #+END_SRC
** ledger (accounting manager)
   #+BEGIN_SRC emacs-lisp
     (when ledger-installed
       (req-package ledger-mode
         :defer 60)
       (req-package flycheck-ledger
         :defer 60
         :require ledger-mode flycheck))
   #+END_SRC
** move frames around
   #+BEGIN_SRC emacs-lisp
     (defun move-frame-right-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame))))
                  (maxx (-  (display-pixel-width) 800)))
              (set-frame-position (selected-frame) (min (+ xpos 800) maxx) ypos)))

     (defun move-frame-left-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame)))))
              (set-frame-position (selected-frame) (max (- xpos 800) 0) ypos)))
   #+END_SRC
** json-navigator
   #+BEGIN_SRC emacs-lisp
   (req-package json-navigator)
   #+END_SRC
** dired-collapse
   - collapse empty directories (like src/main/java... is done by github)
   #+BEGIN_SRC emacs-lisp
   (req-package dired-collapse
     :commands dired-collapse-mode)
   #+END_SRC
** org-pomodoro (time management technique)
   #+BEGIN_SRC emacs-lisp
     (req-package org-pomodoro
       :require appt
       :commands org-pomodoro-clock-in
       :init (add-hook 'org-pomodoro-finished-hook 'gb/pomodoro-finished-notification)
       :config
       (progn
         (defun notify-osx (title message)
           (call-process "terminal-notifier"
                         nil 0 nil
                         "-group" "Emacs"
                         "-title" title
                         "-sender" "org.gnu.Emacs"
                         "-message" message))
         (defun gb/pomodoro-finished-notification ()
           "notify user about finished pomodoro"
           (if (is-macos-p)
               (notify-osx "Pomodoro completed" "Time for a short break")
             (message "Pomodoro completed, time for a short break") ;; notification for unix missing
             ))
         (setq org-pomodoro-play-sounds nil)
         ))
   #+END_SRC
** comint (shell extensions)
   - see [[https://github.com/riscy/shx-for-emacs/blob/master/README.org][homepage]]
   - e.g. additional highlighting
   - given on the home page:
     - Display graphics and plots in the shell with a simple markup language (e.g., <view image.png>)
     - Add event-driven and timed behaviors to any shell session
     - Open any filename or URL by arrowing up to it and pressing <enter>
     - Yank any line to the prompt by arrowing up to it and pressing C-<enter>
     - Check the time a command was run by mousing over its prompt
   #+BEGIN_SRC emacs-lisp
   (req-package shx
     :init (progn
        ;; add hook for shell
        (add-hook 'shell-mode-hook #'shx-mode)
     )
     :config
        ;;(shx-global-mode 1) ;; global shx mode resulted in "text read only" error in ielm when pressing return
     )
   #+END_SRC
** ob-rust
   #+BEGIN_SRC emacs-lisp
   (req-package ob-rust
     :require org)
   #+END_SRC
** underline with char
   - call with prefix command let's you select with which char to underline
   - underlines previous line up to its end with '-'
   #+BEGIN_SRC emacs-lisp
     (req-package underline-with-char
       :commands underline-with-char)
   #+END_SRC
** yarn mode
   - open yarn lock files in a read only mode
   #+BEGIN_SRC emacs-lisp
   (req-package yarn-mode
     :mode (("\\yarn.lock\\'" . yarn-mode)))
   #+END_SRC
** all the icons dired
   #+BEGIN_SRC emacs-lisp
     (req-package all-the-icons-dired
       :require all-the-icons dired)
   #+END_SRC
** all the icons gnus
   - on hold, icons disturb custom ui settings of gnu
   - [ ] test this package with gnus ui customizations off
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package all-the-icons-gnus
     :require gnus all-the-icons dash
     :config (all-the-icons-gnus-setup))
   #+END_SRC
** docker compose mode
   #+BEGIN_SRC emacs-lisp
   (req-package docker-compose-mode
     )
   #+END_SRC
** comint (bifocal)
   - will automatically split a comint buffer, if scrolling into the history (by bifocal-up, down, next, prev)
     this will enable you to view current comint output (or just keep the input line) while looking at the history of the buffer
   #+BEGIN_SRC emacs-lisp
   (req-package bifocal
     :commands bifocal-mode)
   #+END_SRC
** popwin (make windows like help, completion show in a popupwindow that can be closed via C-g
   #+BEGIN_SRC emacs-lisp
     (req-package popwin
       :config
       (popwin-mode 1)
       (setq popwin:popup-window-height 30))
   #+END_SRC
** neotree
   #+BEGIN_SRC emacs-lisp
     (req-package neotree
       :bind (("s-a" . neotree-toggle))
       :config
         (progn
         (setq neo-theme (if (display-graphic-p) 'nerd 'arrow))
         (setq neo-window-width 35)
         (setq neo-banner-face '((t (:foreground "DarkGoldenrod3" :weight bold))))
         (setq neo-dir-link-face '((t (:foreground "DarkOrange1"))))
         (setq neo-expand-btn-face '((t (:foreground "DarkOrange1"))))
         (setq neo-file-link-face '((t (:foreground "burlywood1"))))
         (setq neo-smart-open t)
         (setq projectile-switch-project-action 'neotree-projectile-action)))
   #+END_SRC
* to test
** scp (use scp to transfer files)
** smart-jump (smart go to definition)
** eterm-256color (support for 256 colors in term modes)
** network-watch (allows hooks to run when network is goiing down/up)
** latexdiff (diff between two latex files)
** easy-jekyll (tool to manage jekyll blogs)
** orca (org-capture configuration)
   - allows filing based on the url it was captured from into special files/headers etc.
** lsp-javacomp
   - lsp support for java using [[https://github.com/tigersoldier/JavaComp][java-comp]]
** archive-rpm
   - provide an interface for rpm package open (extends archive-mode)
** zoom
   - keeps balanced windows, zooming the one currently having the focus
** ox-hugo
   - export org markdown to hugo blog entries
   - see [[https://github.com/kaushalmodi/ox-hugo][here]]
** shrink-path
   - do fish like reduciton of paths (e.g. for modeline)
** highlight-function-calls
   - highlight functions in lisp specially
** org-mind-map
   - translate an org file into a mind map
** org-super-agenda
   - see [[https://github.com/alphapapa/org-super-agenda][here]]
   - This package lets you "supercharge" your Org daily/weekly agenda. The idea is to group items into sections, rather than having them all
     in one big list.
   - lets you group agenda entries based on tags, regex on title, todo status etc.
** org-projectile-helm
   - This package aims to provide an easy interface to creating per project org-mode TODO headings.
** org-category-capture
   - This package aims to provide an easy interface to creating per project org-mode TODO headings.
     #+BEGIN_SRC emacs-lisp
     (req-package org-category-capture
       :require org)
     #+END_SRC
** treemacs (tre
** projectile-codesearch (use codesearch to query projects)
** zop-to-char (more options during zap to char)
** sx (elaborate stack exchange interface for emacs)
** swiper-helm (helm interface for swipter)
** html5-schema (html5 support for nXML)
** magit-tbdiff (diffing extension for magit)
   - git-tbdiff is a git extension that allows diffs for topic branches
   - tbdiff shows the differences between two versions of a patch series, or more generally, two sets of commits (ignoring merges). To do
     this in a meaningful way, it tries to find a good correspondence between commits in the two versions (see Algorithm below), and then
     shows the difference between the pairs found. It also copes with removal and addition of commits.
   - see [[https://github.com/magit/magit-tbdiff][link]]
** indium (java script development environment)
   - [[https://github.com/NicolasPetton/Indium][home page]]
* look at
** counsel-tramp
** helm-selected
** use-package-ensure-system-package
   - require binaries / packages of the underlying system for installation of package
   - if provided with installation script might even execute the appropriate installation
   - see [[https://github.com/waymondo/use-package-ensure-system-package][here]]
* discarded
** exwm-surf
   - allows to control surf within exwm
   - surf is a webkit based browser that works as embedded x application and can thus be embedded into emacs directly
   - don't need this, since chromium or firefox can be directly embedded into exwm
* tested but discarded
** diminish (hide minor modes from spaceline mode line) (obsolete now)
   - its still a dependency of use-package, so its still loaded
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package diminish) ;; actual diminishing of modes is executed after init is completely run (see end of file)
   #+END_SRC
** use line if no region (deactive, currently evaluating easy-kill)
   uses a line as region if no active region is selected and a
   command is issued that works on regions
   (not: M-% replace)
   (yes: C-w)
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package whole-line-or-region
     :config
     (whole-line-or-region-mode 1))
   #+END_SRC
** mode icons (disabled)
   - no longer used, since spaceline brings its own set of mode icons
 #+BEGIN_SRC emacs-lisp :tangle no
   (req-package mode-icons
     :disabled t
     :config
     (mode-icons-mode)
     (setq mode-icons-desaturate-inactive t)
     (setq mode-icons-desaturate-active nil)
     (setq mode-icons-grayscale-transform t))

     ;; (defvar minor-mode-icon-list
     ;;   '((paredit-mode paredit-mode-hook "~/icons/clojure-icon-small.png" png))
     ;;   "define a list of icon replacements for the given minor modes")

     ;; (defun install-minor-mode-icons (rem-minor-mode-icon-list)
     ;;   (let* ((minor-mode-icon (car rem-minor-mode-icon-list))
     ;;          (rem-minor-mode-icon-list-new (cdr rem-minor-mode-icon-list)))
     ;;     (if minor-mode-icon
     ;;         (add-hook (nth 1 minor-mode-icon)
     ;;                   `(lambda ()
     ;;                      (let* ((mode-id (nth 0 ,minor-mode-icon))
     ;;                             (icon-path (nth 2 ,minor-mode-icon))
     ;;                             (icon-type (nth 3 ,minor-mode-icon))
     ;;                             (image-line `(image :type ,icon-type :file ,icon-path :ascent center :margin ( 3 . 0 )))
     ;;                             (minor-mode-element (assoc mode-id minor-mode-alist)))
     ;;                        (if (message "FORMATSTRING" &optional ARGS)inor-mode-element
     ;;                          (setf (cdr minor-mode-element) (list (propertize "dummy" 'display image-line))))))))
     ;;     (if rem-minor-mode-icon-list-new
     ;;         install-minor-mode-icons rem-minor-mode-icon-list-new)))

     ;; (install-minor-mode-icons minor-mode-icon-list)
 #+END_SRC
** fonts with ligatures (realized differently)
   - the following is not functional within (my) emacs => it is not tangled
     #+BEGIN_SRC emacs-lisp :tangle no

       ;; if font with ligatures is selected, define some font compositions
       (when (string= gb/default-font "Fira Code")
         (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
                        (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
                        (36 . ".\\(?:>\\)")
                        (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
                        (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                        (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
                        (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
                        (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                        (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
                        (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                        (48 . ".\\(?:x[a-zA-Z]\\)")
                        (58 . ".\\(?:::\\|[:=]\\)")
                        (59 . ".\\(?:;;\\|;\\)")
                        (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
                        (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                        (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                        (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
                        (91 . ".\\(?:]\\)")
                        (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                        (94 . ".\\(?:=\\)")
                        (119 . ".\\(?:ww\\)")
                        (123 . ".\\(?:-\\)")
                        (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                        (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
                        )
                      ))
           (dolist (char-regexp alist)
             (set-char-table-range composition-function-table (car char-regexp)
                                   `([,(cdr char-regexp) 0 font-shape-gstring])))))
     #+END_SRC
** major mode icons
   - does not work with spaceline (nor powerline)
   #+BEGIN_SRC emacs-lisp :tangle no
     (req-package xpm)
     (req-package major-mode-icons
       :require xpm
       :config
       (progn
         (setq mode-line-end-spaces
               (quote ((:eval (major-mode-icons/show)))))
         (major-mode-icons-mode 1)))
   #+END_SRC
** helm-navi
   - does not work together with current org-mode and hide-pw
     (opening password file does not start folded, passwords are shown)
   #+BEGIN_SRC emacs-lisp :tangle no
   (req-package outshine)
   (req-package navi-mode)
   (req-package outorg)
   (req-package helm-navi
     :require outshine navi-mode
     :commands helm-navi helm-navi-headings)
   #+END_SRC
** smex
   - replaced by helm-M-x, a helm interface to M-x
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Enhances M-x to allow easier execution of commands. Provides
     ;; a filterable list of possible commands in the minibuffer
     ;; http://www.emacswiki.org/emacs/Smex
     (req-package smex
       :ensure t
       :disabled t
       :bind (("M-x" . smex))
       :config
       (progn
       (setq smex-save-file (concat user-emacs-directory ".smex-items"))
       (smex-initialize)))
   #+END_SRC
* finish - up
  #+BEGIN_SRC emacs-lisp
    (report-elapsed "enter finish - up")
    (req-package-finish);; this command must be at the end !ALWAYS!

    (require 'server)
    ;; start a server to allow reuse of this server when opening other files from within the os
    (unless (server-running-p)
      (server-start))
    ;; (maximize-frame)
    (gb/do-after-display-system-init
     (toggle-frame-fullscreen)
     (ido-mode 0))
    (setq gc-cons-threshold 80000)
    (report-elapsed "exit finish - up")
  #+END_SRC

#  LocalWords:  flyspell

