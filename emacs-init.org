#+title: init.el
#+property: spellcheck no
#+property: readonly yes
#+property: header-args :tangle ~/.emacs.d/init.el :comments org 
#
# execute org-babel-tangle to actually export the code into a init.el (directly into the emacs directory)
#   c-c c-v t  (org-babel-tangle)
#
# on first run
#   - an error occurs (error "no executable `epdfinfo' found") when installing pdf-tools
#     just answer the upcoming question whether to compile pdf-tools with 'yes'
#     and wait until buffer *compile pdf-tools* reports compilation finished
#     restart emacs: the error should not come up any more!
#   - on autoinstall, installation may stop after xelb:
#     execute '(kill-emacs)' and restart emacs, after that exwm should
#     should be installed and all further installation should complete
#
# make sure to take a look at the message buffer
#   - entries with 'preinstall' mark packages that are installed up front
#   - entries with 'ok: ... installed' mark checks for external programs that are needed for some packages to work
#
* use-package
  - enable this for precompilation (still needs work on this init file though)
  #+BEGIN_SRC emacs-lisp
  ;; (eval-when-compile
  ;;   (require 'use-package))
  #+END_SRC
* preset
  - things to setup before anything else happens
  #+BEGIN_SRC emacs-lisp
  (setq gb/log-startup-timing t) ;; set true for timing messages during startup
  (setq gb/debug-package nil) ;; fails on all packages that could not be loaded but are not mandatory either

  (setq gb/time (float-time))

  (setq gc-cons-threshold 800000000)

  (defun report-elapsed (msg-prefix)
    "record an message time since last call of this function"
    (if gb/log-startup-timing
        (progn
          (setq gb/elapsed-time (- (float-time) gb/time))
          (setq gb/time (float-time))
          (message (format "%s: %f seconds" msg-prefix gb/elapsed-time)))))

  (report-elapsed "preset")
  #+END_SRC
* benchmarking
  - simply call M-x profiler-report after loading
  #+BEGIN_SRC emacs-lisp
  (if gb/log-startup-timing
      (profiler-start 'cpu))
  #+END_SRC
* info
  - information about this file and usages of certain functionalities
** el-get packages
   - example of how to load packages dynamically via el-get from git sources
   #+BEGIN_SRC emacs-lisp :tangle no
   (el-get-bundle org-brain
                  :url "https://github.com/Kungsgeten/org-brain.git"
                  :features org-brain)
   (if (el-get-package-is-installed 'org-brain)
       (el-get 'sync 'org-brain))
   (req-package org-brain
                :loader :el-get
                :require org dash helm-org-rifle
                :commands org-brain-open org-brain-visualize org-brain-insert-link
                :config
                (progn
                  (setq org-brain-path "~/brain")
                  (if (not (file-exists-p org-brain-path))
                      (make-directory org-brain-path t))
                  (defun helm-org-rifle-brain ()
                    "Rifle files in `org-brain-path'."
                    (interactive)
                    (helm-org-rifle-directories (list org-brain-path)))))
   #+END_SRC
** use-package
*** deferred loading with arbitrary key binding (even key chords are this possible) UNCHECKED!!
    - this code:
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ace-jump-mode
      :defer t ;; valid because of key registration in init
      :init
      (autoload 'ace-jump-mode "ace-jump-mode" nil t)
      (bind-key "c-." 'ace-jump-mode))
    #+END_SRC
    - is equivalent with this code (loading is done when the key is used)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ace-jump-mode
      :bind (("c-." . ace-jump-mode)))
    #+END_SRC
** helm locate
   helm uses /usr/bin/locate to actually provide a list of possible candidates.  the configuration goes into /etc/locate.rc (open within
   /sudo::/etc/locate.rc).
** helm-m-x 
*** command history
    - is saved in extended-command-history and saved through the
      package 'session' which stores lots of session information into
      the file .session in the .emacs.d
* enhancements and todos
  list of todos and enhancements to be implmented, checked, verified (some day)
** TODO switch gnus mail sync with google calendar to org-gcal
** TODO lsp-mode: check what packages have to be deactivated in order to not interfere with lsp-mode and company suggestions
** TODO allow duplex/non-duplex configuration of printer / printing (see org header "printer")
** TODO minimap mode results in ligatures being misplaced!
** IMPLEMENT describe each packages' benefit for my configuration
** TODO define something like layers
   e.g. layer for core, editing, navigation, programming ... such that these layers can be easily switched off and on at the top of the init
   file
** IMPLEMENT find keybinding for jumplist, complete jumplist-hook-commands
   - state "implement"  from "todo"       [2015-11-16 mon 12:58]
** IMPLEMENT list modes actually in use and think about optimal key/function binding
   - state "implement"  from "planned"    [2016-11-28 mon 08:08]
*** gnus
*** elfeed
*** paradox
*** org
**** org babel
**** org timers
*** latex
*** clojure
*** java
*** java script
*** docker
** TODO elfeed: filter news depending on title/feed/url etc.
   - state "test"       from "todo"       [2016-04-08 fri 15:55]
** TEST amplify org-mode
   #+BEGIN_SRC emacs-lisp :tangle no
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; org-mode agenda options                                                ;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;don't show tasks as scheduled if they are already shown as a deadline
   (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
   ;;don't give awarning colour to tasks with impending deadlines
   ;;if they are scheduled to be done
   (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
   ;;don't show tasks that are scheduled or have deadlines in the
   ;;normal todo list
   (setq org-agenda-todo-ignore-deadlines (quote all))
   (setq org-agenda-todo-ignore-scheduled (quote all))
   ;;sort tasks in order of when they are due and then by priority
   (setq org-agenda-sorting-strategy
         (quote
          ((agenda deadline-up priority-down)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
   #+END_SRC
** PLANNED explore org-contacts as bbdb replacement (look [[https://julien.danjou.info/projects/emacs-packages#org-contacts][here]] and [[http://kitchingroup.cheme.cmu.edu/blog/2016/12/22/context-specific-org-mode-speed-keys/?utm_source=feedburner&utm_medium=twitter&utm_campaign=feed:+thekitchinresearchgroup+(the+kitchin+research+group)][here]])
** PLANNED add additional modes to store linenumbers when capturing
   [[file:~/.emacs.d/init.el::org-file-lineno-store-link][file:~/.emacs.d/init.el::org-file-lineno-store-link]]
** PLANNED rebind C-x C-k keymacros to some other binding (since C-x C-k is used for killing buffers and windows)
** PLANNED define additional capture templates
   [[file:~/.emacs.d/init.el::org-capture-templates][file:~/.emacs.d/init.el::org-capture-templates]]
** PLANNED adjust selfinsertion commands to put the charater where expected (depending on the mode)
   - see http://mbork.pl/2015-10-31_Smart_comma_and_other_punctuation
** PLANNED define hydra for dired
** PLANNED define hydra for pdf-tools
** DONE install xcape into the linux installtions to allow for using space as control where possible
   - State "DONE"       from "PLANNED"    [2018-07-07 Sat 21:56]
   - configuring needs to be streamlined to allow space-down key-down key-up space-up to work as control
   - all other uses (especially space-down key-down space-up key-up should function as space then key) should work as with normal space mapping
** DONE check magit ediffing with exwm, seems to have trouble with control window!
   - State "DONE"       from "TODO"       [2017-11-16 Thu 06:52]
** DONE synchronise linux and mac os x init
   - State "DONE"       from "IMPLEMENT"  [2017-10-04 Wed 21:47]
   - state "implement"  from "todo"       [2017-01-27 fr 20:02]
*** todo some org-babel packages are not resolved during bootstrap of init.el (sed, shell, groovy)
*** todo loadpath dependencies that should be resolved
    - ob-clojure
    - javad
    - gnus-calendar
    - ox-confluence (obsolete)
    - org-jekyl (obsolete)
*** done require the emacs package manager, add available repositories and intialize packet manager
    make sure that the initial (minimal set) packages needed are all loaded
    - dash
    - maxframe
    - bind-key
    - key-chord
    - benchmark (currently via loadpath)
** DONE undo-tree workaround: [2017-02-25 Sat] currently org src block fontification is disabled if undo tree is called, since undo tree exits on up/down in the tree
** DONE disable smart region '/' in gnus (since / is used to narrow selection and is not used to surround selected text in this context)
** DONE commit message should not store any cursor position info but should always start at the beginning of the buffer
   - session does probably store this position even though COMMIT_EDITMSG is explicitly excluded from this behaviour
   - look at M-x customize-group session-name  session-name-disable-regexp
** DONE todo define keybindings depending on keyboard layout => e.g. key-chords won't make sense in us-keyboard layout
   - State "DONE"       from              [2017-06-26 Mon 16:45]
** DONE pixel wise scrolling
   - look at sublimity defvar 'sublimity--post-vscroll-functions' which is called for scrolling with the amount of lines to actually scroll
     (negative for up). this could be used to actually call pixelwise scrolling on the last line of the scroll action which would make the
     scrolling much more smooth.
** DONE selected workaround: [2017-02-22 Wed] reactivate package selected, currently running in an error, thus expand/contract region does not work anymore
** DONE extend check prerequisites to check multiple programs to exist
** DONE copy windows setup into separate region
   - State "DONE"       from "IMPLEMENT"  [2017-02-18 Sa 06:37]
   - State "IMPLEMENT"  from "TODO"       [2017-02-14 Di 15:57]
** DONE check gnus with extended setup
   - State "DONE"       from "TODO"       [2016-12-23 Fr 12:04]
** DONE when in multicursor, hungry delete should fall back to normal delete
   - State "DONE"       from "TODO"       [2016-12-23 Fr 11:47]
   - is there a mc/keymap? there C-d and <BACKSPACE> could be mapped to different functions
** DONE inserting appointments into org-agenda should make it possible to decide into which calendar this should go
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:49]
** DONE make sure that proportional font is not bold!
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:30]
** DONE remove bind-key with req-package :bind entries, since these bindings will result in loading the package (if not present yet)!
   - State "DONE"       from "IMPLEMENT"  [2016-11-28 Mon 08:07]
   - State "IMPLEMENT"  from "TODO"       [2016-11-06 So 18:12]
** DONE plantuml-mode and puml-mode are both installed, only one should reside
   - State "DONE"       from "TODO"       [2016-11-28 Mon 08:06]
** DONE put this file into version control
   - State "DONE"       from "TODO"       [2016-11-06 So 18:20]
** OBSOLETE todo accepting invitations go into agenda, syncing google calendar goes into gcal
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:45]
   it seems that accepted invitations (accepted within emacs from mail) does not correctly sync with google calendar
** OBSOLETE todo move diminish at the end of file to the respective packages
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:44]
* initial unsetting of global keys
  #+BEGIN_SRC emacs-lisp
  (global-unset-key "\C-z")     ;; (now mapped to prefix -- dash)
  (global-unset-key "\C-x\C-k") ;; keyboard makros prefix (now mapped to kill buffer)
  (global-unset-key "\M-%")     ;; replaced by visual-regexp ...
  ;; unbind super key bindings with the given keys
  (dolist (key '(& \, \^ \` \| \~ \?))
    (global-unset-key (kbd (concat "s-" (symbol-name key))))
    (global-unset-key (kbd (concat "s-" (upcase (symbol-name key))))))
  ;; unbind super key bindings with letters (lower and upper case variant)
  (dotimes (i 26)
    (let ((letter (byte-to-string (+ 65 i))))
      (global-unset-key (kbd (concat "s-" letter)))
      (global-unset-key (kbd (concat "s-" (downcase letter))))))
  #+END_SRC
* check account configuration files
  #+BEGIN_SRC emacs-lisp
  (setq agenda-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/agenda-accounts.el")))
  (setq calendar-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/calendar-accounts.el")))
  (setq mail-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/mail-accounts.el")))
  #+END_SRC
* initial setting of vars
  #+BEGIN_SRC emacs-lisp
  ;; must be set before loading use-package in order to work
  (setq use-package-enable-imenu-support t) ;; enable locating package loaded by use-package within init.el
  (setq running-nixos nil)
  #+END_SRC
* initial function setup
  #+BEGIN_SRC emacs-lisp
  (defun slurp (file-name)
    "Return file content."
    (with-temp-buffer
      (insert-file-contents file-name)
      (buffer-string)))

  (defun jde-read-properties-file (file-name)
    "read a java properties file and provide a map with key value pairs.
    property files are transformed such that multiline properties are heeded,
    double colon is heeded and spaces after the key and before the value are
    discarded."
    (let* ((file-string (slurp file-name))
           (file-string-nomultiline (replace-regexp-in-string "[^\\\\]\\(\\\\\n *\\)" "" file-string nil nil 1)) ;; incomplete! 1
           (file-string-nobackslash-escaping (replace-regexp-in-string "\\\\\\\\" "\\\\" file-string-nomultiline))
           (file-string-nodoublecolon-and-spaces (replace-regexp-in-string " *\\(:\\|=\\) *" "=" file-string-nobackslash-escaping))
           (prop-matches (re-seq "^[^#!=:][^=:]*\\(=\\|:\\)[^=:\n]+$" file-string-nodoublecolon-and-spaces))
           (hash-map (make-hash-table :test 'equal)))
      (--map
       (let* ((splitted-prop (split-string it "="))
              (key (nth 0 splitted-prop))
              (value (nth 1 splitted-prop)))
         (puthash key value hash-map))
       prop-matches)
      hash-map))
  ;; 1 what should be tested if an unbalanced backslash is present at the end of the line.
  ;;   currently the test checks whether there is a single backslash at the end of the line!

  (defun is-ms-windows-p ()
    "check whether this system is microsoft windows"
    (if (string-match "windows" (symbol-name system-type))
        t
      nil))

  (defun is-linux-p ()
    "check whether this system is a linux"
    (if (string-match "linux" (symbol-name system-type))
        t
      nil))

  (defun is-macos-p ()
    "check whether this system is mac os"
    (if (string-match "darwin" (symbol-name system-type))
        t
      nil))

  (defun is-_nix-p ()
    "check whether this is a *nix derivative (either linux or macos)"
    (or (is-linux-p) (is-macos-p)))
  #+END_SRC
* proxy setup (if present)
  #+BEGIN_SRC emacs-lisp
  (if (file-exists-p (concat user-emacs-directory "accounts/proxy-account.el"))
      (load-file (concat user-emacs-directory "accounts/proxy-account.el")))
  #+END_SRC
* package setup
  #+BEGIN_SRC emacs-lisp
  (report-elapsed "enter package setup")
  (require 'package)

  ;; package access either through secure https, or insecure http
  (setq secure-package-access t)


  (when gb/debug-package
    (setq ;; add verbosity level to use package
     ;; use-package-verbose t
     ;; make sure that use-package does minimal reporting to the message buffer
     use-package-expand-minimally t))

  (if secure-package-access
      (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                               ("melpa-stable" . "https://stable.melpa.org/packages/")
                               ("org" . "https://orgmode.org/elpa/")
                               ("melpa" . "https://melpa.org/packages/")))
    (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                             ("melpa-stable" . "http://stable.melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("melpa" . "http://melpa.org/packages/"))))

  (setq package-archive-priorities
        '(("melpa-stable" . 20)  ;; stable is preferred
          ("melpa" . 10)
          ("gnu" . 0)))

  (setq package-menu-async (is-_nix-p)) ;; defaulting operations to be async (is problematic on windows systems)

  (package-initialize) ;; cannot use t as parameter since initialization is necessary for init file to work

  (defun require-package (package)
    "refresh package archives, check package presence and install if it's not installed"
    (if (null (require package nil t))
        (progn
          (let* ((ARCHIVES (if (null package-archive-contents)
                               (progn (package-refresh-contents)
                                      package-archive-contents)
                             package-archive-contents))
                 (AVAIL (assoc package ARCHIVES)))
            (if AVAIL
                (package-install package)))
          (require package))))

  (setq package-to-install-initially
        '( dash
           ht
           maxframe
           bind-key
           key-chord
           validate
           use-package
           seq
           ;; see here https://github.com/jabranham/system-packages
           ;; allows for system manager actions (detecting the system manager)
           system-packages
           ;; see here  https://github.com/jwiegley/use-package
           ;; makes sure that a system program is installed
           use-package-ensure-system-package
           s))

  ;; add mac specific packages
  (when (is-macos-p)
    (add-to-list 'package-to-install-initially 'exec-path-from-shell))

  (dolist (package package-to-install-initially)
    (progn
      (message (concat "Preinstall/require " (symbol-name package)))
      (require-package package)))

  ;; TODO: recheck no and then. error is present in req-package version 1.2
  ;; initialize unbound req-package variable (otherwise an error happens during startup)
  ;;(if (not (boundp 'req-package-paths))
  ;;    (setq req-package-paths (ht)))

  (report-elapsed "exit package setup")
  #+END_SRC
** paradox (package list alternative)
   #+BEGIN_SRC emacs-lisp 
   (use-package paradox
     :after (hydra)
     :commands gb/paradox-list-packages
     :bind (:map paradox-menu-mode-map ("<f1>" . hydra-paradox-list-packages/body))
     :init
     (progn
       (report-elapsed ":init-enter paradox")
       ;; (defun gb/ensure-github-token ()
       ;;   "make sure to load github token if it is empty"
       ;;   (if (not paradox-github-token)
       ;;       (let* ((github-token-file "~/.github-token.properties.gpg"))
       ;;         (if (file-exists-p github-token-file)
       ;;             (let* ((auth-map (jde-read-properties-file "~/.github-token.properties.gpg")))
       ;;               (setq paradox-github-token (gethash "github-paradox-token" auth-map)))
       ;;           (message "WARNING: github token file not found. paradox-list-packages will have to work without github integration.")))))
       ;; (advice-add 'paradox-list-packages :before #'(lambda (orig-func &rest args) (gb/ensure-github-token)))
       )

     :config
     (report-elapsed ":config-enter paradox")

     ;; description is pastell sand like color
     (custom-set-faces '(paradox-description-face ((t (:foreground "#e0d0a0")))))
     (progn
       (setq paradox-automatically-star nil)
       (setq paradox-column-width-package 30)
       (setq paradox-column-width-version 17)
       (when (package-installed-p 'hydra)
         (defhydra hydra-paradox-list-packages ()
           "
        [_v_] view homepage           [_x_] execute commands
        [_l_] show latest commits     [_i_] install
         ^ ^                          [_d_] delete
         ^ ^                          [_U_] update all
     %s(hydra-combine-functions-w-key-bindings
       '((\"    view homepage      \" . paradox-menu-visit-homepage)
         (\"    show latest commit \" . paradox-menu-view-commit-list)
         (\"    execute commands   \" . paradox-menu-execute)
         (\"    install            \" . package-menu-mark-install)
         (\"    delete             \" . package-menu-mark-delete)
         (\"    mark upgrades      \" . package-menu-mark-upgrades)))
     "
           ("v" paradox-menu-visit-homepage)
           ("l" paradox-menu-view-commit-list)
           ("x" paradox-menu-execute :exit t)
           ("i" package-menu-mark-install )
           ("d" package-menu-mark-delete)
           ("U" package-menu-mark-upgrades)
           ("q" (message "Abort") :exit t))
         ))
     (report-elapsed ":config-exit paradox")
     )
   #+END_SRC
* workarounds for broken packages
  #+BEGIN_SRC emacs-lisp
  ;; since perspective is using make-variable-frame-local and this function/macro is removed in emacs 26.x
  ;; (when (not (fboundp 'make-variable-frame-local))
  ;;   (defun make-variable-frame-local (variable) variable))
  #+END_SRC
* splash and initial buffer config
  #+BEGIN_SRC emacs-lisp
  ;; set scratch window content
  (let* ((total-ram (if (is-macos-p)
                        (/ (string-to-int (shell-command-to-string "sysctl hw.memsize | sed 's/.*:\s*//'")) (* 1024 1024 1024) )
                      (/ (nth 0 (memory-info)) (* 1024 1024))))
         (free-ram (if (is-macos-p) 0 (/ (nth 1 (memory-info)) (* 1024 1024))))
         (total-ram-str (concat (number-to-string total-ram) "GB" ))
         (free-ram-str (if (= 0 free-ram) "LOTS OF" (concat (number-to-string free-ram) "GB" )))
         (len-avail-for-memory (+ (length emacs-version) 1))
         (len-needed-for-memory (+ (length free-ram-str) (length total-ram-str))))

    (setq initial-scratch-message 
          (propertize (concat ";; ***** FREE SOFTWARE FOUNDATION  EMACS "
                              emacs-version
                              " *****\n;;   "
                              total-ram-str 
                              " RAM SYSTEM" 
                              (make-string (max 2 (- len-avail-for-memory len-needed-for-memory)) ? )
                              free-ram-str
                              " EMACS LISP BYTES FREE\n;; READY\n")
                      ;; properties do not work here, since they are overwritten/not used
                      )))

  ;; make sure no *Messages* buffer is open on startup 
  (add-hook 'window-setup-hook 'delete-other-windows)

  ;; Go strait to scratch buffer on startup
  (setq inhibit-startup-message t)
  #+END_SRC
* own utility functions
** misc
   #+BEGIN_SRC emacs-lisp
   (setq async-shell-command-display-buffer nil) ;; make sure that the async command does not open a result buffer
   (defun available-keys ()
     "return a list of ids for which the private key is known"
     (remove-if 'string-empty-p (s-split "\n" (shell-command-to-string "gpg -Kq 2> /dev/null | grep -e \"^uid\" | awk '{ print $5; }'"))))

   (defun gb/cache-gpg (prompt)
     "cache gpg password for the standard key or the selected key if the universal argument was provided"
     (interactive "P")
     (require 'ivy)
     (if prompt
         (progn
           (let ((keyId (ivy-read "email: " (--map (string-trim it "<" ">") (available-keys)))))
             (gb/cache-gpg-key keyId)))
       (gb/cache-gpg-key)))

   (defun gb/cache-gpg-key (&optional keyId)
     ""
     (if keyId
         (async-shell-command (concat "echo \"ok\" | gpg -s -u \"" keyId "\" &> /dev/null" nil nil))
       (async-shell-command "echo \"ok\" | gpg -s &> /dev/null" nil nil)))

   (defun re-seq (regexp string &optional matchpos)
     "Get a list of all regexp matches in a string, use matchpos as group index if groups are used!"
     (save-match-data
       (let ((pos-to-match (or matchpos 0))
             (pos 0)
             matches)
         (while (string-match regexp string pos)
           (push (match-string pos-to-match string) matches)
           (setq pos (match-end 0)))
         matches)))
   (rx-to-string `(: bos "prefix"))
   (ert-deftest re-seq-test ()
     "test re-seq (only)"
     (should (let* ((result (re-seq  "\\([0-9]+\\)" "some31and4other")))
               (and (member "4" result)
                    (member "31" result)
                    (= 2 (length result)))))
     (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother")))
               (and (member "31and" result)
                    (= 1 (length result)))))
     (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother" 1)))
               (and (member "31" result)
                    (= 1 (length result))))))

   (defun file-name-from-current-dir (file-name)
     "get given file in the directory of the file currently active"
     (concat (file-name-directory (file-truename (or (concat  "./" file-name) (buffer-file-name (current-buffer))))) file-name))


   (defun get-buffer-file-matching-extension (extension-regex)
     "get all buffers that are associated with a file matching the given extension"
     (--filter (string-match extension-regex (or (file-name-extension it) ""))
               (remove-if 'null (mapcar 'buffer-file-name (buffer-list)))))

   (defun get-visible-buffer-file-matching-extension (extension-regex)
     "get all buffers visible that are associated with a file matching the given extension"
     (--filter (string-match extension-regex (or (file-name-extension it) ""))
               (remove-if 'null  (mapcar 'buffer-file-name (mapcar 'window-buffer (window-list))))))

   (defun spit (contents file-name)
     "Write the given contents into the given file"
     (with-temp-buffer
       (insert contents)
       (write-file file-name)))


   #+END_SRC
** transparency
   #+BEGIN_SRC emacs-lisp
   (defun disable-transparency ()
     "make emacs solid again"
     (interactive)
     (setq frame-transparency-value 100)
     (set-frame-parameter (selected-frame) 'alpha '(100 100)))

   (defun increase-transparency ()
     "increase current frame transparency"
     (interactive)
     (setq frame-transparency-value (max 35 (- frame-transparency-value 7)))
     (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

   (defun decrease-transparency ()
     "decrease current frame transparency"
     (interactive)
     (setq frame-transparency-value (min 100 (+ frame-transparency-value 7)))
     (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

   (setq frame-transparency-value 100)
   (add-to-list 'default-frame-alist '(alpha 100 100))
   #+END_SRC
** editing
*** comment toggle
    #+BEGIN_SRC emacs-lisp
    (defun toggle-comment-on-line ()
      "comment or uncomment current line"
      (interactive)
      (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
    #+END_SRC
*** dos/windows-eol
    #+BEGIN_SRC emacs-lisp
    (defun remove-dos-eol ()
      "Do not show ^M in files containing mixed UNIX and DOS line endings.
              This is especially useful when viewing diffs in magit!"
      (interactive)
      (setq buffer-display-table (make-display-table))
      (aset buffer-display-table ?\^M []))
    #+END_SRC
*** query for a word
    #+BEGIN_SRC emacs-lisp
    ;; aktivate through M-s M-w
    (defun gb/eww-search (orig-fun &rest args)
      "query for string if no active region is present"
      (if (region-active-p)
          (apply orig-fun args)
        (eww (read-string "Query: "))))

    (advice-add 'eww-search-words :around #'gb/eww-search)
    #+END_SRC
*** buffer utils
    #+BEGIN_SRC emacs-lisp
    (defun gb/buffer-contains-string(str)
      "does the current buffer contain the given string?"
      (save-excursion
        (goto-char (point-min))
        (let ((search-result (re-search-forward str nil t)))
          (if search-result (point) nil))))
    #+END_SRC
** scrolling
   #+BEGIN_SRC emacs-lisp
   (defun scroll-up-line-7 ()
     (interactive)
     (scroll-up-line 7))
   (defun scroll-down-line-7 ()
     (interactive)
     (scroll-down-line 7))

   ;; scroll and move cursor
   (defun scroll-up-line-and-move-cursor ()
     (interactive)
     (scroll-up 1)
     (forward-line 1))

   (defun scroll-down-line-and-move-cursor ()
     (interactive)
     (scroll-down 1)
     (forward-line -1))

   (defun scroll-up-line-and-move-cursor-7 ()
     (interactive)
     (scroll-up-line 7)
     (next-line 7))

   (defun scroll-down-line-and-move-cursor-7 ()
     (interactive)
     (scroll-down-line 7)
     (previous-line 7))
   #+END_SRC
** hydra utils
   #+BEGIN_SRC emacs-lisp
   (defun keys-for-function (fun-symbol)
     "find a key binding for the given function
     always returns a string (can be empty)"
     ;; (or (car (car (car (--filter (eq (car (cdr it)) fun-symbol) personal-keybindings)))) "")
     (let ((result (substitute-command-keys (concat "\\[" (symbol-name fun-symbol) "]"))))
       (if (equal (substring result 0 (min (length result) 3)) "M-x")
           ""
         result)))

   (defun hydra-combine-functions-w-key-bindings (pairs)
     "return a string that can be put into hydra menu
     pairs must be a list of tuple of the form ( string . function )
     if a personal keybinding exists the string is concatenated with the
     keybinding of the respective function. if no keybining exists that
     pair is ignored for the rest of the function. all pairs found relevant
     are combined with line breaks in between.

     example call: (hydra-combine-functions-w-key-bindings
                      '(( \"some \" . function )
                        ( \"other\" . mc/mark-previous-like-this )))"
     (--reduce
      (if (eq it nil) "" (format "%s
     %s" acc it))
      (-non-nil
       (--map
        (let ((kb (keys-for-function (cdr it))))
          (if (string-empty-p kb) nil (concat (car it) " <" kb ">")))
        pairs))))
   #+END_SRC
** org utils
   #+BEGIN_SRC emacs-lisp
   (defun gb/execute-startup-block ()
     "execute within this org file the source code block that's named 'startup'"
     (interactive)
     (org-babel-goto-named-src-block "startup")
     (org-babel-execute-src-block))
   #+END_SRC
** ui
   #+BEGIN_SRC emacs-lisp
   (defun gb/kill-a-buffer-and-delete-window (askp)
     "kill the current buffer and remove the window"
     (interactive "P")
     (gb/kill-a-buffer askp)
     ;; only called without prefix argument and not the root window of the frame
     (if (not (or askp (frame-root-window-p (get-buffer-window))))
         (delete-window)))

   (defun gb/kill-a-buffer (askp)
     "kill the current buffer (ask if prefix argument is given)"
     (interactive "P")
     (if askp
         (kill-buffer (ivy-read "Kill buffer: " (mapcar #'buffer-name (buffer-list))))
       (if (string= (buffer-name) "*scratch*")
           (message "scratch buffer must be killed explicitly (with prefix argument, then selecting the buffer)")
         (kill-buffer (current-buffer)))))

   (global-set-key (kbd "C-x k") 'gb/kill-a-buffer)
   (global-set-key (kbd "C-x C-k") 'gb/kill-a-buffer-and-delete-window)
   #+END_SRC
** printer
   extensions
   - add options to print black&white, 2sided, on a4, more than 1 pager per paper
   - printing from pdf-tools view uses the following options for printing
     - (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge"))
   - these could be set via function to allow duplex/non-duplex printing
   #+BEGIN_SRC emacs-lisp
   (setq ps-font-size (quote (7 . 6.5)))
   (setq ps-paper-type (quote a4))
   (setq ps-print-header-frame nil)
   (setq ps-print-header nil)
   (defun gb/get-known-printers ()
     "get all printers currently known to the system"
     (let* ((result (shell-command-to-string "lpstat -a | cut -f1 -d ' '"))
            (result-list (split-string result)))
       result-list))

   (defun gb/get-standard-printer ()
     "get the current standard printer"
     (string-trim (shell-command-to-string "lpq | grep -v 'no entries' | awk '{ print $1; }'")))

   (defun gb/set-default-printer (printer-str)
     "set the given printer to the standard printer"
     (shell-command (concat "lpoptions -d " printer-str " -o media=A4"))
     (setq printer-name printer-str)
     (setq ps-printer-name printer-str))

   (defun gb/query-default-printer ()
     "interactively query for the printer that is then set to be the default printer"
     (interactive)
     (let ((printer-name (ivy-read "printer:" (gb/get-known-printers) :preselect (gb/get-standard-printer) :require-match t)))
       (gb/set-default-printer printer-name)))

   (defun gb/print-buffer (x)
     "Output a postscript file using the defaults.

   When called with universal argument, use font lock.
   Ligatures are disabled for printing."
     (interactive "P")
     (let* (reenable-ligatures ligatures-enabled)
       (gb/disable-ligatures)
       (redisplay t)
       (setq ps-top-margin 80)
       (if x
           (ps-print-buffer-with-faces "~/temp.ps")
         (ps-print-buffer "~/temp.ps"))
       (cond
        ((is-macos-p) (shell-command "open /Applications/Preview.app ~/temp.ps"))
        ((executable-find "evince") (start-process "evince" nil "evince" (file-truename "~/temp.ps")))
        (t (message "No viewer for postscript files known to display ~/temp.ps")))
       (gb/enable-ligatures)))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp

   ;; source: https://stackoverflow.com/questions/5580562/formatting-an-integer-using-iso-prefixes-for-kb-mb-gb-and-kib-mib-gib
   (defconst number-to-string-approx-suffixes
     '("k" "M" "G" "T" "P" "E" "Z" "Y"))

   (defun number-to-string-approx-suffix (n &optional binary)
     "Return an approximate decimal representation of NUMBER as a string,
   followed by a multiplier suffix (k, M, G, T, P, E, Z, Y). The representation
   is at most 5 characters long for numbers between 0 and 10^19-5*10^16.
   Uses a minus sign if negative.
   NUMBER may be an integer or a floating point number.
   If the optional argument BINARY is non-nil, use 1024 instead of 1000 as
   the base multiplier."
     (if (zerop n)
         "0"
       (let ((sign "")
             (b (if binary 1024 1000))
             (suffix "")
             (bigger-suffixes number-to-string-approx-suffixes))
         (if (< n 0)
             (setq n (- n)
                   sign "-"))
         (while (and (>= n 9999.5) (consp bigger-suffixes))
           (setq n (/ n b) ; TODO: this is rounding down; nearest would be better
                 suffix (car bigger-suffixes)
                 bigger-suffixes (cdr bigger-suffixes)))
         (concat sign
                 (if (integerp n)
                     (int-to-string n)
                   (number-to-string (floor n)))
                 suffix))))

   (defun sudo-shell-command (command)
     (interactive "MShell command (root): ")
     (with-temp-buffer
       (cd "/sudo::/")
       (async-shell-command command)))

   (defun dont-kill-emacs()
     "Disable C-x C-c binding execute kill-emacs."
     (interactive)
     (error (substitute-command-keys "To exit emacs: \\[kill-emacs]")))
   (bind-key "C-x C-c" 'dont-kill-emacs)

   (defun ibuffer-list-buffers-and-switch ()
     "Shows a list of buffers"
     (interactive)
     (ibuffer-list-buffers)
     (other-window 1))

   (require 'subr-x)
   (defun _nix-program-exists-in-path-p (program-string)
     "Does the given exist as file and is on the path?
        PROGRAM is the name of the program without path, given as string.

        (fn PROGRAM)

        This program won't work in non unix environments.

        the return value is either t or nil."
     (let* ((which-result (shell-command-to-string (concat "which " program-string))))
       (not (or (string-empty-p which-result)
                (string-match (concat "no " program-string " in") which-result)
                (string-match "not found"  which-result)))))

   (defun all-files-exist (full-file-string-list)
     "does the given file (list of files, all) exist?
   pass either list of strings or a string."
     (if (stringp full-file-string-list)
         (file-regular-p full-file-string-list)
       (-none-p 'null (-map 'file-regular-p full-file-string-list))))

   (defun all-files-excutable (full-file-string-list)
     "is the given file (list of files, all) executable?
   pass either list of strings or a string."
     (if (stringp full-file-string-list)
         (file-executable-p full-file-string-list)
       (-none-p 'null (-map 'file-executable-p full-file-string-list))))

   (defun all-_nix-program-exists-in-path-p (program-string)
     "make sure that the PROGRAM-STRING exists as executable reachable for unix.
   If PROGRAM-STRING is a list, make sure this is true for all elements of the list"
     (if (stringp program-string)
         (executable-find program-string)
       (-none? 'null (-map 'executable-find program-string))))

   (defun report-string-or-list (string-or-list)
     "return STRING-OR-LIST if it is a string, else join the list of strings with comma"
     (if (stringp string-or-list)
         string-or-list
       (string-join string-or-list ", ")))

   (defmacro check-file-existence-status (var-name full-file-string file-name warning)
     "set VAR-NAME to t iff all files in FULL-FILE-STRING exist. additionall
   report existing files (with ok) and non existing files (with warning)."
     `(progn
        (setq ,var-name (all-files-exist ,full-file-string))
        (if (not ,var-name)
            (message (concat "WARNING: " ,file-name " missing, " ,warning))
          (message (concat "OK: " ,file-name " exists.")))))

   (defmacro check-windows-program-status (var-name full-program-string program-name warning)
     "Will check that FULL-PROGRAM-STRING is a full path to an executable and setq's VAR-NAME to installation status
        A WARNING will be logged if no installation is found.

        (macro VAR-NAME FULL-PROGRAM-STRING PROGRAM-NAME WARNING)
        "
     `(if (is-ms-windows-p)
          (progn
            (setq ,var-name (all-files-executable ,full-program-string))
            (if (not ,var-name)
                (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
              (message (concat "OK: " ,program-name " installed."))))
        (progn
          (setq ,var-name nil)
          (message (concat "UNCHECKED (win): " ,program-name)))))

   (defmacro check-_nix-program-status (var-name program-string program-name warning)
     "Will check that PROGRAM-STRING is an executable on the path and setq's VAR-NAME to installation status
        A WARNING will be logged if no installation is found.

        (macro VAR-NAME PROGRAM-STRING PROGRAM-NAME WARNING)
        "
     `(if (is-_nix-p)
          (progn
            (setq ,var-name (all-_nix-program-exists-in-path-p ,program-string))
            (if (not ,var-name)
                (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
              (message (concat "OK: " ,program-name " installed."))))
        (progn
          (setq ,var-name nil)
          (message (concat "UNCHECKED (*nix) : " ,program-name)))))

   #+END_SRC
* delete old backup files
  #+BEGIN_SRC emacs-lisp
  ;; delete backup files that are older than 20 weeks
  ;; or that are elisp files within .emacs.d/elpa/*
  (if (not (file-exists-p "~/file-backups"))
      (make-directory "~/file-backups"))
  (message "Deleting old backup files...")
  (let ((weeks (* 60 60 24 7 20)) ;; twenty weeks
        (current (float-time (current-time))))
    (dolist (file (directory-files (expand-file-name "~/file-backups") t))
      (when (and (backup-file-name-p file)
                 (or (> (- current (float-time (nth 5 (file-attributes file))))
                        weeks)
                     (string-match "!.emacs.d!elpa!.*elc?~$" file))) ;; remove old elpa files (which are not edited by me anyway)
        (message "about to delete file: %s" file)
        (delete-file file))))
  #+END_SRC
* ms windows specific stuff
  #+BEGIN_SRC emacs-lisp
  (when (is-ms-windows-p)
    (progn

      (setq gnutls-cli-installed nil)

      ;; make sure that git asks for the credentials via gui
      (setenv "GIT_ASKPASS" "git-gui--askpass")

      (setq graphviz-installation-path "C:/dev/tools/Graphviz 2.28/")

      (check-windows-program-status graphviz-installed (concat graphviz-installation-path "bin/dot.exe") "Graphviz" "org babel will not be able to prodcess dot files.")

      (if graphviz-installed
          (add-to-list 'exec-path graphviz-installation-path))

      (setq org-plantuml-jar-path "c:/dev/tools/plantuml.jar")

      (check-file-existence-status plantuml-installed org-plantuml-jar-path "plantuml.jar" "org babel won't be able to produce uml diagrams via plantuml.")

      (setq everthing-installation-path "C:/dev/tools/es/")
      (check-windows-program-status everything-installed (concat everthing-installation-path "es.exe") "Everything" "Helm locate will not work without 'Everthing' installed")

      (if everything-installed
          (progn
            (setq everything-cmd "C:/dev/tools/es/es.exe")
            (setq helm-locate-command "es.exe %s -r %s")))

      (setq magithub-installation-path "c:/dev/tools/hub/bin/")
      (check-windows-program-status hub-installed (concat magithub-installation-path "hub.exe") "Hub" "cannot use magithub within magit.")

      (if hub-installed
          (magithub-hub-executable (concat magithub-installation-path "hub.exe")))

      ;; windows specific settings
      ;; 1. install AutoHotkey
      ;; 2. remap windows and alt keys (left windows key will be meta, alt key will be super)
      ;;      LWin::LAlt
      ;;      LAlt::LWin
      ;;      Capslock::Ctrl
      ;; 3. disable windows hot key binding in windows (LWin + f won't open the windows find dialog anymore!)
      ;;      - start 'regedit'
      ;;      - got to the key 'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer'
      ;;      - create a new DWORD 'NoWinKeys' entry  and set its value to 1
      ;;      - reboot

      ;; make sure that autohotkey is run beforehand to map the left windows key to alt!
      (setq w32-lwindow-modifier 'super)

      (setq w3m-installed nil)

      (setq aspell-installation-path "C:/dev/tools/Aspell/")
      (check-windows-program-status aspell-installed (concat aspell-installation-path "bin/aspell.exe") "Aspell" "no spell checking will be possible")

      (if aspell-installed
          (progn
            (add-to-list 'exec-path (concat aspell-installation-path "bin/"))
            (setq ispell-program-name "aspell")))))
  #+END_SRC
* mac os x specific stuff
** misc
   #+BEGIN_SRC emacs-lisp
   ;; mac specific adjustments (keyboard etc)
   (when (is-macos-p)
     (progn

       (setq browse-url-browser-function 'browse-url-chromium)
       (setq browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
       (setq browse-url-firefox-program "/Applications/Firefox.app/Contents/MacOS/firefox")

       ;;     ns-alternate-modifier
       ;;     ns-command-modifier
       ;;     ns-control-modifier
       ;;     ns-function-modifier
       ;;     ns-option-modifier (just a different name for ns-alternate-modifier)
       ;;     ns-right-alternate-modifier
       ;;     ns-right-command-modifier
       ;;     ns-right-control-modifier
       ;;     ns-right-option-modifier

       ;; Each variable can be set to 'control, 'meta, 'alt, 'super, or 'hyper.
       ;; control = C-
       ;; meta = M-
       ;; alt = A-
       ;; super = s-
       ;; hyper = H-


       ;; make sure native fullscreen is off (multi monitor support is shitty then)
       (setq ns-use-native-fullscreen nil)

       ;; make sure that using powerline, the arrows are not somewhat color garbled
       ;; Non-nil means to use sRGB colorspace on OSX >= 10.7.
       (setq ns-use-srgb-colorspace nil)

       ;; fonts anti-aliasing einschalten
       (setq mac-allow-anti-aliasing t)

       ;; Some mac-bindings interfere with Emacs bindings.
       (when (boundp 'mac-pass-command-to-system)
         (setq mac-pass-command-to-system nil))
       ;; Some mac-bindings interfere with Emacs bindings.
       (when (boundp 'mac-pass-control-to-system)
         (setq mac-pass-control-to-system nil))

       ;; Make sure the right alt key is not bound to meta (such that the right alt key can be used on a mac to create []{}...)
       (setq ns-command-modifier 'super)
       (setq ns-function-modifier 'hyper)
       (setq ns-alternate-modifier 'meta)
       (setq ns-control-modifier 'control)
       (setq ns-right-command-modifier 'super)

       ;; on macos x the right alt key is used to get e.g. the pipe '|' (alt-7)
       (setq ns-right-alternate-modifier nil) ;; 'meta

       (defun gb/keyboard-off-macbook-internal () "switch the internal keyboard of the macbook pro off"
              (interactive)
              (sudo-shell-command "kextunload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))

       (defun gb/keyboard-on-macbook-internal () "switch the internal keyboard of the macbook pro on"
              (interactive)
              (sudo-shell-command "kextload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))
       ))
   #+END_SRC
** correct shell path behaviour
   #+BEGIN_SRC emacs-lisp
   ;; make sure this is run before anything else, since all shell program starts need the correct path
   ;; exec-path-from-shell alread required (w/i initial package setup)
   (when (is-macos-p)
     (exec-path-from-shell-initialize)
     (exec-path-from-shell-copy-envs
      '("PATH")))
   #+END_SRC
* check installation status of programs (*nix)
  - make sure this is done, after path is properly setup (mac os problem)
  #+BEGIN_SRC emacs-lisp
  (setq running-nixos (getenv "NIX_PATH"))
  (setq gb/use-exwm (or (string= "ok" (s-trim (shell-command-to-string "cat ~/.xinitrc | grep -q -e '^ *exec .*emacs' && echo 'ok'")))
                        running-nixos))
  (if (is-linux-p)
      (let* ((tracepathResult (shell-command-to-string "tracepath -b -m 4 github.com"))
             (gb/behind-comp (s-contains? "compal" tracepathResult))
             (gb/behind-kabeld (s-contains? "kabel-deutschland" tracepathResult)))
        (setq gb/network-home (and gb/behind-comp gb/behind-kabeld)))
    (setq gb/network-home nil))
  (setq gb/dual-monitor-setup (string= "2" (s-trim (shell-command-to-string "xrandr --listmonitors | grep \"Monitors\" | awk '{ print $2; }'"))))

  (setq gb/use-smart-mode-line (and gb/use-exwm gb/dual-monitor-setup (not gb/network-home) (not running-nixos))) ;;
  (setq gb/use-space-line (not gb/use-smart-mode-line))


  (when (is-_nix-p)
    (progn

      ;; is imagemagick installed (program for command line image manipulation)
      ;; install via "brew install imagemagick" or "pacman -S imagemagick"
      (check-_nix-program-status imagemagick-installed "animate" "ImageMagick" "pdf-tools not installed!")
      (check-_nix-program-status poppler-installed "pdfinfo" "poppler" "pdf-tools not installed!")
      (check-_nix-program-status gnutls-cli-installed "gnutls-cli" "gnutls-cli" "gnutls-cli not installed!")

      (check-_nix-program-status xmllint-installed "xmllint" "xmllint" "xmllint not installed, some xml functions will not be accessible (e.g. formatting)")


      ;; graphviz brings dot (and other) cl tools which are needed for plantuml to work
      (check-_nix-program-status graphviz-installed "dot" "GraphViz" "dot is not available, thus plantuml cannot be used!")

      ;; make useful for pdf tools
      (check-_nix-program-status make-installed '("make" "automake" "autoconf" "g++" "gcc") "make-tools" "make-tools are not (completely) available, thus pdf-tools cannot be compiled!")

      ;; check basic tooling
      (check-_nix-program-status locate-installed "locate" "locate" "locate is not available, thus helm find file will not work properly!")

      ;; lein (for clojure)
      (check-_nix-program-status lein-installed "lein" "leinigen" "lein is not available, thus clojure/cider will not work properly!")

      ;; hub (for magithub)
      (check-_nix-program-status hub-installed "hub" "hub" "hub command line tool not available, magithub will not be installed")

      ;; gpg (for file encryption)
      (check-_nix-program-status gpg-installed "gpg" "gpg" "gpg is necessary for file encryption.")
      (if gpg-installed
          (setq epg-gpg-program "gpg"))

      (check-_nix-program-status w3m-installed '("w3m") "w3m" "html messages in gnus will not be displayed, helm dash browsing will not use w3m.")

      (check-_nix-program-status git-lfs-installed "git-lfs" "git-lfs" "magit-lfs will not be available")

      (check-_nix-program-status ledger-installed "ledger" "ledger" "ledger-mode will not be available")

      (check-_nix-program-status chromium-installed "chromium" "chromium" "chromium not found, flymd will not work")

      (check-_nix-program-status firefox-installed "firefox" "firefox" "firefox not found")

      (check-_nix-program-status icecat-installed "icecat" "icecat" "icecat not found")

      (check-_nix-program-status git-imerge-installed "git-imerge" "git-imerge" "git-imerge not found")

      (check-_nix-program-status languagetool-installed "languagetool" "languagetool" "languagetool not found")


      (if firefox-installed
          (progn
            (setq browse-url-browser-function 'browse-url-firefox)
            (setq browse-url-firefox-program (s-trim (shell-command-to-string "which firefox")))))

      ;; chromium takes precedence (over firefox)
      (if chromium-installed
          (progn
            (setq browse-url-browser-function 'browse-url-chromium)
            (setq browse-url-chromium-program (s-trim (shell-command-to-string "which chromium")))))

      ;; icecat takes precedence (over firefox)
      ;; (if icecat-installed
      ;;   (progn
      ;;     (setq browse-url-browser-function 'browse-url-default-browser)
      ;;     (setq browse-url-chromium-program (s-trim (shell-command-to-string "which icecat")))))

      (setq gnu-ls-installed (not (is-ms-windows-p)))
      (if gnu-ls-installed
          (setq gnu-ls-bin-path (car (split-string (shell-command-to-string "which ls")))))
      ))
  #+END_SRC
* check emacs capabilities
  #+BEGIN_SRC emacs-lisp
  ;; check on png support
  (if (image-type-available-p 'png)
      (message "OK: Image type png is supported.")
    (message "WARNING: image type png is NOT supported."))
  #+END_SRC
* own utility functions (based on installed utils)
** xml
   #+BEGIN_SRC emacs-lisp
   ;; make sure flyspell works with nxml mode
   ;; (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)
   ;; make sure to use flyspell-prog-mode, though

   ;; if interactively used, print the current path to the mini buffer
   ;; if used non interactively, return the same
   (defun nxml-where ()
     "Display the hierarchy of XML elements the point is on as a path."
     (interactive)
     (let ((path nil))
       (save-excursion
         (save-restriction
           (widen)
           (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                       (condition-case nil
                           (progn
                             (nxml-backward-up-element) ; always returns nil
                             t)
                         (error nil)))
             (setq path (cons (xmltok-start-tag-qname) path)))
           (let ((result (format "/%s" (mapconcat 'identity path "/"))))
             (if (called-interactively-p t)
                 (message result)
               result))))))

   (defun nxml-where-to-clipboard ()
     "paste xpath of the current location into clipboard and message buffer"
     (interactive)
     (let ((result (nxml-where)))
       (kill-new result)
       (message result)))

   (when xmllint-installed
     (defun nxml-pretty-format ()
       "use command line tool xmllint to format (large) xml files"
       (interactive)
       (save-excursion
         (shell-command-on-region (point-min) (point-max) "xmllint -nowarning --format -" (buffer-name) t)
         (nxml-mode)
         (indent-region begin end))))

   (when xmllint-installed
     (defun nxml-xpath (xpath)
       "run an xpath (may NOT include namespaces) on the currently selected buffed.
   output is pasted into buffer *xpath-output*"
       (interactive (list (read-string "xpath:" nil 'xpath-history)))
       (let* ((out-buffer "*xpath-output*")
              (new-buffer (get-buffer-create out-buffer))
              (cmd (concat "xmllint --nowarning --xpath " (shell-quote-argument xpath) " -")))
         (if (fboundp 'persp-add-buffer)
             (persp-add-buffer out-buffer))
         (shell-command-on-region (point-min) (point-max) cmd out-buffer)
         (with-current-buffer out-buffer
           (condition-case nil
               (if (string= "<" (buffer-substring-no-properties 1 2))
                   (nxml-mode)
                 (text-mode))
             (error (text-mode))))
         (if (not (get-buffer-window out-buffer))
             (message (concat "output is on buffer " out-buffer))))))

   (when xmllint-installed
     (defun nxml-xpath-on-file (xpath)
       "run an xpath (may include namespaces) on the FILE of the currently selected buffed.
   output is pasted into buffer *xpath-output*"
       (interactive (list (read-string "xpath:" nil 'xpath-history)))
       (let ((cmd (concat "echo -e \"setrootns\ncat " xpath "\" | xmllint --nowarning --shell "
                          (buffer-file-name (window-buffer (minibuffer-selected-window)))
                          "| grep -v -e \"^/ >\""))
             (out-buffer "*xpath-output*"))
         (if (fboundp 'persp-add-buffer)
             (persp-add-buffer out-buffer))
         (shell-command cmd out-buffer)
         (with-current-buffer out-buffer
           (condition-case nil
               (if (string= "<" (buffer-substring-no-properties 1 2))
                   (nxml-mode)
                 (text-mode))
             (error (text-mode))))
         (if (not (get-buffer-window out-buffer))
             (message (concat "output is on buffer " out-buffer))))))

   (when xmllint-installed
     (defun nxml-run-xmllint-shell ()
       "run an interactive xmllint shell on the FILE of the currently selected buffer"
       (interactive)
       (compile (concat "xmllint --shell " (buffer-file-name (window-buffer (minibuffer-selected-window)))) t)))
   #+END_SRC

* encryption
** epa (see 'check-installation-status *nix)
** configure pinentry
   - see ~/.gnupg/gpg-agent.conf
   - need to add the line `allow-emacs-pinentry` to gpg-agent.conf
   - killing gpg agent by `gpgconf --kill gpg-agent`, restart is automatic, as soon as it is needed
   - see [[https://help.ubuntu.com/community/GnuPrivacyGuardHowto][here]] too
   #+BEGIN_SRC emacs-lisp
   (use-package epa
     :config
     (setq epa-pinentry-mode 'loopback))
   ;; (global-visible-mark-mode -1)
   #+END_SRC
* networking
** tls
   - --tofu                 Enable trust on first use authentication
   - --strict-tofu          Fail to connect if a known certificate has changed
   - %p inserts port
   - %h inserts host
   - keys are saved in ~/.gnutls/known_hosts
   #+BEGIN_SRC emacs-lisp
   (use-package tls
     :config (when gnutls-cli-installed (add-to-list 'tls-program "gnutls-cli -p %p %h")))
   #+END_SRC
   - fetch a certificate and put it into known_hosts
   #+BEGIN_SRC sh :tangle no
   gnutls-cli --tofu -p 443 imap.gmail.com
   #+END_SRC
* browser
** w3m
   #+BEGIN_SRC emacs-lisp
   (if w3m-installed
       (use-package w3m
         :commands w3m w3m-search w3m-browse-url
         :ensure t
         :config
         (progn
           (setq w3m-default-display-inline-images t)
           (setq w3m-toggle-inline-images t))))
   #+END_SRC
* ui related stuff
** command logging
   - 'M-x command-log-mode' opens a buffer that logs all commands used
   - other functions use prefix 'clm/'
   #+BEGIN_SRC emacs-lisp
   (use-package command-log-mode
     :commands clm/toggle-command-log-buffer
     :config
     (setq command-log-mode-auto-show t))
   #+END_SRC
** inline docs
   #+BEGIN_SRC emacs-lisp
   (use-package inline-docs
     :config
     (progn
       ;; corrects version inline-docs-20170522.2150
       ;; redefinition of internal function to allow readable typescript inline display of flycheck errors (otherwise they are rendered in dimgray which is not helpful)
       (defun inline-docs--string-display (string apply-face)
         "Show STRING contents below point line until next command with APPLY-FACE."
         (let* ((border-line (make-string (window-body-width) inline-docs-border-symbol))
                (offset (make-string
                         (if (= (current-indentation) 0) ; fix (wrong-type-argument wholenump -1) when current indentation is 0 minus 1 will caused wholenump exception.
                             (current-indentation)
                           (- (current-indentation) 1))
                         inline-docs-prefix-symbol))
                (str (concat (propertize border-line
                                         'face 'inline-docs-border-face)
                             "\n"
                             offset
                             (propertize (concat inline-docs-indicator-symbol " ")
                                         'face 'inline-docs-indicator-face)
                             ;; GBA CHANGE { propertize text if no text properties are present
                             (if (next-property-change 0 string)
                                 (copy-sequence string) ; original eldoc string with format.
                               (propertize string 'face 'inline-docs-face))
                             ;; GBA CHANGE }
                             "\n"
                             (propertize border-line
                                         'face 'inline-docs-border-face)
                             "\n"))
                start-pos end-pos)
           (unwind-protect
               (save-excursion
                 ;; clear overlay
                 (inline-docs--clear-overlay)
                 ;; decide overlay positions
                 (cl-case inline-docs-position
                   ('above (forward-line 0))
                   ('below (forward-line)))
                 (setq start-pos (point))
                 (end-of-line)
                 (setq end-pos (point))
                 ;; create overlay
                 (setq inline-docs-overlay (make-overlay start-pos end-pos (current-buffer)))
                 ;; change the face
                 ;; (if apply-face
                 ;;     (overlay-put inline-docs-overlay 'face 'inline-docs-face))
                 ;; hide full line
                 ;; (overlay-put inline-docs-overlay 'display "")
                 ;; (overlay-put inline-docs-overlay 'display :height 20)
                 ;; pre-pend indentation spaces
                 ;; (overlay-put inline-docs-overlay 'line-prefix prefix)
                 ;; auto delete overlay
                 (overlay-put inline-docs-overlay 'evaporate t)
                 ;; display message
                 (overlay-put inline-docs-overlay 'before-string str))
             (add-hook 'post-command-hook 'inline-docs--clear-overlay))))

       ))
   #+END_SRC
** interaction log
   - start via ilog-log-buffer-mode, creates a buffer called *Emacs log*, just open it
   #+BEGIN_SRC emacs-lisp
   (use-package interaction-log
     :commands ilog-log-buffer-mode)
   #+END_SRC
** copy of window init from spacemacs
   #+BEGIN_SRC emacs-lisp
   (defvar gb--after-display-system-init-list '()
     "List of functions to be run after the display system is initialized.")

   (defadvice server-create-window-system-frame
       (after gb-init-display activate)
     "After Emacs server creates a frame, run functions queued in
   `GB--AFTER-DISPLAY-SYSTEM-INIT-LIST' to do any setup that needs to have
   the display system initialized."
     (progn
       (dolist (fn (reverse gb--after-display-system-init-list))
         (funcall fn))
       (ad-disable-advice 'server-create-window-system-frame
                          'after
                          'gb-init-display)
       (ad-activate 'server-create-window-system-frame)))

   (defmacro gb/do-after-display-system-init (&rest body)
     "If the display-system is initialized, run `BODY', otherwise,
   add it to a queue of actions to perform after the first graphical frame is
   created."
     `(let ((init (cond ((boundp 'ns-initialized) ns-initialized)
                        ;; w32-initialized gets set too early, so
                        ;; if we're on Windows, check the list of fonts
                        ;; instead (this is nil until the graphics system
                        ;; is initialized)
                        ((boundp 'w32-initialized) (font-family-list))
                        ((boundp 'x-initialized) x-initialized)
                        ;; fallback to normal loading behavior only if in a GUI
                        (t (display-graphic-p)))))
        (if init
            (progn
              ,@body)
          (push (lambda () ,@body) gb--after-display-system-init-list))))
   #+END_SRC
** winner mode
   - undo/redo window configuration with C-c <left> and C-c <right>
   #+BEGIN_SRC emacs-lisp
   (winner-mode 1)
   #+END_SRC
** minibuffer
   #+BEGIN_SRC emacs-lisp
   (setq enable-recursive-minibuffers t)
   (minibuffer-depth-indicate-mode 1)
   #+END_SRC
** jumpy scrolling
   - some settings that makes scrolling a bit more what is actually wanted
   #+BEGIN_SRC emacs-lisp
   (progn
     (setq-default scroll-up-aggressively 0.01
                   scroll-down-aggressively 0.01)
     (setq scroll-up-aggressively 0.01
           scroll-down-aggressively 0.01)
     (setq scroll-margin 0)
     ;; (setq scroll-step 1)
     (setq scroll-conservatively 10000)
     (setq auto-window-vscroll nil))
   (setq smooth-scroll/vscroll-step-size 3)
   #+END_SRC
** show menu bar (only in case of macos)
   #+BEGIN_SRC emacs-lisp
   (if (is-macos-p)
       (menu-bar-mode 1)
     (menu-bar-mode -1))
   #+END_SRC
** remove scroll bars
   #+BEGIN_SRC emacs-lisp
   (when (fboundp 'scroll-bar-mode)
     (scroll-bar-mode -1))
   #+END_SRC
** add theme
   #+BEGIN_SRC emacs-lisp
   (use-package color-theme-sanityinc-tomorrow
     :ensure color-theme-sanityinc-tomorrow
     :config
     (progn
       (load-theme 'sanityinc-tomorrow-night t)
       (custom-set-faces '(link-face ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
       (custom-set-faces '(link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e")))))))
     )

   #+END_SRC
** display symbols (pretty-mode, prettify-greek)
   #+BEGIN_SRC emacs-lisp
   (use-package pretty-mode
     :ensure pretty-mode
     :config
     (progn
       (global-pretty-mode 1)
       (global-prettify-symbols-mode 1)
       (setq prettify-symbols-unprettify-at-point t)

       ;; make sure this does not collide with symbols from fira code symbol replacement (ligatures)
       (pretty-deactivate-groups
        '(:equality :ordering :ordering-double :ordering-triple
                    :arrows :arrows-twoheaded :punctuation :arithmetic :arithmetic-double))
       (pretty-activate-groups
        '(:sub-and-superscripts :greek :arithmetic-nary))
       ))

   (use-package prettify-greek
     :ensure prettify-greek) ;; prettify greek symbols
   #+END_SRC
** font related stuff
   #+BEGIN_SRC emacs-lisp
   (setq font-lock-support-mode 'jit-lock-mode)
   (setq jit-lock-stealth-time 8
         jit-lock-defer-contextually t
         jit-lock-stealth-nice 1)
   (setq-default font-lock-multiline t)

   (setq gb/default-font "Source Code Pro")
   ;; (setq gb/default-font "Fira Code")
   ;; (setq gb/default-font "Cousine")

   (when (not (member gb/default-font (font-family-list)))
     (message (concat "WARNING: expected font '" gb/default-font "' not found in available font list.")))

   (require 'ht)
   (defun gb/get-font-heights (display-width win-system)
     "Get font heights depending on display width"
     (if (memq win-system '(mac ns))
         (cond ((> display-width 3400)
                (ht ('default-height 150) ('variable-pitch-height 160)))
               ((ht ('default-height 130) ('variable-pitch-height 140))))
       (cond ((> display-width 5000)
              (ht ('default-height 300) ('variable-pitch-height 300)))
             ((> display-width 3400)
              (ht ('default-height 130) ('variable-pitch-height 130)))
             ((ht ('default-height 110) ('variable-pitch-height 110))))))

   (defun gb/get-font-weights (win-system)
     "Get font weights depending on windowing system"
     (if (memq win-system '(mac ns))
         (ht ('default-weight 'light) ('variable-pitch-weight 'regular))
       (ht ('default-weight 'regular) ('variable-pitch-weight 'regular))))

   (setq gb/setup-main-fonts-needs-execution t)
   (defun gb/setup-main-fonts (&optional frame)
     "Set up default fonts.

     Use DEFAULT-HEIGHT for default face and VARIABLE-PITCH-HEIGHT
     for variable-pitch face."
     (if gb/setup-main-fonts-needs-execution
         (let* ((attr-map (ht-merge (gb/get-font-heights (x-display-pixel-width) window-system)
                                    (gb/get-font-weights window-system))))
           (message "setting up default fonts")
           (message (format "display pixel width %d" (x-display-pixel-width)))
           (set-face-attribute 'default nil
                               :family gb/default-font
                               :height (ht-get attr-map 'default-height)
                               :weight (ht-get attr-map 'default-weight))
           (set-face-attribute 'variable-pitch nil
                               ;; :family "Fira Sans"
                               :height (ht-get attr-map 'variable-pitch-height)
                               :weight (ht-get attr-map 'variable-pitch-weight))
           (setq gb/setup-main-fonts-needs-execution nil))))

   (defun gb/reset-main-fonts ()
     "reinitialize fonts e.g. if resolution changed etc."
     (interactive)
     (setq gb/setup-main-fonts-needs-execution t)
     (gb/setup-main-fonts))

   ;; (gb/setup-main-fonts)
   (gb/do-after-display-system-init (gb/setup-main-fonts))
   ;;(add-hook 'after-make-frame-functions #'gb/setup-main-fonts)
   ;;(add-hook 'focus-in-hook #'gb/setup-main-fonts)
   ;;(when (display-graphic-p)
   ;;  (gb/setup-main-fonts))

   ;; (if after-init-time
   ;;     (gb/setup-main-fonts)
   ;;   (add-hook 'after-init-hook 'gb/setup-main-fonts))

   #+END_SRC
   - install ligatures via fira code symbol (had to install [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][fira code symbol]] for the following to work)
     #+BEGIN_SRC emacs-lisp
     (setq gb/setup-ligatures-needs-execution t)
     (defun gb/setup-ligatures (&optional frame) "setup ligatures"
            (if gb/setup-ligatures-needs-execution
                (progn
                  (setq fira-code-symbol-installed (member "Fira Code Symbol" (font-family-list)))

                  (if (not fira-code-symbol-installed)
                      (message "WARNING: Fira code symbol not installed. Ligatures will not be available."))

                  (when fira-code-symbol-installed
                    (message "setting up ligatures")
                    ;; Fira code
                    ;; This works when using emacs --daemon + emacsclient
                    ;; (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
                    ;; This works when using emacs without server/client
                    (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
                    ;; I haven't found one statement that makes both of the above situations work, so I use both for now

                    (defconst fira-code-font-lock-keywords-alist
                      (mapcar (lambda (regex-char-pair)
                                `(,(car regex-char-pair)
                                  (0 (prog1 ()
                                       (compose-region (match-beginning 1)
                                                       (match-end 1)
                                                       ;; The first argument to concat is a string containing a literal tab
                                                       ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
                              '(("\\(www\\)"                   #Xe100)
                                ;; ("[^/\\*]\\(\\*\\*\\)[^\\*/]"        #Xe101) ;; double **
                                ;; ("\\(\\*\\*\\*\\)"             #Xe102) ;; triple stars ***
                                ;; ("\\(\\*\\*/\\)"               #Xe103) ;; double comment end **/
                                ;; ("\\(\\*>\\)"                  #Xe104)
                                ;; ("[^*]\\(\\*/\\)"              #Xe105) ;; single comment end */
                                ("\\(*\\)" #Xe16f) ;; single *
                                ("\\(\\\\\\\\\\)"              #Xe106)
                                ("\\(\\\\\\\\\\\\\\)"          #Xe107)
                                ("\\({-\\)"                    #Xe108)
                                ;; ("\\(\\[\\]\\)"                #Xe109) ;; []
                                ("\\(::\\)"                    #Xe10a)
                                ("\\(:::\\)"                   #Xe10b)
                                ("[^=]\\(:=\\)"                #Xe10c)
                                ("\\(!!\\)"                    #Xe10d)
                                ("\\(!=\\)"                    #Xe10e)
                                ("\\(!==\\)"                   #Xe10f)
                                ("\\(-}\\)"                    #Xe110)
                                ("\\(--\\)"                    #Xe111)
                                ("\\(---\\)"                   #Xe112)
                                ("\\(-->\\)"                   #Xe113)
                                ("[^-]\\(->\\)"                #Xe114)
                                ("\\(->>\\)"                   #Xe115)
                                ("[^<-]\\(-<\\)[^<>]"                    #Xe116)
                                ("\\(-<<\\)"                   #Xe117)
                                ("\\(-~\\)"                    #Xe118)
                                ("\\(#{\\)"                    #Xe119)
                                ("\\(#\\[\\)"                  #Xe11a)
                                ("\\(##\\)"                    #Xe11b)
                                ("\\(###\\)"                   #Xe11c)
                                ("\\(####\\)"                  #Xe11d)
                                ("\\(#(\\)"                    #Xe11e)
                                ("\\(#\\?\\)"                  #Xe11f)
                                ("\\(#_\\)"                    #Xe120)
                                ("\\(#_(\\)"                   #Xe121)
                                ("\\(\\.-\\)"                  #Xe122)
                                ("\\(\\.=\\)"                  #Xe123)
                                ("\\(\\.\\.\\)"                #Xe124)
                                ("\\(\\.\\.<\\)"               #Xe125)
                                ("\\(\\.\\.\\.\\)"             #Xe126)
                                ("\\(\\?=\\)"                  #Xe127)
                                ("\\(\\?\\?\\)"                #Xe128)
                                ("\\(;;\\)"                    #Xe129)
                                ;; ("\\(/\\*\\)"                  #Xe12a)
                                ;; ("\\(/\\*\\*\\)"               #Xe12b)
                                ("\\(/=\\)[^=]"                    #Xe12c)
                                ("\\(/==\\)"                   #Xe12d)
                                ("[^<]\\(/>\\)"                    #Xe12e)
                                ("[^/]\\(//\\)[^/]"                    #Xe12f)
                                ("\\(///\\)"                   #Xe130)
                                ("\\(&&\\)"                    #Xe131)
                                ("\\(||\\)[^=]"                    #Xe132)
                                ("\\(||=\\)"                   #Xe133)
                                ("[^|]\\(|=\\)"                #Xe134)
                                ("\\(|>\\)"                    #Xe135)
                                ("\\(\\^=\\)"                  #Xe136)
                                ("\\(\\$>\\)"                  #Xe137)
                                ("\\(\\+\\+\\)"                #Xe138)
                                ("\\(\\+\\+\\+\\)"             #Xe139)
                                ("\\(\\+>\\)"                  #Xe13a)
                                ("\\(=:=\\)"                   #Xe13b)
                                ("[^!/]\\(==\\)[^>=]"           #Xe13c)
                                ("\\(===\\)"                   #Xe13d)
                                ("\\(==>\\)"                   #Xe13e)
                                ("[^=<>]\\(=>\\)[^>]"                #Xe13f)
                                ("\\(=>>\\)"                   #Xe140)
                                ("[^<>]\\(<=\\)[^=<>]"                    #Xe141)
                                ("\\(=<<\\)"                   #Xe142)
                                ("\\(=/=\\)"                   #Xe143)
                                ("\\(>-\\)"                    #Xe144)
                                ("\\(>=\\)[^>]"                    #Xe145)
                                ("\\(>=>\\)"                   #Xe146)
                                ("[^-=]\\(>>\\)"               #Xe147)
                                ("\\(>>-\\)"                   #Xe148)
                                ("\\(>>=\\)"                   #Xe149)
                                ("\\(>>>\\)"                   #Xe14a)
                                ;; ("\\(<\\*\\)[^>]"                  #Xe14b)
                                ;; ("\\(<\\*>\\)"                 #Xe14c)
                                ("\\(<|\\)[^>]"                    #Xe14d)
                                ("\\(<|>\\)"                   #Xe14e)
                                ("\\(<\\$\\)[^>]"                  #Xe14f)
                                ("\\(<\\$>\\)"                 #Xe150)
                                ("\\(<!--\\)"                  #Xe151)
                                ("\\(<-\\)[^-<>]"                    #Xe152)
                                ("\\(<--\\)"                   #Xe153)
                                ("\\(<->\\)"                   #Xe154)
                                ("\\(<\\+\\)[^>]"                  #Xe155)
                                ("\\(<\\+>\\)"                 #Xe156)
                                ("\\(<=\\)[^=<>]"                    #Xe157)
                                ("\\(<==\\)"                   #Xe158)
                                ("\\(<=>\\)"                   #Xe159)
                                ("\\(<=<\\)"                   #Xe15a)
                                ("[^-]\\(<>\\)[^-]"                    #Xe15b)
                                ("[^-=]\\(<<\\)"               #Xe15c)
                                ("\\(<<-\\)"                   #Xe15d)
                                ("\\(<<=\\)"                   #Xe15e)
                                ("\\(<<<\\)"                   #Xe15f)
                                ("\\(<~\\)[^~]"                    #Xe160)
                                ("\\(<~~\\)"                   #Xe161)
                                ("\\(</\\)[^>]"                    #Xe162)
                                ("\\(</>\\)"                   #Xe163)
                                ("\\(~@\\)"                    #Xe164)
                                ("\\(~-\\)"                    #Xe165)
                                ("\\(~=\\)"                    #Xe166)
                                ("[^<~]\\(~>\\)"                    #Xe167)
                                ("[^<]\\(~~\\)[^>]"                #Xe168)
                                ("\\(~~>\\)"                   #Xe169)
                                ("\\(%%\\)"                    #Xe16a)
                                ;;("\\(x\\)"                     #Xe16b)
                                ("[^:=]\\(:\\)[^:=]"           #Xe16c)
                                ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
                                ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

                    (defun add-fira-code-symbol-keywords ()
                      (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

                    (defun remove-fira-code-symbol-keywords ()
                      (font-lock-remove-keywords nil fira-code-font-lock-keywords-alist))

                    (defun gb/disable-ligatures ()
                      "disable ligatures"
                      (interactive)
                      (remove-fira-code-symbol-keywords)
                      (remove-hook 'prog-mode-hook
                                   #'add-fira-code-symbol-keywords)
                      (font-lock-flush)
                      (run-mode-hooks)
                      (setq ligatures-enabled nil))

                    (defun gb/enable-ligatures ()
                      "enable ligatures"
                      (interactive)
                      (add-fira-code-symbol-keywords)
                      (add-hook 'prog-mode-hook
                                #'add-fira-code-symbol-keywords)
                      (font-lock-flush)
                      (run-mode-hooks)
                      (setq ligatures-enabled t))

                    (defun gb/toggle-ligatures ()
                      "toggle display of ligatures in progmode"
                      (interactive)
                      (if ligatures-enabled
                          (progn
                            (gb/disable-ligatures)
                            (message "disabled ligatures."))
                        (progn
                          (gb/enable-ligatures)
                          (message "enabled ligatures."))))

                    (gb/enable-ligatures)
                    (message "enabled ligatures.")
                    (setq gb/setup-ligatures-needs-execution nil)))))

     (gb/do-after-display-system-init (gb/setup-ligatures))
     ;; (add-hook 'focus-in-hook #'gb/setup-ligatures)
     ;; (add-hook 'after-make-frame-functions #'gb/setup-ligatures)
     ;; (when (display-graphic-p)
     ;;   (gb/setup-ligatures))

     #+END_SRC
** sublimity (smooth scrolling)
   #+BEGIN_SRC emacs-lisp
   (use-package sublimity
     :config
     (progn
       ;; enable smooth scrolling
       (require 'sublimity-scroll)

       (defun gb/enable-sublimity-mode ()
         "do not enable sublimity mode for a certain list of modes"
         (if (memq major-mode (list 'ansi-term-mode 'term-mode 'shell-mode))
             (sublimity-mode -1)
           (sublimity-mode 1)))
       ;; (add-hook 'after-change-major-mode-hook #'gb/enable-sublimity-mode)
       (setq sublimity-scroll-drift-length 4)
       (setq sublimity-scroll-weight 4.0)
       ;; minimap is explicitly not enabled, since another minimap-mode is used for that
       ;; enable minimap
       ;; (require 'sublimity-map)
       ;; show minimap after x seconds of inactivity
       ;; (sublimity-map-set-delay 3)
       ))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp
   ;; Changes all yes/no questions to y/n type
   (defalias 'yes-or-no-p 'y-or-n-p)

   (setq-default line-spacing 1)

   ;; These settings relate to how emacs interacts with your operating system
   (setq ;; makes killing/yanking interact with the clipboard
    select-enable-clipboard t

    ;; use primary selection for cut/paste
    select-enable-primary t

    ;; Save clipboard strings into kill ring before replacing them.
    ;; When one selects something in another program to paste it into Emacs,
    ;; but kills something in Emacs before actually pasting it,
    ;; this selection is gone unless this variable is non-nil
    save-interprogram-paste-before-kill t

    ;; Shows all options when running apropos. For more info,
    ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html
    apropos-do-all t

    ;; Mouse yank commands yank at point instead of at click.
    mouse-yank-at-point t)

   ;; No cursor blinking, it's distracting
   (blink-cursor-mode 0)

   ;; make cursor the width of the character it is under
   ;; i.e. full width of a TAB
   (setq x-stretch-cursor t)

   ;; full path in title bar
   (setq-default frame-title-format "%b (%f)")

   (setq visible-bell 1)
   #+END_SRC
** window/frame
   #+BEGIN_SRC emacs-lisp
   ;; do window enlarge and shrink
   (defun shrink-window-horizontally-effect ()
     "shrink window within a frame with visual effect"
     (interactive)
     (save-excursion
       (let ((speeds '(4 4 4)))
         (dolist (speed speeds)
           (shrink-window-horizontally speed)
           (force-window-update (selected-window))
           (redisplay)))))

   (defun enlarge-window-horizontally-effect ()
     "enlarge window within frame with visual effect"
     (interactive)
     (save-excursion
       (let ((speeds '(4 4 4)))
         (dolist (speed speeds)
           (enlarge-window-horizontally speed)
           (force-window-update (selected-window))
           (redisplay)))))

   (defun enlarge-window-effect ()
     "enlarge window vertically with visual effect"
     (interactive)
     (save-excursion
       (let ((speeds '(1 1 1 1)))
         (dolist (speed speeds)
           (enlarge-window speed)
           (force-window-update (selected-window))
           (redisplay)))))

   (defun shrink-window-effect ()
     "shrink window vertically with visual effect"
     (interactive)
     (save-excursion
       (let ((speeds '(1 1 1 1)))
         (dolist (speed speeds)
           (shrink-window speed)
           (force-window-update (selected-window))
           (redisplay)))))

   (defun balance-windows-respecting-speedbar ()
     "balance all windows but make sure that speedbar is sized to 50 width"
     (interactive)
     (balance-windows)
     (with-selected-window (get-buffer-window "*SPEEDBAR*")
       (let ((delta (- 50 (window-width (selected-window)))))
         (if (< 0 delta)
             (shrink-window-horizontally (- delta))
           (enlarge-window-horizontally delta)))))

   ;; make sure that macos mouse scrolling is not too jerky
   (setq mouse-wheel-scroll-amount '(0.01))
   #+END_SRC
** maxframe
   #+BEGIN_SRC emacs-lisp
   (use-package maxframe
     :config
     (progn
       ;; remove defined alias
       (defalias 'mf nil)))
   #+END_SRC
** transpose frame
   #+BEGIN_SRC emacs-lisp
   (use-package transpose-frame
     :bind (
            ("C-s-+" . flip-frame) ;; exchange top with bottom windows (german layout)
            ("C-s-]" . flip-frame) ;; us layout
            ("C-s-#" . flop-frame) ;; exchange right with left windows
            ("C-s-'" . flop-frame) ;; us layout
            ("C-s--" . transpose-frame) ;; exchange splitted vertically with splitted horizontally window
            ("C-s-/" . transpose-frame) ;; us layout
            )
     :ensure t)
   #+END_SRC
** bind-key
   #+BEGIN_SRC emacs-lisp
   ;; set global keys for window management
   (use-package bind-key
     :after ( ibuffer windmove)
     :config
     (progn

       ;; select window (left,right,up or down) relative to current window
       (bind-key "s-<left>" 'windmove-left)
       (bind-key "s-<right>" 'windmove-right)
       (bind-key "s-<up>" 'windmove-up)
       (bind-key "s-<down>" 'windmove-down)
       ;; shrink selected window horizontally
       (bind-key "C-s-<left>" 'shrink-window-horizontally-effect)
       ;; enlarge selected window horizontally
       (bind-key "C-s-<right>" 'enlarge-window-horizontally-effect)
       ;; shrink selected window vertically
       (bind-key "C-s-<down>" 'shrink-window-effect)
       ;; enlarge slected window vertically
       (bind-key "C-s-<up>" 'enlarge-window-effect)

       ;; maximize selected window
       (bind-key "C-s-<return>" 'maximize-window)
       ;; balance all windows and the set speedbar to 50 width
       (bind-key "C-s-<backspace>" 'balance-windows-respecting-speedbar)

       ;; Key binding to use "hippie expand" for text autocompletion
       ;; http://www.emacswiki.org/emacs/HippieExpand
       (bind-key "s-7" 'hippie-expand)
       ;; Interactive search key bindings. By default, C-s runs
       ;; isearch-forward, so this swaps the bindings.
       (bind-key "C-s" 'isearch-forward-regexp) ;; currently shadowed by visual-regexp (in test)
       (bind-key "C-r" 'isearch-backward-regexp) ;; currently shadowed by visual-regexp (in test)
       ;; (bind-key "C-M-s" 'isearch-forward)
       ;; (bind-key "C-M-r" 'isearch-backward)

       ;; indent relative to the stuff on the previous line
       ;; overwrite (hide) original binding M-i tab-to-tab-stop
       ;; (global-set-key (kbd "M-i") 'indent-relative)
       (bind-key "M-i" 'indent-relative)


       (bind-key "C-c RET" 'remove-dos-eol)
       (bind-key "C-c <C-return>" 'remove-dos-eol)

       (bind-key "C-x C-c" 'dont-kill-emacs)

       (bind-key "s-+" 'decrease-transparency)
       (bind-key "s--" 'increase-transparency)
       (bind-key "s-#" 'disable-transparency)
       (bind-key "s-]" 'decrease-transparency)
       (bind-key "s-'" 'increase-transparency)
       (bind-key "s-/" 'disable-transparency)

       (bind-key "C-;" 'toggle-comment-on-line)

       (bind-key "C-x b" 'ibuffer-list-buffers-and-switch)

       ;; make sure that C-g behaves just as helm-buffer, aborting the buffer switch
       ;; TODO ibuffer mode map not known yet
       ;; (bind-key "C-g" 'quit-window ibuffer-mode-map)

       (bind-key "<s-up>" 'scroll-up-line)
       (bind-key "<s-down>" 'scroll-down-line)
       (bind-key "<M-s-up>" 'scroll-up-line-7)
       (bind-key "<M-s-down>" 'scroll-down-line-7)

       (bind-key "<s-C-up>" 'scroll-up-line-and-move-cursor)
       (bind-key "<s-C-down>" 'scroll-down-line-and-move-cursor)

       (bind-key "<s-C-M-up>" 'scroll-up-line-and-move-cursor-7)
       (bind-key "<s-C-M-down>" 'scroll-down-line-and-move-cursor-7)

       (bind-key "C-h C-m" 'discover-my-major)))
   #+END_SRC
** symon sytem stats (for minibuffer)
   #+BEGIN_SRC emacs-lisp
   (use-package symon
     ;; :commands symon-mode
     :config
     (progn
       ;; make sure to load it
       (require 'symon)

       (setq symon-sparkline-width 20)
       (setq symon-history-size 20)
       (setq symon-sparkline-use-xpm t)
       (setq symon-network-rx-upper-bound 1100)))

   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package symon
     ;; :commands symon-mode
     :config
     (progn
       ;; make sure to load it
       (require 'symon)

       (setq symon-sparkline-width 50)
       (setq symon-history-size 50)
       (setq symon-sparkline-use-xpm t)
       (setq symon-network-rx-upper-bound 1100)

       (defmacro define-symon-monitor (name &rest plist)
         "define a new symon monitor NAME. following keywords are
   supoprted in PLIST:

   :setup (default: nil)

       an expression evaluated when activating symon-mode, and
       expected to do some preparation.

   :cleanup (default: nil)

       an expression evaluated when deactivating symon-mode, and
       expected to do some cleanup.

   :fetch (default: nil)

       an expression that evaluates to the latest status value. the
       value must be a number (otherwise `N/A' is displayed as the
       value).

   :interval (default: symon-refresh-rate)

       fetch interval in seconds.

   :index (default: \"\")

       string prepended to the status value (\"MEM:\" for memory
       monitor, for example).

   :unit (default: \"\")

       string appended to the status value (\"%\" for memory
       monitor, for example).

   :annotation (default: nil)

       an expression that evaluates to the annotation string for the
       metrics (\"xxxKB Swapped\" for memory monitor, for
       example). if this expression returns a non-nil value, it is
       surrounded with parentheses and appended to the status value.

   :display (default: nil)

       an expression evaluated before updating symon display. when
       this expression evaluates to a non-nil value, it will be
       displayed instead of standard symon display format.

   :sparkline (default: nil)

       when non-nil, sparklines are rendered.

   :lower-bound (default: 100.0)

       upper bound of sparkline.

   :upper-bound (default: 0.0)

       lower bound of sparkline."
         (let* ((cell (make-vector 2 nil))
                (sparkline (plist-get plist :sparkline))
                (interval (or (plist-get plist :interval) 'symon-refresh-rate))
                (display (plist-get plist :display))
                (update-fn
                 `(lambda ()
                    (ring-insert (aref ,cell 0) ,(plist-get plist :fetch))))
                (setup-fn
                 `(lambda ()
                    (aset ,cell 0 (symon--make-history-ring))
                    (aset ,cell 1 (run-with-timer 0 ,interval ,update-fn))
                    ,(plist-get plist :setup)
                    (funcall ,update-fn)))
                (cleanup-fn
                 `(lambda ()
                    (cancel-timer (aref ,cell 1))
                    ,(plist-get plist :cleanup)))
                (display-fn
                 (if display `(lambda () (concat ,display " "))
                   `(lambda ()
                      (let* ((lst (ring-elements (aref ,cell 0)))
                             (val (car lst)))
                        (concat ,(plist-get plist :index)
                                ;; (if (not (numberp val)) "N/A "
                                ;;   (concat (format "%d%s " val ,(or (plist-get plist :unit) ""))
                                ;;           (let ((annot ,(plist-get plist :annotation)))
                                ;;             (when annot (concat "(" annot ") ")))))
                                ,(when sparkline
                                   `(when (window-system)
                                      (let ((sparkline (symon--make-sparkline
                                                        lst
                                                        ,(plist-get plist :lower-bound)
                                                        ,(plist-get plist :upper-bound))))
                                        (when symon-sparkline-use-xpm
                                          (setq sparkline
                                                (symon--convert-sparkline-to-xpm sparkline)))
                                        (concat (propertize " " 'display sparkline) " "))))))))))
           `(put ',name 'symon-monitor (vector ,setup-fn ,cleanup-fn ,display-fn))))

       (define-symon-monitor symon-linux-cpu-monitor
         :index "C-" :unit "%" :sparkline t
         :setup (setq symon-linux--last-cpu-ticks nil)
         :fetch (cl-destructuring-bind (cpu)
                    (symon-linux--read-lines
                     "/proc/stat" (lambda (str) (mapcar 'read (split-string str nil t))) '("cpu"))
                  (let ((total (apply '+ cpu)) (idle (nth 3 cpu)))
                    (prog1 (when symon-linux--last-cpu-ticks
                             (let ((total-diff (- total (car symon-linux--last-cpu-ticks)))
                                   (idle-diff (- idle (cdr symon-linux--last-cpu-ticks))))
                               (unless (zerop total-diff)
                                 (/ (* (- total-diff idle-diff) 100) total-diff))))
                      (setq symon-linux--last-cpu-ticks (cons total idle))))))

       (define-symon-monitor symon-linux-memory-monitor
         :index "M-" :unit "%" :sparkline t
         :fetch (cl-destructuring-bind (memtotal memavailable memfree buffers cached)
                    (symon-linux--read-lines
                     "/proc/meminfo" (lambda (str) (and str (read str)))
                     '("MemTotal:" "MemAvailable:" "MemFree:" "Buffers:" "Cached:"))
                  (if memavailable
                      (/ (* (- memtotal memavailable) 100) memtotal)
                    (/ (* (- memtotal (+ memfree buffers cached)) 100) memtotal)))
         :annotation (cl-destructuring-bind (swaptotal swapfree)
                         (symon-linux--read-lines
                          "/proc/meminfo" 'read '("SwapTotal:" "SwapFree:"))
                       (let ((swapped (/ (- swaptotal swapfree) 1000)))
                         (unless (zerop swapped) (format "%dMB Swapped" swapped)))))

       (define-symon-monitor symon-linux-battery-monitor
         :index "BAT:" :unit "%" :sparkline t
         :fetch (when battery-status-function
                  (read (cdr (assoc ?p (funcall battery-status-function))))))

       (define-symon-monitor symon-linux-network-rx-monitor
         :index "R-" :unit "KB/s" :sparkline t
         :upper-bound symon-network-rx-upper-bound
         :lower-bound symon-network-rx-lower-bound
         :setup (setq symon-linux--last-network-rx nil)
         :fetch (with-temp-buffer
                  (insert-file-contents "/proc/net/dev")
                  (goto-char 1)
                  (let ((rx 0))
                    (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
                      (unless (string= (match-string 1) "lo")
                        (setq rx (+ rx (read (current-buffer))))))
                    (prog1 (when symon-linux--last-network-rx
                             (/ (- rx symon-linux--last-network-rx) symon-refresh-rate 1000))
                      (setq symon-linux--last-network-rx rx)))))

       (define-symon-monitor symon-linux-network-tx-monitor
         :index "T-" :unit "KB/s" :sparkline t
         :upper-bound symon-network-tx-upper-bound
         :lower-bound symon-network-tx-lower-bound
         :setup (setq symon-linux--last-network-tx nil)
         :fetch (with-temp-buffer
                  (insert-file-contents "/proc/net/dev")
                  (goto-char 1)
                  (let ((tx 0))
                    (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
                      (unless (string= (match-string 1) "lo")
                        (forward-word 8)
                        (setq tx (+ tx (read (current-buffer))))))
                    (prog1 (when symon-linux--last-network-tx
                             (/ (- tx symon-linux--last-network-tx) symon-refresh-rate 1000))
                      (setq symon-linux--last-network-tx tx)))))

       (defun symon--make-sparkline (list &optional minimum maximum)
         "make sparkline image from LIST."
         (let ((num-samples (length list)))
           (unless (zerop num-samples)
             (let* ((image-data (symon--get-sparkline-base))
                    (maximum (if maximum (float maximum) 100.0))
                    (minimum (if minimum (float minimum) 0.0))
                    (topmargin (1- symon-sparkline-thickness))
                    (height (- symon-sparkline-height topmargin))
                    (height-per-point (/ height (1+ (- maximum minimum))))
                    (width-per-sample (/ symon-sparkline-width (float num-samples)))
                    (samples (apply 'vector list))
                    sample y ix)
               (dotimes (x symon-sparkline-width)
                 (setq sample (aref samples (floor (/ x width-per-sample))))
                 (when (numberp sample)
                   (setq y (floor (* (- sample minimum) height-per-point)))
                   (when (and (<= 0 y) (< y height))
                     (dotimes (dy symon-sparkline-thickness)
                       (aset image-data
                             (+ (* (- symon-sparkline-height (+ y dy) 1) symon-sparkline-width) x)
                             t)))))
               `(image :type xbm :data ,image-data :ascent ,symon-sparkline-ascent
                       :height ,symon-sparkline-height :width ,symon-sparkline-width :foreground "#ff8c00")))))

       (defun symon--convert-sparkline-to-xpm (sparkline)
         "convert sparkline to an xpm image."
         (let ((data (plist-get (cdr sparkline) :data)))
           (with-temp-buffer
             (insert (format "/* XPM */
        static char * sparkline_xpm[] = { \"%d %d 2 1\", \"@ c %s\", \". c none\""
                             symon-sparkline-width symon-sparkline-height
                             "#ff8c00"))
             (let ((ix 0))
               (dotimes (x symon-sparkline-height)
                 (insert ",\n\"")
                 (dotimes (y symon-sparkline-width)
                   (insert (if (aref data ix) ?@ ?.))
                   (setq ix (1+ ix)))
                 (insert "\"")))
             (insert "};")
             `(image :type xpm :data ,(buffer-string) :ascent ,symon-sparkline-ascent
                     :height ,symon-sparkline-height :width ,symon-sparkline-width))))




       ;; (defun symon--initialize ()
       ;;   (unless symon-monitors
       ;;     (message "Warning: `symon-monitors' is empty."))
       ;;   (let* ((symon-monitors                ; for backward-compatibility
       ;;           (if (symbolp (car symon-monitors))
       ;;               (list symon-monitors)
       ;;             symon-monitors))
       ;;          (monitors
       ;;           (mapcar (lambda (lst)
       ;;                     (mapcar (lambda (s) (get s 'symon-monitor)) lst))
       ;;                   symon-monitors))
       ;;          (monitors-flattened
       ;;           (symon--flatten monitors)))
       ;;     (mapc (lambda (m) (funcall (aref m 0))) monitors-flattened) ; setup-fns
       ;;     (setq symon--cleanup-fns    (mapcar (lambda (m) (aref m 1)) monitors-flattened)
       ;;           symon--display-fns    (mapcar (lambda (l) (mapcar (lambda (m) (aref m 2)) l)) monitors)
       ;;           symon--display-active nil
       ;;           symon--total-page-num (length symon-monitors)
       ;;           symon--timer-objects
       ;;           (list (run-with-timer 0 symon-refresh-rate 'symon--redisplay)
       ;;                 (run-with-idle-timer symon-delay t 'symon-display)))))

       ;; (defun symon-display ()
       ;;   "activate symon display."
       ;;   (interactive)
       ;;   (setq symon--active-page 0)
       ;;   (force-mode-line-update t))

       ;; (defun symon--redisplay ()
       ;;   "update symon display."
       ;;   (when symon--display-active
       ;;     (setq symon--active-page (% (1+ symon--active-page) symon--total-page-num))
       ;;     (force-mode-line-update t)))


       ;; (defun symon--cleanup ()
       ;;   (mapc 'cancel-timer symon--timer-objects)
       ;;   (mapc 'funcall symon--cleanup-fns))


       ;; redefine to display right aligned
       (defun symon--display-update ()
         "update symon display"
         (unless (or cursor-in-echo-area (active-minibuffer-window))
           (let ((message-log-max nil)  ; do not insert to *Messages* buffer
                 (display-string nil)
                 (page 0))
             (dolist (lst symon--display-fns)
               (if (= page symon--active-page)
                   (let* ((fheight (ht-get (gb/get-font-heights (x-display-pixel-width) window-system) 'default-height))
                          (spaces (floor (- (/ (frame-pixel-width) 10) (- fheight 110)))))
                     (message (concat (make-string  spaces ? ) "%s") (apply 'concat (mapcar 'funcall lst))))
                 (mapc 'funcall lst))
               (setq page (1+ page))))
           (setq symon--display-active t)))
       ;; then redefine with alternate cpu benchmark (dividing cpu mark by 8 cores)
       (defun symon-darwin--maybe-start-process ()
         (symon--maybe-start-process (format "
             while true; do
                 echo \"----\"

                 interface=`route get 0.0.0.0 | grep interface | awk '{print $2}'`
                 s=`netstat -bi -I $interface | tail -1`;
                 echo $s | awk '{print \"rx:\"$7}'
                 echo $s | awk '{print \"tx:\"$8}'

                 s=`ps -e -o %%cpu | awk '{x+=$1} END {print x/8}' | sed 's/,.*//'`           ### cpu number is 8 => /8
                 echo \"cpu:$s\"

                 m1=`sysctl hw.memsize | sed 's/.*:\s*//'`
                 m_active=`vm_stat | grep 'Pages active' | sed 's/.*: *//'`
                 m_wired=`vm_stat | grep 'Pages wired' | sed 's/.*: *//'`

                 s=`echo \"scale=2; (($m_active+$m_wired)*4096*100 / $m1)\"| bc -l`
                 echo \"mem:$s\"

                 sleep %d
             done" symon-refresh-rate)))

       (setq symon-sparkline-type 'boxed)
       ;; (symon-mode 1)
       ))
   #+END_SRC
** modeline
*** spinner (busy indicator for modeline)
    - (spinner-start 'vertical-breathing 10)
    - (spinner-start 'minibox)
    - (spinner-start 'moon)
    - (spinner-start 'triangle)
    #+BEGIN_SRC emacs-lisp
    (use-package spinner)
    #+END_SRC
*** spaceline (mode line of spacemacs)
    #+BEGIN_SRC emacs-lisp
    (when gb/use-space-line
      (use-package spaceline
        :ensure spaceline
        :after ( powerline) ;; symon
        :config
        ;; Valid Values: alternate, arrow, arrow-fade, bar, box, brace,
        ;; butt, chamfer, contour, curve, rounded, roundstub, wave, zigzag,
        ;; utf-8
        (setq powerline-default-separator nil) ;;'utf-8

        (require 'spaceline-config)
        (spaceline-spacemacs-theme)
        (spaceline-helm-mode)
        (custom-set-faces
         '(spaceline-highlight-face ((t (:background "DarkGoldenrod3" :foreground "#000000" :inherit (quote mode-line))))))

        (gb/do-after-display-system-init

         (setq gb/mode-line-buffer-read-only-symbol (if fira-code-symbol-installed "\ue0a2" "o"))  ;; ""
         (setq gb/mode-line-buffer-modified-ro-symbol (if fira-code-symbol-installed "\ue16b" "x"))  ;; ""
         (setq gb/mode-line-buffer-modified-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
         (setq gb/mode-line-branch-up-to-date-symbol "\u2713")  ;; "✓"
         (setq gb/mode-line-branch-edited-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
         (setq gb/mode-line-cutted-path-prefix-symbol "\u2025") ;; "…"

         (defun gb/symon-display-str ()
           "update symon display"
           (let ((message-log-max nil)  ; do not insert to *Messages* buffer
                 (display-string nil)
                 (page 0)
                 (displaystr ""))
             (dolist (lst symon--display-fns)
               (if (= page symon--active-page)
                   (setq displaystr (apply 'concat (mapcar 'funcall lst)))
                 (mapc 'funcall lst))
               (setq page (1+ page)))
             displaystr)
           )

         (spaceline-define-segment gb/symon
           ""
           "" ;;(gb/symon-display-str)
           )

         (spaceline-define-segment gb/buffer-status
           "Buffer status (read-only, modified), with color"
           (cond ((and buffer-read-only (buffer-modified-p)) gb/mode-line-buffer-modified-ro-symbol)
                 (buffer-read-only gb/mode-line-buffer-read-only-symbol)
                 ((buffer-modified-p) gb/mode-line-buffer-modified-symbol)
                 (t " ")))

         (spaceline-define-segment gb/date-and-cw
           "display date and calendar week of window is broad enough"
           (if (> (window-width) 150)
               (propertize (format-time-string "%m-%d/%V")
                           'help-echo "month-day/calendarweek")
             ""))

         (spaceline-define-segment gb/buffer-id
           (propertize (buffer-name) 'help-echo (format "%s, size: %s" (buffer-name) (number-to-string (buffer-size)))))

         (spaceline-define-segment gb/buffer-file-name
           "provide fullpath to buffer file name, shortened to 35 characters if too long"
           ;; limit path length to a certain number of characters (currently 35)
           ;; TODO: allow replacing certain paths with some shorthands (e.g. :doc: for ~/Documents/)
           (let* ((path (replace-regexp-in-string (concat "^" (regexp-quote (expand-file-name "~"))) "~" (or (file-name-directory (or buffer-file-name "")) "")))
                  (maxlen (max 0 (- (window-width) 57 (length (buffer-name)))))
                  (spath (cond ((>= 0 maxlen) "")
                               ((> (length path) maxlen)
                                (concat gb/mode-line-cutted-path-prefix-symbol (substring path (- maxlen) nil)))
                               (t path))))
             (propertize spath 'help-echo path))
           ;;     (or spath "")
           )

         (defun parent-dir-of (directory)
           "parrent directory of the given"
           (s-join "/" (-drop-last 1 (s-split "/" directory))))

         (defun file-exists-up-the-tree (directory filename)
           "does the given file exist in this directory or anywhere up to the root?"
           (or (file-exists-p (concat directory "/" filename))
               (and (not (or (string= "/" directory)
                             (string-empty-p directory)))
                    (file-exists-up-the-tree (parent-dir-of directory) filename))))

         (defun gb/in-git-dir-p ()
           (or
            (and (buffer-file-name) (file-exists-up-the-tree (file-name-directory (buffer-file-name)) ".git"))
            (not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir")))))

         (defun gb/vc-status ()
           (if vc-mode
               vc-mode
             (concat "\ue0a0 " (car (split-string (shell-command-to-string "git rev-parse --abbrev-ref HEAD"))))))

         (setq gb/vc-status-cache-delay "10 sec")
         (setq gb/vc-status-cache-buffer-id nil)
         (setq gb/vc-status-cache nil)
         (setq gb/vc-status-cache-timer nil)

         (defun gb/get-cached-git-state ()
           "if cache filled and within same buffer (name) refresh in five seconds and return cached value, else refresh cache and return new values"
           (if (and gb/vc-status-cache (string= (buffer-name) gb/vc-status-cache-buffer-id))
               ;; only if no timer is running!
               (unless gb/vc-status-cache-timer
                 (setq gb/vc-status-cache-timer (run-at-time gb/vc-status-cache-delay nil 'gb/refresh-vc-status-cache)))
             (gb/refresh-vc-status-cache))
           gb/vc-status-cache)

         (defun gb/refresh-vc-status-cache ()
           "refresh values with actual git call and clear timer (maybe cancel?)"
           (setq gb/vc-status-cache-buffer-id (buffer-name))
           (setq gb/vc-status-cache (gb/git-state))
           (setq gb/vc-status-cache-timer nil))

         (defun gb/git-state ()
           "query git status for the currently active buffer, refresh on buffer switches"
           (let* ((git-output (shell-command-to-string "git status -s")))
             ;; (message (concat  "git querried " (current-time-string))) ;; just for debugging, please remove when done
             (if (string-empty-p git-output)
                 'up-to-date
               'dirty)))

         (defun gb/vc-state ()
           (if (buffer-file-name)
               (vc-state (buffer-file-name))
             (gb/get-cached-git-state)))

         (defun gb/buffer-on-remote ()
           "return whether current buffer is on remote (via tramp)"
           (file-remote-p (or default-directory buffer-file-name dired-directory "")))

         (spaceline-define-segment gb/projectile-id
           (cond ((gb/buffer-on-remote) "×")
                 ((and (fboundp 'projectile-project-p) (projectile-project-p))
                  (projectile-project-name))
                 (t "×")))

         (spaceline-define-segment gb/version-control
           "Version control information."
           (when (and (not (gb/buffer-on-remote)) (gb/in-git-dir-p))
             (powerline-raw
              (s-trim (concat (replace-regexp-in-string "^ *Git[:-]" "\ue0a0 " (gb/vc-status)) ;; "  "
                              (pcase (gb/vc-state)
                                (`up-to-date (concat " " gb/mode-line-branch-up-to-date-symbol))
                                (`edited (concat " " gb/mode-line-branch-edited-symbol))
                                (`added " +")
                                (`unregistered " ?")
                                (`removed " -")
                                (`needs-merge " m")
                                (`needs-update " u")
                                (`ignored " i")
                                (_ " x")))))))

         (spaceline-define-segment gb/time
           "A segment to to display the time"
           (propertize (format-time-string "%H:%M")
                       'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit)
                       'display '(raise 0.1)
                       'help-echo (format-time-string "%A, %Y.%m.%d %H:%M")))

         (when (package-installed-p 'indent-info)
           (spaceline-define-segment gb/indent-info-mode-line
             ""
             (indent-info-mode-line)))

         )))
    #+END_SRC
*** spaceline all the icons
    - important: install fonts located [[https://github.com/domtronn/all-the-icons.el/tree/master/fonts][here]]
    #+begin_SRC emacs-lisp
    ;; (use-package font-lock+)
    (when gb/use-space-line
      (use-package all-the-icons
        :ensure all-the-icons
        :after ( memoize) ;; font-lock+
        :config
        ;; extend list of all-the-icons-mode-icon-alist
        ;; by
        ;; (typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
        ;; (tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
        (with-eval-after-load 'all-the-icons
          (progn
            (add-to-list 'all-the-icons-mode-icon-alist '(typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
            (add-to-list 'all-the-icons-mode-icon-alist '(tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
            )))

      (use-package memoize
        :ensure memoize)

      (use-package spaceline-all-the-icons
        :ensure spaceline-all-the-icons
        :after ( spaceline all-the-icons memoize) ;; indent-info
        ;; :defer 1
        :config
        ;; (spaceline-all-the-icons-theme)
        (custom-set-variables  '(spaceline-all-the-icons-highlight-file-name t)
                               '(spaceline-all-the-icons-separator-type (quote slant)) ;; cup, slant, wave, arrow
                               '(spaceline-all-the-icons-slim-render nil)
                               '(spaceline-all-the-icons-file-name-highlight t)
                               )

        (gb/do-after-display-system-init
         (progn
           (defun gb/warn-missing-font (font-name)
             "warn of font missing, if not found"
             (if (member font-name (font-family-list))
                 (message (concat "OK: font '" font-name "' is installed."))
               (message (concat "WARNING: make sure font '" font-name  "' is installed."))))

           (gb/warn-missing-font "all-the-icons")
           (gb/warn-missing-font "file-icons")
           (gb/warn-missing-font "FontAwesome")
           (gb/warn-missing-font "Material Icons")
           (gb/warn-missing-font "github-octicons")
           (gb/warn-missing-font "Weather Icons")

           (spaceline-install '((gb/buffer-status :face highlight-face)
                                ;; auto-compile
                                ;; buffer-size
                                gb/buffer-file-name
                                (gb/buffer-id :face highlight-face) ;; popup-menu-selection-face
                                ;; remote-host
                                (paradox-menu :when active)
                                ;; persp-name
                                ;; major-mode
                                ((flycheck-error flycheck-warning flycheck-info)
                                 :when active)
                                ((major-mode
                                  ;; all-the-icons-mode-icon
                                  ;; gb/projectile-id

                                  ;;  all-the-icons-projectile
                                  ;; (minor-modes :when active)
                                  (gb/version-control :when (not (string-match "magit.*" (symbol-name major-mode))))
                                  ;; all-the-icons-vc-icon
                                  ;; (all-the-icons-vc-status
                                  ;;  all-the-icons-git-ahead
                                  ;;   all-the-icons-git-status
                                  ;; :when (buffer-file-name))
                                  ;; all-the-icons-flycheck-status
                                  ;; all-the-icons-flycheck-status-info
                                  ;; all-the-icons-package-updates
                                  ))

                                ;; (erc-track :when active)
                                (process :when active)
                                (org-pomodoro :when active)
                                (org-clock :when active)
                                )

                              '(;; which-function
                                ;; (python-pyvenv :fallback python-pyenv)
                                ;; purpose



                                selection-info
                                ;; gb/indent-info-mode-line
                                ;; input-method
                                ((buffer-encoding-abbrev
                                  point-position
                                  line-column)
                                 :separator " ")
                                ;;(global :when active)
                                ((buffer-position
                                  hud))
                                (gb/date-and-cw :tight t :when active :face default-face)
                                ((all-the-icons-battery-status :tight t)
                                 ;; (all-the-icons-time :when active :tight t)
                                 (gb/time :when active :tight t)
                                 ;; (gb/symon :when active :tight t)
                                 ;; :separator (spaceline-all-the-icons--separator "|" " ") :face default-face
                                 )
                                ))

           (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
           (spaceline-all-the-icons--setup-anzu)
           ;; (symon--initialize)
           ))

        ;; (spaceline-all-the-icons--setup-paradox)
        ))
    #+END_SRC
*** rich minority mode (hide minor modes from smart mode line) (disabled, smart mode line not in use anymore)
    #+BEGIN_SRC emacs-lisp
    (when gb/use-smart-mode-line
      (use-package rich-minority
        :config
        (progn
          (rich-minority-mode +1)
          (setq rm-blacklist
                '(
                  " $" ;; rich minority mode
                  " ARev" ;; auto revert mode
                  " ASE" ;; auto sudo edit
                  " Abbrev" ;;
                  " AceI" ;; ace-isearch-mode
                  " Anzu" ;; mode to display number of matches during reg ex search
                  " EditorConfig" ;;
                  " ElDoc overlay" ;; eldoc-overlay-mode
                  " ElDocOver" ;;
                  " ElDoc" ;; elisp documentation mode
                  " Fill" ;; auto-fill-mode
                  ;; " Fly" ;; flymake mode?
                  " GitGutter"
                  " Helm" ;; helm mode
                  " HidePW" ;; hide passwords in org mode files
                  " MRev"
                  " Org"
                  " OTSH" ;; org table sticky headers
                  ;; " Paredit" ;;
                  " Projectile" ;;
                  " PCRE" ;; perl like regular expressions everywhere
                  " SliNav" ;; slime navigation mode (C-, C-.)
                  " Undo-Tree"
                  " VHl" ;; volatile-highlights-mode (visual feedback to some operations related to regions)
                  " WK" ;; which key
                  " WLR" ;; whole line or region mode
                  " ^L" ;; display ^L as continuous line
                  " back" ;; back-button-mode (navigation local/global)
                  " company" ;; complete anything mode
                  " ez-esc" ;; easy-escape displays regular expressions in a more readable way
                  " h"
                  ;; " hs" ;; hide show (toggle block visibility)
                  " mate"
                  ;; " sel" ;; selected-minor-mode (provides extra keymap '' if a region is selected)
                  ;; " wb" ;; white space butler mode (removes trailing whitespaces on lines edited)
                  " wr" ;; wrap-region-mode, wraps a region with tags (e.g. '*' in org mode wraps marked region in ** )
                  " yas" ;; yasnippets
                  )))))
    #+END_SRC
*** smart mode line
    #+BEGIN_SRC emacs-lisp
    (when gb/use-smart-mode-line

      ;; make sure the install question is not interactively placed!
      ;; (setq sml/no-confirm-load-theme t)
      ;; (setq powerline-arrow-shape 'curve)
      ;; (setq powerline-default-separator-dir '(right . left))
      ;; (setq sml/theme 'powerline)
      ;; (sml/setup)

      (use-package powerline
        :ensure powerline)
      (use-package smart-mode-line-powerline-theme
        :ensure smart-mode-line-powerline-theme
        :after ( powerline))
      (use-package smart-mode-line
        :after (powerline smart-mode-line-powerline-theme)
        :init (progn
                (custom-set-faces
                 '(sml/read-only ((t (:inherit sml/not-modified :foreground "orange"))))
                 '(sml/folder ((t (:inherit sml/global :background "#282a2e" :foreground "dark gray" :weight normal))))
                 '(sml/git ((t (:inherit (sml/read-only sml/prefix) :background "#282a2e"))) )
                 '(sml/minor-modes ((t (:inherit sml/folder :foreground "dark gray"))))
                 '(sml/position-percentage ((t (:inherit sml/prefix :background "#373b41" :foreground "goldenrod" :weight normal))))
                 '(sml/read-only ((t (:inherit sml/not-modified :foreground "orange"))))
                 '(sml/vc ((t (:inherit sml/git :background "#373b41" :foreground "saddle brown"))))
                 '(sml/vc-edited ((t (:inherit sml/prefix :background "#373b41" :foreground "peru")))))
                (add-hook 'after-init-hook 'sml/setup))
        :config
        (progn
          (setq sml/name-width 80) ;; max filename length

          ;; (defadvice switch-to-buffer (after switch-to-buffer-resize-mode-line-filename-space activate)
          ;;   "resize modeline to hold filenames"
          ;;   (progn
          ;;     (message (concat "switched and set " (number-to-string (max 40 (- (window-width) 90)))))
          ;;     (setq sml/name-width (max 40 (- (window-width) 90)))))

          (defun rm--mode-list-as-string-list ()
            '())
          (setq sml/mode-width 'full) ;; mode are to be displayed fully
          (setq sml/shorten-directory t)
          (setq sml/shorten-modes t)

          (setq sml/col-number-format "%3c")
          (setq sml/line-number-format "%4l")

          (setq sml/theme 'dark)

          (if after-init-time
              (progn
                (sml/setup)
                ))

          ;; add a hook to sml/after-setup-hook to modify mode-line-format
          ;; ("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification sml/pos-id-separator mode-line-position smartrep-mode-line-string
          ;; (vc-mode vc-mode)
          ;; sml/pre-modes-separator mode-line-modes mode-line-misc-info mode-line-end-spaces)


          ;; (require 'smart-mode-line-powerline-theme)
          ;; (sml/apply-theme 'dark)
          ;; Alternatives:
          ;; (sml/apply-theme 'powerline)
          ;; (sml/apply-theme 'dark)
          ;; (sml/apply-theme 'light)
          ;; (sml/apply-theme 'respectful)
          ;; (sml/apply-theme 'automatic)
          (setq powerline-default-separator 'arrow)
          ;; (setq powerline-default-separator-dir '(right . left))

          ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Projects/" ":iP:"))
          ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Utilities/" ":iU:"))
          (add-to-list 'sml/replacer-regexp-list '("^~/Documents/clojure/workspace" ":clj:")))))

    #+END_SRC
*** fancy battery (for modeline)
    Display of battery status in the emacs mode line (all the way to the left)
    See [[https://github.com/lunaryorn/fancy-battery.el][link]]
    #+BEGIN_SRC emacs-lisp
    (use-package fancy-battery
      :ensure fancy-battery
      :init (progn (add-hook 'after-init-hook #'fancy-battery-mode)))
    #+END_SRC
** rainbow mode
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-mode
     :ensure rainbow-mode
     :init (add-hook 'help-mode-hook #'rainbow-mode))
   #+END_SRC
** rainbow identifiers
   #+BEGIN_SRC emacs-lisp
   ;; can be switched off by M-x rainbow-identifiers-mode, which toggles the mode
   (use-package rainbow-identifiers
     :ensure rainbow-identifiers
     :init
     (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
   #+END_SRC
** cursor blinking / beacon
   - see https://github.com/Malabarba/beacon
   #+BEGIN_SRC emacs-lisp
   ;; mark cursor when switching buffers/windows/frames
   (use-package beacon
     :config
     (setq beacon-blink-when-window-scrolls nil)
     (setq beacon-blink-when-window-changes t)
     (setq beacon-blink-when-point-moves nil)
     (setq beacon-push-mark nil)
     (beacon-mode 1)
     )
   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package crosshairs
     :after (ace-window   ;; optional, install cursor blink after ace window switch
             helm)       ;; optional, install cursor blink after helm buffer switch
     :config
     (progn
       (defun blink-cursor-mode-off ()
         (blink-cursor-mode 0))

       (setq cursor-flash-timer nil)

       (defun cursor-flash (&optional seconds)
         "let cursor flash for three seconds"
         (interactive "P")
         (if cursor-flash-timer
             (cancel-timer cursor-flash-timer)) ; Cancel to prevent duplication.
         (blink-cursor-mode 0)
         (blink-cursor-mode 1)
         (let ((delay (or seconds 3)))
           (setq cursor-flash-timer (run-at-time
                                     delay nil
                                     #'blink-cursor-mode-off))))

       (defun cursor-ping (&optional seconds)
         (flash-crosshairs)
         (cursor-flash (or seconds 3)))

       ;; (toggle-crosshairs-when-idle t)
       (setq col-highlight-vline-face-flag  t
             col-highlight-face
             hl-line-face)

       (global-set-key (kbd "C-+") '(lambda (&optional u) (interactive) (cursor-ping 1)))

       (defadvice switch-to-buffer (after switch-to-buffer-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (when (package-installed-p 'helm)
         (defadvice helm-buffer-list (after helm-buffer-list-flash-crosshairs activate)
           "Call `flash-crosshairs' after `switch-to-buffer'"
           (cursor-ping 2)))

       (defadvice ns-next-frame (after ns-next-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (defadvice ns-prev-frame (after ns-prev-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `ns-prev-frame'"
         (cursor-ping 2))

       (defadvice other-window (after other-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `other-window'"
         (cursor-ping 1))

       (defadvice delete-window (after delete-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching because of `delete-window'"
         (cursor-ping 1))

       (when (package-installed-p 'ace-window)
         (defadvice ace-window (after ace-window-flash-crosshairs activate)
           "Call `flash-crosshairs' after switching with `ace-window'"
           (cursor-ping 1)))))
   #+END_SRC
** window arrangement
   - [[https://github.com/wasamasa/shackle][github]]
   - [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-shackle.el][example usage]]
   #+BEGIN_SRC emacs-lisp
   (use-package shackle
     :config
     (progn
       (shackle-mode 1)
       (setq shackle-rules
             '(
               ("*helm M-x*"            :align right :size 0.3)
               ("*helm imenu-anywhere*" :align right :size 0.5)
               ("*helm for files*"      :align right :size 0.5)
               ("*undo-tree*"           :align right :size 0.25)
               ))))
   #+END_SRC
** linenumbers
   #+BEGIN_SRC emacs-lisp
   (use-package nlinum
     :bind (("M-g M-g" . goto-line-with-feedback))
     :init (progn
             (defun goto-line-with-feedback ()
               "Show line numbers temporarily, while prompting for the line number input"
               (interactive)
               (unwind-protect
                   (progn
                     (setq display-line-numbers t)
                     (goto-line (read-number "Goto line: ")))
                 (setq display-line-numbers nil)))
             )
     :config
     (progn
       (setq linum-delay t)
       ;; (global-set-key [remap goto-line] 'goto-line-with-feedback)

       ;; (setq global-nlinum-mode t)
       ))
   #+END_SRC
** toggle serif font
   #+BEGIN_SRC emacs-lisp
   (defvar serif-preserve-default-list nil
     "A list holding the faces that preserve the default family and
     height when TOGGLE-SERIF is used.")

   (setq serif-preserve-default-list
         '(;; LaTeX markup
           font-latex-math-face
           font-latex-sedate-face
           font-latex-warning-face
           ;; org markup
           org-latex-and-related
           org-meta-line
           org-verbatim
           org-block-begin-line
           ;; syntax highlighting using font-lock
           font-lock-builtin-face
           font-lock-comment-delimiter-face
           font-lock-comment-face
           font-lock-constant-face
           font-lock-doc-face
           font-lock-function-name-face
           font-lock-keyword-face
           font-lock-negation-char-face
           font-lock-preprocessor-face
           font-lock-regexp-grouping-backslash
           font-lock-regexp-grouping-construct
           font-lock-string-face
           font-lock-type-face
           font-lock-variable-name-face
           font-lock-warning-face))

   (defun toggle-serif ()
     "Change the default face of the current buffer to use a serif family."
     (interactive)
     (when (display-graphic-p)  ;; this is only for graphical emacs
       ;; the serif font familiy and height, save the default attributes
       (let ((serif-fam "Source Serif Pro")
             (serif-height 120)
             (default-fam (face-attribute 'default :family))
             (default-height (face-attribute 'default :height)))
         (if (not (bound-and-true-p default-cookie))
             (progn (make-local-variable 'default-cookie)
                    (make-local-variable 'preserve-default-cookies-list)
                    (setq preserve-default-cookies-list nil)
                    ;; remap default face to serif
                    (setq default-cookie
                          (face-remap-add-relative
                           'default :family serif-fam :height serif-height
                           :weight 'light
                           ))
                    ;; keep previously defined monospace fonts the same
                    (dolist (face serif-preserve-default-list)
                      (add-to-list 'preserve-default-cookies-list
                                   (face-remap-add-relative
                                    face :family default-fam :height default-height)))
                    (text-scale-increase 2)
                    (message "Turned on serif writing font."))
           ;; undo changes
           (progn (face-remap-remove-relative default-cookie)
                  (dolist (cookie preserve-default-cookies-list)
                    (face-remap-remove-relative cookie))
                  (setq default-cookie nil)
                  (setq preserve-default-cookies-list nil)
                  (text-scale-decrease 2)
                  (message "Restored default fonts."))))))
   #+END_SRC
** form feed
   - display ^L as h-bar
   #+BEGIN_SRC emacs-lisp
   (use-package form-feed
     :ensure form-feed
     :init
     (progn (add-hook 'text-mode-hook #'form-feed-mode)))
   #+END_SRC
** hide show org like
   - if tab does not indent, folding is done
   #+BEGIN_SRC emacs-lisp
   (use-package hideshow-org
     :init (add-hook 'text-mode #'hs-org/minor-mode))
   #+END_SRC
** highlight indent
   - Minor mode to highlight indentation
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-indent-guides
     :ensure highlight-indent-guides
     :init ;; (add-hook 'prog-mode-hook #'highlight-indent-guides-mode)
     :config
     (progn
       (set-face-background 'highlight-indent-guides-odd-face "darkgray")
       (set-face-background 'highlight-indent-guides-even-face "dimgray")
       (setq highlight-indent-guides-character ?\|)
       (setq highlight-indent-guides-method 'character)))
   #+END_SRC
** COMMENT own ui stuff
   #+BEGIN_SRC emacs-lisp
   (when (and (package-installed-p 'ace-window) (package-installed-p 'helm))

     (require 'ace-window)
     (require 'helm-buffers)

     (defun split-window-below-and-select-scratch ()
       (interactive)
       (let* ((new-window (split-window-below)))
         (set-window-buffer new-window "*scratch*")
         (aw-switch-to-window new-window)
         new-window))
     (bind-key "C-x 2" 'split-window-below-and-select-scratch)

     (defun split-window-right-and-select-scratch ()
       (interactive)
       (let* ((new-window (split-window-right)))
         (set-window-buffer new-window "*scratch*")
         (aw-switch-to-window new-window)
         new-window))
     (bind-key "C-x 3" 'split-window-right-and-select-scratch)

     (defun split-window-right-and-select ()
       (interactive)
       (split-window-right-and-select-scratch)
       (helm-mini))
     (bind-key "C-x C-3" 'split-window-right-and-select)

     (defun split-window-below-and-select ()
       (interactive)
       (split-window-below-and-select-scratch)
       (helm-mini))
     (bind-key "C-x C-2" 'split-window-below-and-select))

   #+END_SRC
* editing related stuff
** make space a control key (on/off)
   #+BEGIN_SRC emacs-lisp
   (defun gb/restore-space ()
     "given the appropriate xinit settings, this will restore the original space behaviour (e.g. for c64 emulation)"
     (interactive)
     (shell-command "xmodmap -e 'keycode 65 = space'")
     (shell-command "killall xcape")
     (message "switched back to regular space behaviour"))

   (defun gb/space-to-control ()
     "given the appropriate xinit settings, this will enable the usage of space as control key again, after restoring original space behaviour"
     (interactive)
     (shell-command "xmodmap -e 'keycode 65 = Hyper_L'")
     (shell-command "xcape -e 'Hyper_L=space'")
     (message "use space as ctrl alternative"))
   #+END_SRC
** selfinsertion on readonly modes
   #+BEGIN_SRC emacs-lisp
   ;; TODO: refactor macro to a normal function
   (setq selfinsert-modification-mode-ignore-list '(".*magit.*" ".*Magit.*"))

   (defmacro selfinsertOrFunction (func)
     "execute selfinserting if buffer is r/w, else execute function passed"
     `(if (and buffer-read-only
               (not (-first (lambda (reg) (string-match reg mode-name)) selfinsert-modification-mode-ignore-list)))
          (,func)
        (self-insert-command 1)))

   (defun gb/selfInsertOrNextLine ()
     "insert n if in a buffer that allows changes, else move down"
     (interactive)
     (selfinsertOrFunction next-line))

   (defun gb/selfInsertOrPreviousLine ()
     "insert n if in a buffer that allows changes, else move down"
     (interactive)
     (selfinsertOrFunction previous-line))

   (bind-key "p" 'gb/selfInsertOrPreviousLine text-mode-map)
   (bind-key "n" 'gb/selfInsertOrNextLine text-mode-map)

   #+END_SRC
** auto-fill-mode configuration
   - will word break / line break after column _
   #+BEGIN_SRC emacs-lisp
   (setq fill-column 140)
   (set-default 'fill-column 140)
   (defun gb/enable-auto-fill-mode ()
     "enable auto-fill-mode regardless of current state"
     (auto-fill-mode +1))
   #+END_SRC
** keep some session stuff
   - will keep helm-M-x history after restart
   - will keep recent in file location even for org files
   #+begin_src emacs-lisp 
   (use-package session
     :init (add-hook 'after-init-hook 'session-initialize)
     :ensure t
     :config
     (progn
       (setq session-name-disable-regexp "\\(\\`/tmp\\|COMMIT_EDITMSG\\)")))
   #+end_src
** smart-region
   1. set mark, repetitive calls to M-x smart-region will call er/expand-region
   2. set mark, move up/down, stay in same column, call M-x smart-region will open mc/multiple-cursor on each line
      easier to reach via C-S-> and C-S-<
   3. set mark, move right/left/up/down, call M-x smart-region will make a rectangular selection
   #+begin_src emacs-lisp 
   (use-package smart-region
     :commands smart-region
     :after (expand-region multiple-cursors))
   #+end_src
** edit-indirect
   - edit region in separate buffer (and guess mode)
   #+begin_src emacs-lisp 
   (use-package edit-indirect
     :commands edit-indirect-region edit-indirect-commit)
   #+end_src
** autosave
   #+BEGIN_SRC emacs-lisp
   (setq auto-save-interval 500)
   #+END_SRC
** ws-butler
   - remove trailing whitespaces upon save (unobtrusively, that is only in lines actually changed)
   - [[https://github.com/lewang/ws-butler][home page]]
   #+BEGIN_SRC emacs-lisp
   (use-package ws-butler
     :ensure ws-butler
     :config
     (progn
       (ws-butler-global-mode 1)))
   #+END_SRC
** encoding
   #+BEGIN_SRC emacs-lisp
   (prefer-coding-system 'utf-8-unix)
   (set-default-coding-systems 'utf-8-unix)
   (set-terminal-coding-system 'utf-8-unix)
   (set-keyboard-coding-system 'utf-8-unix)
   (set-selection-coding-system 'utf-8-unix)
   (setq-default buffer-file-coding-system 'utf-8-unix)
   ;; (set-language-environment "UTF-8")
   #+END_SRC
** easy-escaping
   - display escaping \ (which is normaly doubled) as single red backslash
   #+BEGIN_SRC emacs-lisp
   (use-package easy-escape
     :ensure easy-escape
     :init (add-hook 'prog-mode-hook 'easy-escape-minor-mode)
     :config
     (progn
       (set-face-attribute 'easy-escape-face nil :foreground "red") ;; make a \\ stand out as red backslash
       ))
   #+END_SRC
** schrute mode (make suggestions) disabled
   #+begin_src emacs-lisp :tangle no
   (use-package schrute
     :disabled t
     :config
     (progn
       (defun msgavy ()
         (interactive)
         (message "try avy-goto-line"))
       (setf schrute-shortcuts-commands
             '((msgavy      . (next-line previous-line))))
       (schrute-mode)))
   #+end_src
** german umlaute
   - standard binding is C-x 8 " a|o|u|s
   - key-chords: hit a|u|o and e simultaneously => umlaut
   - other-key: hit C-" then a|u|o|s => umlaut,ß
   #+BEGIN_SRC emacs-lisp
   (progn
     (require 'bind-key)
     (require 'key-chord)
     (bind-key "C-\" a" (lambda () (interactive) (insert "ä")))
     (bind-key "C-\' a" (lambda () (interactive) (insert "ä")))
     (bind-key "C-\" A" (lambda () (interactive) (insert "Ä")))
     (key-chord-define-global "AE" (lambda () (interactive) (insert "Ä")))
     ;;(key-chord-define-global "ae" (lambda () (interactive) (insert "ä")))
     (bind-key "C-\" u" (lambda () (interactive) (insert "ü")))
     (bind-key "C-\' u" (lambda () (interactive) (insert "ü")))
     (bind-key "C-\" U" (lambda () (interactive) (insert "Ü")))
     (key-chord-define-global "UE" (lambda () (interactive) (insert "Ü")))
     ;;(key-chord-define-global "ue" (lambda () (interactive) (insert "ü")))
     (bind-key "C-\" o" (lambda () (interactive) (insert "ö")))
     (bind-key "C-\' o" (lambda () (interactive) (insert "ö")))
     (bind-key "C-\" O" (lambda () (interactive) (insert "Ö")))
     (key-chord-define-global "OE" (lambda () (interactive) (insert "Ö")))
     ;; (key-chord-define-global "oe" (lambda () (interactive) (insert "ö")))
     (bind-key "C-\" s" (lambda () (interactive) (insert "ß")))
     (bind-key "C-\' s" (lambda () (interactive) (insert "ß")))
     (bind-key "C-\" S" (lambda () (interactive) (insert "ß"))))
   #+END_SRC
** hungry delete (disabled, testing smart hungry delete)
   - delete all spaces before/after when using backspace/delete
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package hungry-delete
     :bind (( "C-S-d" . hungry-delete-forward)
            ( "S-<backspace>" . hungry-delete-backward)))
   #+END_SRC
** editing
   #+BEGIN_SRC emacs-lisp
   ;; No need for ~ files when editing
   (setq create-lockfiles nil)

   ;; Customizations relating to editing a buffer.
   ;; enable C-x C-u to do upcase on region (which is disabled by default)
   (put 'upcase-region 'disabled nil)
   (put 'downcase-region 'disabled nil)

   ;; display tabs as four spaces
   (setq default-tab-width 4)
   (setq tab-width 4)

   ;; indent all c and derived sources (java, groovy) with the basic 4 indent
   (defun gb/c-mode-hook ()
     (setq indent-tabs-mode nil
           c-basic-offset 4))
   (add-hook 'c-mode-common-hook 'gb/c-mode-hook)


   ;; make sure that C-k kills to the end of line and the whole line if cursor is at the start of the line
   (setq-default kill-whole-line t)

   ;; automatically reload open buffers if they changed on disk
   (global-auto-revert-mode 1)

   ;; overwrite selected text
   (delete-selection-mode t)

   ;; Lisp-friendly hippie expand
   (setq hippie-expand-try-functions-list
         '(try-expand-dabbrev
           try-expand-dabbrev-all-buffers
           try-expand-dabbrev-from-kill
           try-complete-lisp-symbol-partially
           try-complete-lisp-symbol))

   ;; Highlights matching parenthesis
   (show-paren-mode 1)
   (custom-set-faces '(show-paren-match
                       ((t (:background "black"
                                        :foreground "yellow"
                                        :weight ultra-bold
                                        :width ultraexpanded)))))

   ;; Highlight current line
   (global-hl-line-mode 1)
   (custom-set-faces
    '(hl-line ((t (:background "gray15"))))
    '(highlight ((t (:background "gray15"))))
    '(font-lock-doc-face ((t (:foreground "gray52"))))
    '(font-lock-comment-face ((t (:foreground "gray38"))))
    '(font-lock-comment-delimiter-face ((t (:foreground "gray38"))))
    '(font-lock-string-face ((t (:foreground "#4080b0")))))

   ;; Don't use hard tabs
   (setq-default indent-tabs-mode nil)

   ;; after indent is ok, try to complete
   (setq tab-always-indent 'complete)
   (add-to-list 'completion-styles 'initials t)
   ;; Emacs can automatically create backup files. This tells Emacs to
   ;; put all backups in ~/.emacs.d/backups. More info:
   ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html
   (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                  "backups"))))
   (setq auto-save-default nil)


   (use-package rainbow-delimiters
     :ensure rainbow-delimiters
     :init
     (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

   (defun die-tabs ()
     "remove all tabs within this buffer using spaces, interpreting a tab as 8 spaces"
     (interactive)
     (set-variable 'tab-width 8)
     (mark-whole-buffer)
     (untabify (region-beginning) (region-end))
     (keyboard-quit))

   ;; fix weird os x kill error
   (defun ns-get-pasteboard ()
     "Returns the value of the pasteboard, or nil for unsupported formats."
     (condition-case nil
         (ns-get-selection-internal 'CLIPBOARD)
       (quit nil)))

   (setq electric-indent-mode nil)

   #+END_SRC
** toggle commands (C-x t ...)
   #+BEGIN_SRC emacs-lisp
   (define-prefix-command 'gb/toggle-map)

   (defun gb/toggle-line-numbers ()
     ""
     (interactive)
     (setq display-line-numbers (not display-line-numbers)))
   ;; The manual recommends C-c for user keys, but C-x t is
   ;; always free, whereas C-c t is used by some modes.
   (define-key ctl-x-map "t" 'gb/toggle-map)
   (define-key gb/toggle-map "c" #'column-number-mode)
   (define-key gb/toggle-map "d" #'toggle-debug-on-error)
   (define-key gb/toggle-map "e" #'toggle-debug-on-error)
   (define-key gb/toggle-map "f" #'auto-fill-mode)
   (define-key gb/toggle-map "h" #'highlight-thing-mode)
   (define-key gb/toggle-map "i" #'gb/toogle-highlight-what-thing)
   (define-key gb/toggle-map "k" #'flycheck-mode)
   (define-key gb/toggle-map "l" #'toggle-truncate-lines)
   (when (fboundp 'gb/toggle-visible-mark-mode)
     (define-key gb/toggle-map "m" #'gb/toggle-visible-mark-mode))
   (define-key gb/toggle-map "n" #'gb/toggle-line-numbers)
   (define-key gb/toggle-map "o" #'dired-omit-mode)
   (define-key gb/toggle-map "p" #'toggle-serif)
   (define-key gb/toggle-map "q" #'toggle-debug-on-quit)
   (define-key gb/toggle-map "r" #'toggle-word-wrap)
   (define-key gb/toggle-map "s" #'flyspell-mode)
   (when (fboundp 'gb/toggle-ligatures)
     (define-key gb/toggle-map "t" #'gb/toggle-ligatures))
   (define-key gb/toggle-map "u" #'gb/switch-dictionary)
   (define-key gb/toggle-map "w" #'whitespace-mode)
   (define-key gb/toggle-map "5" #'toggle-frame-fullscreen)
   #+END_SRC
** browse kill ring
   - allow to browse kill ring via M-y and insert from arbitrary positions
   #+BEGIN_SRC emacs-lisp
   (use-package browse-kill-ring
     ;; bind M-y to interactively browsing the kill ring buffer
     :config
     (browse-kill-ring-default-keybindings))
   #+END_SRC
** save-place
   - When you visit a file, point goes to the last place where it
     was when you previously visited the same file.
   - http://www.emacswiki.org/emacs/SavePlace
   #+BEGIN_SRC emacs-lisp
   (if (not (version< emacs-version "25.0"))
       ;; for later emacs versions, save place is no separate package, but built in
       (progn (save-place-mode +1)
              (setq save-place-file (concat user-emacs-directory "places")))
     (use-package saveplace
       :config
       (progn
         (save-place-mode +1)
         ;; keep track of saved places in ~/.emacs.d/places
         (setq save-place-file (concat user-emacs-directory "places")))))
   #+END_SRC
** save on focus loss
   #+BEGIN_SRC emacs-lisp
   (defun save-all ()
     (interactive)
     (save-some-buffers t))
   (add-hook 'focus-out-hook 'save-all)
   #+END_SRC
** undo tree
   - C-x u opens the undo tree and lets you move through the tree of undo/redo
   #+BEGIN_SRC emacs-lisp 
   (use-package undo-tree
     :ensure undo-tree
     :config
     (progn
       ;; (setq undo-tree-auto-save-history t) ;; it seems that this feature regularly causes emacs to crash, if this history file cannot be read properly
       (setq undo-tree-visualizer-diff t) ;; display diff to previous
       (global-undo-tree-mode)))
   #+END_SRC
** very large files
   - edit very large files in chunks (see [[https://github.com/m00natic/vlfi][here]])
   #+BEGIN_SRC emacs-lisp
   (use-package vlf
     :defer 7
     :config (require 'vlf-setup))
   #+END_SRC
** volatile hightlighting
   - highlight blocks associated with buffer commands until any key is pressed
     (e.g. highlight pasted text)
   #+BEGIN_SRC emacs-lisp
   (use-package volatile-highlights
     :config
     (volatile-highlights-mode t))
   #+END_SRC
** region related editing
*** wrap-region
    - works nicely together with expand region
    - simple mark a region and hit the key '(' e.g. to wrap marked region with parenthesis
    #+BEGIN_SRC emacs-lisp
    ;; wrap-region
    (use-package wrap-region
      :ensure wrap-region
      :config
      (progn
        (wrap-region-global-mode 1)
        (wrap-region-add-wrappers
         ;; default includes ( { [ ' ", so there is no need to define those
         '(("*" "*" nil (markdown-mode org-mode))
           ("~" "~" nil (markdown-mode org-mode))
           ("/" "/" nil (markdown-mode org-mode))
           ("=" "=" "+" (markdown-mode org-mode))
           ("_" "_" nil (markdown-mode org-mode))
           ("$" "$" nil (org-mode latex-mode))
           ("/*" "*/" "/" java-mode)))
        (add-to-list 'wrap-region-except-modes 'gnus-group-mode)
        (add-to-list 'wrap-region-except-modes 'gnus-summary-mode)  ;; don't remap / key, since it is used to limit mail list
        ;; hooks only useful if global region mode is not set (see above)
        ;; (add-hook 'org-mode-hook 'wrap-region-mode)
        ;; (add-hook 'latex-mode-hook 'wrap-region-mode)
        ;; (add-hook 'prog-mode 'wrap-region-mode)
        ))
    #+END_SRC
*** embrace region
    - embrace symbol/word ... with ", ', ( { [ ...
    - key binding is Press C-, a w ' to add '' to the current word:
    #+BEGIN_SRC emacs-lisp
    (use-package embrace
      :after ( expand-region))
    #+END_SRC
*** change-inner
    #+BEGIN_SRC emacs-lisp
    (use-package change-inner
      :after ( expand-region)
      :bind (("M-i" . change-inner)
             ("M-o" . change-outer)))
    #+END_SRC
*** easy kill
    - see [[https://github.com/leoliu/easy-kill][here]]
    - M-w selects the following in the order of availability:
      active region, url, email and finally current line
    - M-w is also a prefix that can be followed by
      - w save word at point
      - b save buffer file name (including path) or default-directory
      - s save sexp at point
      - l save list at point (enclosing sexp)
      - d save defun at point
      - D save defun name at point
      - f save file at point
    - the following keys modify the selection (following the key above)
      - @ append selection to previous kill
      - C-w kill selection and exit
      - +, - and 1..9 expand/shrink the selection
      - 0 shrink selection to initial size
      - C-SPC turn selection into an active region
      - C-g abort
      - ? help
    #+BEGIN_SRC emacs-lisp
    (use-package easy-kill
      :ensure easy-kill
      :init (global-set-key [remap kill-ring-save] 'easy-kill))
    #+END_SRC
*** expand region
    expand / shrink region smartly
    #+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :ensure expand-region
      :after (key-chord) ;; optional, install key chords that do region expansion/shrink
      ;; :defer t ;; valid since init script registeres keys
      :init
      (autoload 'expand-region "er/expand-region" nil t)
      (autoload 'expand-region "er/contract-region" nil t)
      (when (package-installed-p 'key-chord)
        (key-chord-define-global "ü+"   'er/expand-region) ;; make the current selection expand to the next outer bounds
        (key-chord-define-global "]["   'er/expand-region) ;; make the current selection expand to the next outer bounds
        (key-chord-define-global ".-"   'er/contract-region)
        (key-chord-define-global "./"   'er/contract-region))) ;; make the current selection collapse again into the inner bounds
    #+END_SRC
** subword (internal programming minor mode)
   #+BEGIN_SRC emacs-lisp
   (use-package subword
     )
   #+END_SRC
** multicursor
   #+BEGIN_SRC emacs-lisp
   (use-package multiple-cursors
     :after ( hydra highlight-indent-guides)
     ;; bind currently does not work since some other project loads multiple cursors without req-package actually loading this!
     :bind (
            ;; When you have an active region that spans multiple lines, the following will
            ;; add a cursor to each line:
            ("C-S-c C-S-c" . mc/edit-lines)

            ;; When you want to add multiple cursors not based on continuous lines, but based on
            ;; keywords in the buffer, use:

            ("C->" . mc/mark-next-like-this)
            ("C-<" . mc/mark-previous-like-this)
            ("C-c C-<" . mc/mark-all-like-this) ;; mark textually (even substrings)
            ("C-c C->" . mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
            )
     :config
     (progn
       ;; add a cursor to each line:
       ;; (bind-key "C-S-c C-S-c" 'mc/edit-lines)

       ;; When you want to add multiple cursors not based on continuous lines, but based on
       ;; keywords in the buffer, use:

       ;; (bind-key "C->" 'mc/mark-next-like-this)
       ;; (bind-key "C-<" 'mc/mark-previous-like-this)
       ;; (bind-key "C-c C-<" 'mc/mark-all-like-this) ;; mark textually (even substrings)
       ;; (bind-key "C-c C->" 'mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
       (defhydra hydra-multiple-cursors ()
         "
                 ^Up^            ^Down^          ^Other^
                 ----------------------------------------------
                 [_p_]   Next    [_n_]   Next    [_l_] Edit lines
                 [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
                 [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
                 ^ ^             ^ ^             [_m_] Mark by avy
                 ^ ^             ^ ^             [_q_] Quit
             %s(hydra-combine-functions-w-key-bindings
               '((\"    [p]   Up-Next       \" . mc/mark-previous-like-this)
                 (\"    [P]   Up-Skip       \" . mc/skip-to-previous-like-this)
                 (\"    [M-p] Up-Unmark     \" . mc/unmark-previous-like-this)
                 (\"    [n]   Down-Next     \" . mc/mark-next-like-this)
                 (\"    [N]   Down-Skip     \" . mc/skip-to-next-like-this)
                 (\"    [M-n] Down-Unmark   \" . mc/unmark-next-like-this)
                 (\"    [l]   Edit lines    \" . mc/edit-lines)
                 (\"    [a]   Mark all      \" . mc/mark-all-like-this)
                 (\"    [r]   Mark by regexp\" . mc/mark-all-in-region-regexp)
                 (\"    [m]   Mark by avy   \" . ace-mc-add-multiple-cursors)))
                 "
         ("l" mc/edit-lines :exit t)
         ("a" mc/mark-all-like-this :exit t)
         ("n" mc/mark-next-like-this)
         ("N" mc/skip-to-next-like-this)
         ("M-n" mc/unmark-next-like-this)
         ("p" mc/mark-previous-like-this)
         ("P" mc/skip-to-previous-like-this)
         ("M-p" mc/unmark-previous-like-this)
         ("r" mc/mark-all-in-region-regexp :exit t)
         ("m" ace-mc-add-multiple-cursors :exit t)
         ("q" (message "Abort") :exit t))))
   #+END_SRC
** IMPLEMENT ace-mc
   - mark multiple cursors using avy to jump to the places that should be multicursored!
     - available functions are: ace-mc-add-multiple-cursors
   #+BEGIN_SRC emacs-lisp
   (use-package ace-mc
     :commands ace-mc-add-multiple-cursors ace-mc-add-single-cursor
     :bind (("C-|" . ace-mc-add-multiple-cursors))
     :after (avy multiple-cursors ace-jump-mode))
   #+END_SRC
** key-chord
   #+BEGIN_SRC emacs-lisp
   (use-package key-chord
     :config
     (progn
       (setq key-chord-two-keys-delay 0.10)
       (setq key-chord-one-key-delay 0.20)
       (key-chord-mode 1)

       ;; (key-chord-define-global "hj"   'undo)

       ;; (key-chord-define-global "12"   'delete-other-windows) ;; key 12 is too often typed directly after each other => function is triggered unwanted
       ;; (key-chord-define-global "23"   'split-window-below)
       ;; (key-chord-define-global "34"   'split-window-right)
       ;; (key-chord-define-global "0ß"   'delete-window)

       ))
   #+END_SRC
** space-chord (currently disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; last time I had to install this via M-x el-get-list-packages before it actually started working
   ;; when using space as an alternative to control this will not work right
   (el-get-bundle space-chord)
   (use-package space-chord
     :loader :el-get
     :after ( key-chord)
     :config
     (progn
       (setq space-chord-delay 0.08)
       (space-chord-define-global "f" 'find-file) ;; just an example
       (space-chord-define-global "u" 'undo)
       ))
   #+END_SRC
** highlight thing
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-thing
     :after ( key-chord) ;; optional, install key chord to highlight thing
     :init (progn
             ;; make sure that during marking words, the highlighting is switched (temporarily) off
             (add-hook 'activate-mark-hook 'highlight-thing-mode-temporary-off)
             (add-hook 'deactivate-mark-hook 'highlight-thing-mode-temporary-on))
     :config
     (progn
       (setq highlight-thing-delay-seconds 1)
       (setq highlight-thing-what-thing 'symbol)
       ;; customize face hi-yellow

       ;; highlight all identical 'words in view
       (when (package-installed-p 'key-chord)
         (key-chord-define-global "\\'" (function highlight-thing-mode))
         (key-chord-define-global "#ä" (function highlight-thing-mode)))

       (setq highlight-thing-mode-temporary nil)

       (defun highlight-thing-mode-temporary-on ()
         "switch the tepmorary switched off mode on again (if it was on)"
         (interactive)
         (if highlight-thing-mode-temporary
             (progn
               (setq highlight-thing-mode-temporary nil)
               (highlight-thing-mode 1)
               (highlight-thing-schedule-timer))))

       (defun highlight-thing-mode-temporary-off ()
         "switch highlight thing mode temporary off (if it was on)"
         (interactive)
         (let ((hlmode highlight-thing-mode))
           (if hlmode
               (progn
                 (setq highlight-thing-mode-temporary t)
                 (highlight-thing-remove-last)
                 (highlight-thing-mode 0))
             )))

       ))
   #+END_SRC
** highlight symbol
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-symbol
     :bind (("C-c h" . highlight-symbol))
     :config
     (progn
       (setq  highlight-symbol-foreground-color "Gray52")))
   #+END_SRC
** bookmarking (needs hydra)
   #+BEGIN_SRC emacs-lisp
   (use-package bm
     :ensure bm
     :bind
     ( "C-c b t" . bm-toggle)
     ( "C-c b n" . bm-next)
     ( "C-c b p" . bm-previous)
     ( "C-c b s" . bm-show)
     ( "C-c b S" . bm-show-all)
     ( "C-c b r" . bm-bookmark-regexp)
     ( "C-c b A" . bm-bookmark-annotate)
     ( "C-c b a" . bm-bookmark-show-annotation))
   #+END_SRC
** additional functions
   #+BEGIN_SRC emacs-lisp
   (when (functionp #'nxml-pretty-format)
     (defun gb/replace-buffer-with-yank ()
       "replace the whole buffer with the first item on the kill ring"
       (interactive)
       (erase-buffer)
       (yank)
       (if (string-prefix-p (buffer-substring 1 6) "<?xml")
           (nxml-pretty-format))))
   #+END_SRC
** aggressive indent mode (also used by parinfer) 
   automatically indents all while typing 
   #+BEGIN_SRC emacs-lisp
   (use-package aggressive-indent
     :config
     (progn ;; (global-aggressive-indent-mode 1) ;; enable mode for all programming modes
       (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
       ;;(add-to-list 'aggressive-indent-excluded-modes 'clojure-mode)
       ;;(add-to-list 'aggressive-indent-excluded-modes 'emacs-lisp-mode)
       )) ;; disable mode for ...
   #+END_SRC
** with editor
   #+BEGIN_SRC emacs-lisp
   (use-package with-editor
     :after ( async))
   #+END_SRC
** selected (provide special keybindings if selections are active)
   - https://github.com/Kungsgeten/selected.el
   #+BEGIN_SRC emacs-lisp 
   (use-package selected
     :ensure selected
     :init (progn
             (add-hook 'org-mode-hook 'selected-minor-mode)
             (add-hook 'prog-mode-hook 'selected-minor-mode))
     :bind (:map selected-keymap
                 ("a" . mc/mark-all-like-this)
                 ("d" . downcase-region)
                 ("i" . indent-region)
                 ("m" . mc/mark-more-like-this-extended)
                 ("q" . selected-off)
                 ("u" . upcase-region)
                 ("w" . count-words-region)
                 ("<" . mc/mark-previous-like-this)
                 (">" . mc/mark-next-like-this))
     :config
     (progn ))
   #+END_SRC
* language specific stuff
** langtool (very! elaborate spellchecking)
   - instrument languagetool (see [[https://www.languagetool.org/][here]])
     installed via 'brew install languagetool'
   - description see [[https://github.com/mhayashi1120/Emacs-langtool][here]]
   - TODO: change interface to use json (thus some other details can be used for display)
     json parsing with elisp see [[http://tess.oconnor.cx/2006/03/json.el][here]]
     adjustments to (langtool--process-filter) will have to be made, in order to parse json results
   #+BEGIN_SRC emacs-lisp
   (when languagetool-installed
     (use-package langtool
       :after ( s)
       :commands (langtool-check
                  langtool-check-buffer
                  langtool-check-done
                  langtool-switch-default-language
                  langtool-show-message-at-point
                  langtool-correct-buffer)
       :init
       (progn
         (defun langtool-autoshow-detail-popup (overlays)
           (when (require 'popup nil t)
             ;; Do not interrupt current popup
             (unless (or popup-instances
                         ;; suppress popup after type `C-g` .
                         (memq last-command '(keyboard-quit)))
               (let ((msg (langtool-details-error-message overlays)))
                 (popup-tip msg)))))
         (setq langtool-autoshow-message-function
               'langtool-autoshow-detail-popup)
         )
       :config
       (when (is-_nix-p)
         (let ((jar-file (concat (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/^CP=\\(.*\\)/\\1/p'")) "/languagetool-commandline.jar")))
           (cond ((file-exists-p jar-file) (setq langtool-language-tool-jar jar-file))
                 ((file-exists-p "/usr/share/languagetool") (setq langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*"))
                 (t (message (format "ERROR: langtool jar not found at '%s' nor in '/usr/share/languagetool'" jar-file))))))
       (when (is-macos-p)
         (let ((jar-file (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/.*-jar.\\(.*\\) \".*/\\1/p'"))))
           (if (file-exists-p jar-file)
               (progn
                 (message "OK: langtool jar file found")
                 (setq langtool-language-tool-jar jar-file))
             (message (format "ERROR: langtool jar not found at '%s'" jar-file)))))

       (setq langtool-default-language "de")
       (setq langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))))
   #+END_SRC
** flyspell
   installation of ispell german dictionary:
   - arch linux:
     #+BEGIN_SRC bash :tangle no
     sudo pacman -S aspell-en aspell-de
     #+END_SRC
   - mac:
     - download from https://www.j3e.de/ispell/igerman98/
     - unpack, edit make file (remove unnecessary languages), execute make
     - copy *.hash from subdir ispell into /usr/local/Cellar/ispell/3.4.00/lib/ispell/ (e.g. de_DE.hash)
     - create link 'ln -s de_DE.hash deutsch.hash'
     - TODO: make gb/switch-dictionary use a variable for hooks that are all called when registration took place! langtool then only registers
       an additional hook. the hook should use well defined languages as parameters to let each hook what exactly to set
   #+BEGIN_SRC emacs-lisp
   (use-package flyspell
     :after ( org)
     :init (progn
             (defun gb/activate-ispell-in-org-mode ()
               "activate ispell and try to select to right language (e.g. `#+language: de')
     disable spell checking if `#+PROPERTY: spellcheck no' is set"
               (let* ((spellCheck (gb/org-global-prop-value "spellcheck")))
                 (if (string= spellCheck "no")
                     (progn (flyspell-mode 0))
                   (require 'ox)
                   (let* ((fileLang (plist-get (org-export--get-inbuffer-options) :language)))
                     (if (string= fileLang "de")
                         (ispell-change-dictionary "deutsch8")
                       (ispell-change-dictionary "english"))
                     (turn-on-flyspell)))))

             ;; switch between german and english dicionary
             (defun  gb/switch-dictionary()
               (interactive)
               (let* ((oldLang ispell-current-dictionary)
                      (newLang (if (string= oldLang "deutsch8") "english" "deutsch8"))
                      (oldLangtool (if (boundp 'langtool-default-language) langtool-default-language nil))
                      (newLangtool (if (string= oldLangtool "de") "en-US" "de")))
                 (ispell-change-dictionary newLang)
                 (if (boundp 'langtool-default-language) (setq langtool-default-language newLangtool))
                 (message "Dictionary switched from `%s' to `%s'" oldLang newLang)))

             (add-hook 'message-mode-hook 'turn-on-flyspell)
             (add-hook 'org-mode-hook 'gb/activate-ispell-in-org-mode)
             )
     :bind (("C-x l" . gb/switch-dictionary))
     :config
     (progn
       (require 'ox)
       (setq ispell-dictionary "deutsch8")
       (setq ispell-local-dictionary "deutsch8")
       (setq flyspell-default-dictionary "deutsch8")

       ;; for programmiong modes, switch to english and activate flyspell-prog-mode
       ;; (dolist (hook '(prog-mode-hook))
       ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "english")(flyspell-prog-mode 1)))))

       ;; for orgmode, switch to english and activate flyspell
       ;; (dolist (hook '(org-mode-hook))
       ;;   (add-hook hook (lambda () (flyspell-mode 1))))

       ;; for mails, switch to german dictionary and activate flyspell
       ;; (dolist (hook '(message-mode-hook))
       ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "deutsch8")(flyspell-mode 1)))))

       ;; don't print error message for every mispelled word found
       (setq flyspell-issue-message-flag nil)


       ))
   #+END_SRC
** dictionary
   - description [[http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary][here]]
   - downloaded from [[https://github.com/gucong/emacs-sdcv][here]]
   - use dictionary in startdict format from ~/.stardict/dic
   #+BEGIN_SRC emacs-lisp
   (if (file-exists-p "~/.emacs.d/additionals/sdcv-mode.el")
       (use-package sdcv-mode
         :commands sdcv-search
         :load-path "~/.emacs.d/additionals"))
   #+END_SRC
** look up definition
   - 'H-d' (it's fn-d on mac) will lookup (english) definition of the word at point
   - 'H-D' will query for the word to find the definition for
   #+BEGIN_SRC emacs-lisp
   (use-package define-word
     :bind (("H-d" . define-word-at-point)
            ("H-D" . define-word)))
   #+END_SRC
* auto complete, help, man etc.
** helpful
   - allow for additional help information for functions
   #+BEGIN_SRC emacs-lisp
   (use-package helpful
     :ensure helpful
     :commands (helpful-macro helpful-function helpful-command helpful-variable helpful-at-point)
     :bind ("s-h" . helpful-at-point))
   #+END_SRC
** which key
   #+BEGIN_SRC emacs-lisp
   (use-package which-key
     :ensure which-key
     :config
     (progn
       (bind-key "C-h y" #'which-key-show-top-level)
       (which-key-mode)
       (which-key-setup-side-window-right)
       (validate-setq which-key-side-window-max-width 0.4)
       (setq which-key-max-description-length 45)
       (setq which-key-popup-type 'side-window)
       ))
   #+END_SRC
** keyfreq
   #+BEGIN_SRC emacs-lisp
   (use-package keyfreq
     :config
     (progn
       (keyfreq-mode 1)
       (keyfreq-autosave-mode 1)
       ;; use M-x keyfreq-show to show the frequency of key usages
       ))
   #+END_SRC
** company
   #+BEGIN_SRC emacs-lisp
   (use-package company-try-hard
     :ensure company-try-hard
     :after (company)
     :config
     (progn
       (global-set-key (kbd "M-TAB") #'company-try-hard)
       (global-set-key (kbd "<C-tab>") #'company-try-hard)
       (global-set-key (kbd "M-/") #'company-try-hard)
       (define-key company-active-map (kbd "M-TAB") #'company-try-hard)
       ))

   (use-package company-box
     :ensure company-box
     :after (company)
     :init
     (add-hook 'company-mode-hook 'company-box-mode)
     :config
     (progn
       (setq company-box-enable-icon nil)
       (custom-set-faces
        '(company-box-candidate ((t (:foreground "gray85")))))))

   (use-package company
     :after (selected)
     :ensure company
     :init (progn
             (add-hook 'after-init-hook 'global-company-mode))
     :config
     (progn
       (setq company-idle-delay nil)
       (setq company-show-numbers nil)
       ;; use numbers 0-9 to select company completion candidates
       (let ((map company-active-map))
         (mapc (lambda (x) (define-key map (format "%d" x)
                             `(lambda () (interactive) (company-complete-number ,x))))
               (number-sequence 0 9)))

       ;; this will make company be used tab completion (if no indenting needs to take place)
       (global-set-key (kbd "TAB") #'company-indent-or-complete-common)
       (setq company-minimum-prefix-length 4)
       (setq company-tooltip-limit 15)
       (setq company-tooltip-flip-when-above t)
       (setq company-dabbrev-downcase nil) ;; make company suggestions case sensitive (no downcase conversion)
       (setq company-backends
             (quote
              (company-capf company-shell company-bbdb company-semantic company-files
                            company-dabbrev-code company-gtags company-etags company-keywords
                            company-oddmuse company-dabbrev)))
       (setq company-dabbrev-code-modes
             (quote
              (prog-mode
               batch-file-mode
               css-mode
               ;; erlang-mode
               ;; haskell-mode
               ;; jde-mode
               ;; lua-mode
               ;; python-mode
               clojure-mode
               ;; scala-mode
               )))

       (custom-set-faces
        '(company-echo-common ((t (:inherit company-echo :foreground "gray15"))))
        '(company-preview ((t (:foreground "gray15"))))
        '(company-preview-common ((t (:foreground "tomato2"))))
        '(company-tooltip ((t (:background "gray15" :foreground "gray85"))))
        '(company-tooltip-selection ((t (:background "gray23" :foreground "white"))))
        '(company-tooltip-common ((t (:foreground "firebrick4"))))
        '(company-tooltip-annotation ((t (:foreground "gray15")))))


       ))

   (use-package company-statistics
     :ensure company-statistics
     :after (company)
     :init
     (progn
       (add-hook 'after-init-hook 'company-statistics-mode)))

   #+END_SRC
** company flx
   #+BEGIN_SRC emacs-lisp
   (use-package company-flx
     :ensure company-flx
     :after (company)
     :config
     (with-eval-after-load 'company (add-hook 'company-mode-hook (lambda () (add-to-list 'company-backends 'company-capf))) (company-flx-mode +1)))
   #+END_SRC
** IMPLEMENT company-shell 
   - provide company help for fish (or other shell) completions within modes like (fish-mode, shell-mode)
   #+BEGIN_SRC emacs-lisp
   (use-package company-shell
     :ensure company-shell
     :after (company)
     :config (add-to-list 'company-backends 'company-shell))
   #+END_SRC
** helm-company
   #+BEGIN_SRC emacs-lisp
   (use-package helm-company
     :ensure helm-company
     :after ( helm company)
     :bind (:map company-mode-map
                 ("C-:" . helm-company)
                 :map company-active-map
                 ("C-:" . helm-company)))
   #+END_SRC
** helm-descbind
   - describe current keybindings with helm interface
   #+BEGIN_SRC emacs-lisp
   (use-package helm-descbinds
     :ensure helm-descbinds
     :after (helm company)
     :bind (("\C-h b" . helm-descbinds)))
   #+END_SRC
** helm-dash
   - add new sources for helm dash via helm-dash-install-docset
   - browse doc set via helm-dash
   #+BEGIN_SRC emacs-lisp
   (use-package helm-dash
     :bind (("\C-z SPC d" . helm-dash-at-point))
     :after ( helm)
     :init (progn
             (defun clojure-dash-doc ()
               (interactive)
               (setq-local helm-dash-docsets '("Clojure")))


             (defun java-dash-doc ()
               (interactive)
               (setq-local helm-dash-docsets '("Java_SE8")))


             (defun bash-dash-doc ()
               (interactive)
               (setq-local helm-dash-docset '("Bash")))


             (add-hook 'clojure-mode-hook 'clojure-dash-doc)
             (add-hook 'java-mode-hook 'java-dash-doc)
             (add-hook 'shell-mode-hook 'bash-dash-doc)
             )
     :config
     (progn
       (if w3m-installed
           (setq helm-dash-browser-func 'w3m-browse-url))
       (setq helm-dash-docsets '("Bash"
                                 "Clojure"
                                 "Docker"
                                 "Emacs Lisp"
                                 "Groovy"
                                 "Groovy JDK"
                                 "Gradle Groovy API"
                                 "Gradle DSL"
                                 "Gradle User Guide"
                                 "Java"
                                 "LaTeX"
                                 "PostgreSQL"
                                 "Vagrant"
                                 "XSLT"))))
   #+END_SRC
*** Installing docsets

    Helm-dash uses the same docsets as Dash. You can install them with
    m-x helm-dash-install-docset for the official docsets or m-x
    helm-dash-install-user-docset for user contributed docsets
    (experimental).

    To install a docset from a file in your drive you can use m-x
    helm-dash-install-docset-from-file'. That function takes as input
    atgzfile that you obtained, starting from a folder named.docset`,
    with the command:

    tar --exclude='.DS_Store' -cvzf <docset name>.tgz <docset name>.docset

    as explained here.
** dash at point
   #+BEGIN_SRC emacs-lisp
   (use-package dash-at-point
     :bind (("C-z SPC h d" . dash-at-point-with-docset)
            ("C-z SPC h D" . dash-at-point)))
   #+END_SRC
** helm-swoop
   #+BEGIN_SRC emacs-lisp
   (use-package helm-swoop
     :ensure helm-swoop
     :bind (("C-S-s" . helm-swoop)
            ("C-M-S-s" . helm-multi-swoop-all))
     :after (helm))
   #+END_SRC
** pos tip
   #+BEGIN_SRC emacs-lisp
   (use-package pos-tip
     :ensure pos-tip)
   #+END_SRC
** help at point
   - show help in modeline to text that is propertized as button... (e.g. in customize-.... modes)
   - the timer will make the help appear after x seconds (can be a float)
   #+BEGIN_SRC emacs-lisp
   (use-package help-at-pt
     :ensure help-at-pt
     :config
     (progn
       (custom-set-variables '(help-at-pt-display-when-idle (quote (kbd-help button local-map keymap)) nil (help-at-pt)))
       (setq help-at-pt-timer-delay 1)
       (help-at-pt-set-timer)))
   #+END_SRC
* navigation
** iy-go-to-char
   - prompts for a character and the jumps forward/backward to the next occurrance of that char
   #+BEGIN_SRC emacs-lisp
   (use-package iy-go-to-char
     :bind (
            ("C-c f" . iy-go-to-char)
            ("C-c F" . iy-go-to-char-backward)))
   #+END_SRC
** ace and avy
   #+BEGIN_SRC emacs-lisp
   (use-package ace-link
     :ensure ace-link
     :after (gnus)
     :bind (
            ;; bind within org mode
            :map org-mode-map
            ("M-o" . ace-link-org)
            ;; bind within gnus
            :map gnus-summary-mode-map
            ("M-o" . ace-link-gnus)
            :map gnus-article-mode-map
            ("M-o" . ace-link-gnus))
     :config
     (progn
       ;; bind "o" within info, help, woman, eww compilation and custom mode
       (ace-link-setup-default)))

   (use-package ace-window  ;; select open window with one key
     :after ( key-chord) ;; optional, key binding
     :ensure ace-window
     :init
     (progn
       (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
       (when (package-installed-p 'key-chord)
         (key-chord-define-global "o0"   'ace-window))))

   (use-package ace-flyspell
     :ensure ace-flyspell
     :after ( flyspell avy))
   ;; available commands 'M-x ace-flyspell-jump-word', jump to incorrect spelling via ace
   ;; 'M-x ace-flyspell-dwim', autocorrect word
   ;; 'M-x ace-flyspell-correct-word', no jump but autocorrect

   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package ace-isearch
     :ensure ace-isearch
     :after ( avy helm-swoop ace-jump-mode)
     :disabled t
     :config
     (progn
       (setq ace-isearch-function (quote avy-goto-word-1)) ;; use thus function if only one character was searched for
       ;; (setq ace-isearch-input-length 3) ;; start helm swoop at a length of 3 characters
       ;; (setq ace-isearch-jump-delay 0.35)
       (setq ace-isearch-use-jump (quote printing-char))

       ;; Enable global ace-isearch mode:
       (global-ace-isearch-mode +1)

       ;; Enable ace-isearch minor mode:
       ;; (ace-isearch-mode +1)

       (when (package-installed-p 'bind-key)
         ;; when in search mode, hit C-' to jump to single char!
         (bind-key "C-'" 'ace-isearch-jump-during-isearch isearch-mode-map)

         (bind-key "C-S-s" 'isearch-forward)
         (bind-key "C-S-r" 'isearch-backward))))

   #+END_SRC
   #+BEGIN_SRC emacs-lisp
   (use-package avy
     :ensure avy
     :bind (("C-S-SPC" . avy-goto-char-timer)
            ("C-c SPC" . avy-goto-char-timer)
            ("C-c C-SPC" . avy-goto-char-timer)
            ("C-x SPC" . avy-pop-mark)
            ("C-x C-SPC" . avy-pop-mark))
     :config
     (progn
       (setq avy-background t)
       (setq avy-keys (number-sequence ?a ?z))
       (custom-set-faces
        '(avy-lead-face ((t (:foreground "red"))))
        '(avy-lead-face-0 ((t (:foreground "orange"))))
        '(avy-lead-face-1 ((t (:foreground "yellow"))))
        '(avy-lead-face-2 ((t (:foreground "white")))))))



   (use-package avy-zap
     :ensure avy-zap
     :after ( avy)
     :bind
     (("M-Z" . avy-zap-to-char-dwim)
      ("M-z" . avy-zap-up-to-char)))


   #+END_SRC
** ace popup menu
   - display regular popup windows (like the one upon C-c $ to correct mispelled words) as a text window (in separate emacs window)
   #+BEGIN_SRC emacs-lisp
   (use-package avy-menu)
   (use-package ace-popup-menu
     :after ( avy avy-menu)
     :ensure t
     :config (ace-popup-menu-mode 1))
   #+END_SRC
** search cursor left
   - C-RET after searching via C-s will leave cursor at start of match
   - RET after searching via C-s will leave cursor at end of match
   #+BEGIN_SRC emacs-lisp
   (define-key isearch-mode-map [(control return)]
     #'isearch-exit-other-end)
   (defun isearch-exit-other-end ()
     "Exit isearch, at the opposite end of the string."
     (interactive)
     (isearch-exit)
     (goto-char isearch-other-end))
   #+END_SRC
** visible mark
   - make the last (2) marks visible (orange, yellow)
   - C-x C-x exchanges point and mark, spanning a region between the two
   - C-space sets the mark, marks are put into a ring
   - back-button allows navigation throught the mark buffer positions
   - STATUS: produces errors on post command hooks (default is disabled)
   #+BEGIN_SRC emacs-lisp
   (use-package visible-mark
     :init
     (defface visible-mark-active ;; put this before (require 'visible-mark)
       '((((type tty) (class mono)))
         (t (:background "magenta"))) "")
     (setq visible-mark-max 2)
     (setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))
     (defun gb/toggle-visible-mark-mode ()
       "toggle visible mark mode"
       (if (bound-and-true-p visible-mark-mode)
           (visible-mark-mode -1)
         (visible-mark-mode t)))
     :config
     (global-visible-mark-mode -1) ;; disable visible mark mode globally (until explicitly toggled for a mode)
     ;; or add (visible-mark-mode) to specific hooks
     )
   #+END_SRC
** back-button
   #+BEGIN_SRC emacs-lisp
   (use-package back-button
     ;; :ensure back-button ;; has currently problems compiling
     :after ( hydra)
     :config
     (progn

       ;;--------------------------------------------------------------------------------
       (defhydra hydra-navigate-history ()
         "
               Navigate through location history
               ---------------------------------
               [_p_] back local    [_n_] forward local
               [_P_] back global   [_N_] forward global
               ^ ^                 [_q_] quit

           %s(hydra-combine-functions-w-key-bindings
             '((\"    back local     \" . back-button-local-backward)
               (\"    back global    \" . back-button-global-backward)
               (\"    forward local  \" . back-button-local-forward)
               (\"    forward global \" . back-button-global-forward)))
               "
         ("p" back-button-local-backward :color green)
         ("P" back-button-global-backward )
         ("n" back-button-local-forward )
         ("N" back-button-global-forward )
         ("q" (message "Abort") :exit t))

       (back-button-mode 1)))
   #+END_SRC
** jumplist
   #+BEGIN_SRC emacs-lisp
   (use-package jumplist
     :after (helm helm-swoop)
     :ensure jumplist
     :bind (
            ("C-," . jumplist-previous)
            ("C-." . jumplist-next))
     :config
     (custom-set-variables
      '(jumplist-hook-commands
        '(helm-swoop helm-for-files helm-find-files
                     dired-jump
                     find-file
                     isearch-forward-regexp isearch-forward
                     end-of-buffer beginning-of-buffer
                     elisp-slime-nav-find-elisp-thing-at-point
                     find-tag
                     eclim-java-find-declaration eclim-java-find-references eclim-java-find-generic eclim-java-find-type
                     cider-find-resource cider-find-file cider-find-var cider-find-var-file))))
   #+END_SRC
** region-state
   - Show the number of chars/lines or rows/columns in the region
   #+BEGIN_SRC emacs-lisp
   (use-package region-state
     :config
     (region-state-mode 1))
   #+END_SRC
** goto last change
   #+BEGIN_SRC emacs-lisp
   (use-package goto-chg
     :ensure goto-chg
     :bind (
            ("C-c b ," . goto-last-change)
            ("C-c b ." . goto-last-change-reverse)))
   #+END_SRC
** smart scan (jump to next/prev of symbol)
   #+BEGIN_SRC emacs-lisp
   (use-package smartscan
     :ensure smartscan
     :config
     (progn
       (global-smartscan-mode +1)
       (setq smartscan-symbol-selector "symbol")))
   ;; (smartscan-mode 1)
   ;; use M-p to jump to previous location of that symbol
   ;; use M-n to jump to net location of that symbol
   #+END_SRC
** anzu (searching regexp with hit count)
   #+BEGIN_SRC emacs-lisp
   ;; display # of matches in modeline when searching
   (use-package anzu
     :ensure anzu
     :config
     (global-anzu-mode +1))
   #+END_SRC
** other (recentf, uniquify)
   #+BEGIN_SRC emacs-lisp
   ;; These customizations make it easier for you to navigate files,
   ;; switch buffers, and choose options from the minibuffer.

   ;; "When several buffers visit identically-named files,
   ;; Emacs must give the buffers distinct names. The usual method
   ;; for making buffer names unique adds ‘<2>’, ‘<3>’, etc. to the end
   ;; of the buffer names (all but one of them).
   ;; The forward naming method includes part of the file's directory
   ;; name at the beginning of the buffer name
   ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html
   (use-package uniquify
     :config
     (setq uniquify-buffer-name-style 'forward))

   ;; Turn on recent file mode so that you can more easily switch to
   ;; recently edited files when you first start emacs
   (use-package recentf
     :ensure recentf
     :config
     (progn
       (setq recentf-save-file (concat user-emacs-directory ".recentf"))
       ;; since recentf file may grow large, delete it if too large
       (shell-command (s-concat "touch " recentf-save-file))
       (let ((rsf-size-str (s-trim (shell-command-to-string (s-concat "ls -la " recentf-save-file " | awk '{ print $5; }'")))))
         (if (<= 10000 (string-to-number rsf-size-str))
             (progn
               (message (s-concat "deleting too large recentf file '" recentf-save-file "' ( size: " rsf-size-str ")"))
               (shell-command (s-concat "rm " recentf-save-file)))))
       (setq recentf-exclude (list "^.*/\\.emacs\\.d/.*"))
       (setq recentf-max-menu-items 40)
       (recentf-mode 1)))
   #+END_SRC
** swiper
   #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :after (easy-escape)
     :ensure ivy)
   (use-package swiper
     :ensure swiper
     :after ( ivy))
   #+END_SRC
** counsel
   #+BEGIN_SRC emacs-lisp
   (use-package counsel
     :ensure counsel
     :after ( swiper)
     ;; :bind (("M-y" . counsel-yank-pop)
     ;;        :map ivy-minibuffer-map
     ;;        ("M-y" . ivy-next-line))
     :config
     (progn
       (bind-key "M-y" #'counsel-yank-pop ) ;; no :bind, since counsel needs to be loaded for magit
       (bind-key "M-y" #'ivy-next-line ivy-minibuffer-map )
       (setq counsel-grep-swiper-limit 3000000)))
   #+END_SRC
** highlight-thing
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-thing
     :ensure highlight-thing
     :init
     (progn
       (defun gb/toogle-highlight-what-thing ()
         "toggle highlight-thing-what-thing between word and symbol.
   highlight thing mode will be switched off during toggle
   and then reactivated, if it was active before."
         (interactive)
         (let (old-highlight-thing-mode highlight-thing-mode)
           (highlight-thing-mode -1)
           (if (equal 'symbol highlight-thing-what-thing)
               (setq highlight-thing-what-thing 'word)
             (setq highlight-thing-what-thing 'symbol))
           (if old-highlight-thing-mode
               (highlight-thing-mode 1))))
       (setq highlight-thing-what-thing 'symbol)))
   #+END_SRC
** minimap
   #+BEGIN_SRC emacs-lisp
   (use-package minimap
     :ensure minimap
     :bind (("s-m" . minimap-mode))
     :config
     (progn
       (setq minimap-major-modes (quote (prog-mode org-mode nxml-mode)))
       (setq minimap-window-location (quote right))
       (custom-set-faces '(minimap-active-region-background ((t (:background "gray23")))))))
   #+END_SRC
* programming language related
** functional-editing
*** OBSOLETE parinfer (currently disabled)
    - State "OBSOLETE"   from "TODO"       [2016-12-18 Sun 09:47]
    - M-x parinfer-toggle-mode
    - use indent to actually infer parenthesis
    - CAREFUL, THIS IS DESTRUCTIVE TO NOT CORRECTLY INDENTED LISP CODE!
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package parinfer
      :disabled t
      :init
      (progn
        (add-hook 'clojure-mode-hook #'parinfer-mode)
        (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'parinfer-mode)
        (add-hook 'ielm-mode-hook             #'parinfer-mode)
        (add-hook 'lisp-mode-hook             #'parinfer-mode)
        (add-hook 'lisp-interaction-mode-hook #'parinfer-mode)
        (add-hook 'scheme-mode-hook           #'parinfer-mode)))
    #+END_SRC
*** eros (display result of eval as overlay)
    - shows eval-last-sexp as overlay behind the expression evaluated (instead of only minibuffer)
    #+BEGIN_SRC emacs-lisp 
    (use-package eros
      :ensure eros
      :config
      (progn
        (eros-mode 1)))
    #+END_SRC
*** eldoc mode
    - is automatically turned on in emacs 25.x
    #+BEGIN_SRC emacs-lisp
    ;; eldoc-mode shows documentation in the minibuffer when writing code
    ;; http://www.emacswiki.org/emacs/ElDoc
    ;; (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    ;; (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    ;; (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC
    #+BEGIN_SRC emacs-lisp
    ;; function that displays eldoc message into a pos-tip
    (defun gb/eldoc-display-message (format-string &rest args)
      "Display eldoc message near point."
      (when format-string
        (pos-tip-show (apply 'format format-string args) :TIMEOUT 1)))
    ;; make sure that eldoc calls own function
    ;; (setq eldoc-message-function #'gb/eldoc-display-message)
    ;; restore original
    ;; (setq eldoc-message-function #'eldoc-minibuffer-message)

    #+END_SRC
*** eldoc overlay mode
    - displays eldoc in an overlay right before cursor
    - does this all the time, after some delay.
    - this may become anoying
    #+BEGIN_SRC emacs-lisp
    (use-package eldoc-overlay
      :ensure eldoc-overlay
      :after( inline-docs)
      :commands eldoc-overlay-mode)
    #+END_SRC
*** paredit
    #+BEGIN_SRC emacs-lisp
    ;; Automatically load paredit when editing a lisp file
    ;; More at http://www.emacswiki.org/emacs/ParEdit
    (use-package paredit
      :ensure paredit
      :init
      (progn
        (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
        (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
        (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
        (add-hook 'clojure-mode-hook          #'enable-paredit-mode)))

    ;; (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)

    #+END_SRC
*** elisp slime nav
    #+BEGIN_SRC emacs-lisp
    ;; allows navigation M-. and M-, to jump to definition and return back
    (use-package elisp-slime-nav
      :ensure elisp-slime-nav
      :init
      (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook 'elisp-slime-nav-mode))
      )
    #+END_SRC
*** IMPLEMENT lispy
    when cursor is positioned on opening parenthesis or right behind closing parenthesis, special keybinding is applied
    (see also https://github.com/abo-abo/lispy)
**** general keybindings
***** [      move to first enclosing opening parenthesis
***** ]      move to first enclosing closing parenthesis 
      )      
***** C-1    display function doc inline (only if connected to nrepl)
***** C-2    display function parameters of current thing at point (repl connected)
***** }      open square brackets "[]"
***** {      open curly brackets "{}"
***** (      open brackets "()"
***** "      open quotes '""'
**** special keybindings
***** >      barf in
***** <      barf out
      #+BEGIN_SRC emacs-lisp
      (use-package iedit
        :after (rainbow-identifiers))
      (use-package lispy
        :ensure lispy
        :bind (("C-1" . lispy-describe-inline)) ;; make C-1 available even without lispy mode!
        :after ( hydra iedit)
        :config
        (custom-set-faces
         '(lispy-face-hint ((t (:background "gray20" :foreground "#fff3bc")))))
        )
      #+END_SRC
** clojure
*** clojure
    #+BEGIN_SRC emacs-lisp
    ;;;;
    ;; Clojure
    ;;;;


    ;; A little more syntax highlighting
    (use-package clojure-mode-extra-font-locking
      :ensure clojure-mode-extra-font-locking
      :after ( clojure-mode))

    (use-package clojure-mode
      :ensure clojure-mode
      :after ( subword ;; optional, when active, clojure switches to this minor mode too
               flycheck ;; optional, when active, clojure switches to this minor mode too
               paredit ;; optional, when active, clojure switches to this minor mode too
               hideshow ;; for folding namespaces (see below)
               key-chord ;; for defining folding with hide show
               hydra )
      :interpreter "clojure"
      :mode "\\.clj\\'"
      :init (progn
              ;; Enable paredit for Clojure
              (when (package-installed-p 'paredit)
                (add-hook 'clojure-mode-hook 'enable-paredit-mode))

              (when (package-installed-p 'flycheck)
                (add-hook 'clojure-mode-hook 'flycheck-mode))

              ;; This is useful for working with camel-case tokens, like names of
              ;; Java classes (e.g. JavaClassName)
              (when (package-installed-p 'subword)
                (add-hook 'clojure-mode-hook 'subword-mode))

              ;; turn on eldoc for clojure mode
              (add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)

              ;; syntax hilighting for midje
              (add-hook 'clojure-mode-hook
                        (lambda ()
                          (setq inferior-lisp-program "lein repl")
                          (font-lock-add-keywords
                           nil
                           '(("(\\(facts?\\)"
                              (1 font-lock-keyword-face))
                             ("(\\(background?\\)"
                              (1 font-lock-keyword-face))))
                          (define-clojure-indent (fact 1))
                          (define-clojure-indent (facts 1))))

              (defun gb/hs-clojure-mode-hook ()
                (interactive)
                (hs-minor-mode 1)
                (key-chord-define clojure-mode-map "q1" #'hs-toggle-hiding)
                (gb/hs-clojure-hide-namespace-and-folds))

              (add-hook 'clojure-mode-hook #'gb/hs-clojure-mode-hook)
              )
      :config
      (progn
        ;; define hydras

        ;;--------------------------------------------------------------------------------
        (defhydra hydra-all-clojure-refactorings ()
          "all clojure refactorings as hydra menu"
          ("c" hydra-cljr-code-menu/body "code refactorings" :exit t)
          ("n" hydra-cljr-ns-menu/body "namespace refactorings" :exit t)
          ("p" hydra-cljr-project-menu/body "project refactorings" :exit t)
          ("t" hydra-cljr-toplevel-form-menu/body "top level form refactorings" :exit t))

        (defun gb/hs-clojure-hide-namespace-and-folds ()
          "Hide the first (ns ...) expression in the file, and also all
    the (^:fold ...) expressions."
          (interactive)
          (hs-life-goes-on
           (save-excursion
             (goto-char (point-min))
             (when (ignore-errors (re-search-forward "^(ns "))
               (hs-hide-block))

             (while (ignore-errors (re-search-forward "\\^:fold"))
               (hs-hide-block)
               (next-line)))))

        ))
    #+END_SRC
*** flycheck-clojure
    #+BEGIN_SRC emacs-lisp
    (use-package flycheck-clojure
      :ensure flycheck-clojure
      :after (flycheck clojure-mode))
    #+END_SRC
*** cider
    #+BEGIN_SRC emacs-lisp
    ;;;;
    ;; Cider
    ;;;;
    (use-package cider
      :ensure cider
      :commands cider-jack-in
      :after ( clojure-mode
               company ;; optional for completion
               flycheck-clojure ;; optional for checking on the fly
               rainbow-delimiters ;; optional minor mode to switch on
               paredit ;; optional paredit minor mode to switch to
               spinner)
      :bind (:map clojure-mode-map
                  ("C-c C-v" . cider-start-http-server)
                  ("C-M-r" . cider-refresh)
                  ("C-c u" . cider-user-ns)
                  :map cider-mode-map
                  ("C-c u" . cider-user-ns))
      :init (progn
              ;; provides minibuffer documentation for the code you're typing into the repl
              (add-hook 'cider-mode-hook 'turn-on-eldoc-mode)

              ;; add company hooks
              (when (package-installed-p 'company)
                (add-hook 'cider-repl-mode-hook #'company-mode)
                (add-hook 'cider-mode-hook #'company-mode))

              ;; enable paredit in your REPL
              (when (package-installed-p 'paredit) (add-hook 'cider-repl-mode-hook 'paredit-mode))

              ;; make delimiters colorful
              (when (package-installed-p 'rainbow-delimiters)  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

              ;; Replace return key with newline-and-indent when in cider mode.
              (add-hook 'cider-mode-hook '(lambda () (local-set-key (kbd "RET") 'newline-and-indent)))

              ;; Use clojure mode for other extensions
              (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
              (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
              ;; (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode)) ;; might collide with clojure mode check of current major mode!!
              (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))

              (autoload 'cider--make-result-overlay "cider-overlays")

              (defun endless/eval-overlay (value point)
                (cider--make-result-overlay (format "%S" value)
                  :where point
                  :duration 'command)
                ;; Preserve the return value.
                value)

              (advice-add 'eval-region :around
                          (lambda (f beg end &rest r)
                            (endless/eval-overlay
                             (apply f beg end r)
                             end)))

              (advice-add 'eval-last-sexp :filter-return
                          (lambda (r)
                            (endless/eval-overlay r (point))))

              (advice-add 'eval-defun :filter-return
                          (lambda (r)
                            (endless/eval-overlay
                             r
                             (save-excursion
                               (end-of-defun)
                               (point)))))

              ;; these help me out with the way I usually develop web apps
              (defun cider-start-http-server ()
                (interactive)
                (cider-load-current-buffer)
                (let ((ns (cider-current-ns)))
                  (cider-repl-set-ns ns)
                  (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
                  (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))

              (defun cider-refresh ()
                (interactive)
                (cider-interactive-eval (format "(user/reset)")))

              (defun cider-user-ns ()
                (interactive)
                (cider-repl-set-ns "user"))

              )
      :config
      (progn

        ;; try to display some context information additionally to regular eldoc
        (setq cider-eldoc-display-context-dependent-info t)

        ;; don't autoinject, because refactor-nrepl is injected, too, which fails to load
        ;; for (java 1.8, clojure 1.9, cider 0.17.0, lein 2.8.1)
        (setq cider-inject-dependencies-at-jack-in t)

        ;; use 1.9.0 if autoinjecting during cider startup
        (setq cider-jack-in-auto-inject-clojure "1.9.0")

        ;; make sure that nrepl does not automatically scroll down!
        (setq cider-repl-scroll-on-output nil)
        ;; use pretty print output in repl
        (setq cider-repl-use-pretty-printing t)

        ;; go right to the REPL buffer when it's finished connecting
        (setq cider-repl-pop-to-buffer-on-connect t)

        ;; When there's a cider error, show its buffer and switch to it
        (setq cider-show-error-buffer t)
        (setq cider-auto-select-error-buffer t)

        ;; Where to store the cider history.
        (setq cider-repl-history-file (concat user-emacs-directory "cider-history"))
        ;; keep that much history
        (setq cider-repl-history-size 1000)
        ;; Wrap when navigating history.
        (setq cider-repl-wrap-history t)

        ;; do flycheck setup for clojure
        (when (package-installed-p 'flycheck-clojure)  (flycheck-clojure-setup))

        ))
    #+END_SRC
*** helm-cider
    #+BEGIN_SRC emacs-lisp
    (use-package helm-cider
      :ensure helm-cider
      :after ( helm cider)
      :config
      (helm-cider-mode 1))
    #+END_SRC
*** litable
    #+BEGIN_SRC emacs-lisp
    ;; To start this up, simply enable the litable minor mode in the buffer by calling
    ;; M-x litable-mode.
    (use-package litable
      :after ( clojure-mode))

    ;; Litable keeps a list of pure functions as a safeguard for unwanted evaluations.
    ;; A function must first be accepted into this list (using M-x litable-accept-as-pure)
    ;; before it can be evaluated on-the-fly. You should take care of what function you accept
    ;; as pure to avoid any unfortunate accidents. Also, note that the pure functions list
    ;; persists across sessions.

    #+END_SRC
*** clojars
    - search clojars for libraries (M-x clojars)
    #+BEGIN_SRC emacs-lisp
    (use-package clojars
      :after ( clojure-mode))
    #+END_SRC
*** expectations
    #+BEGIN_SRC emacs-lisp :tangle no
    ;;================================================== clojure
    ;; clojure expectations mode
    ;;   (use-package expectations-mode
    ;;     :after ( clojure-mode)
    ;;     :config
    ;;     (setenv "EXPECTATIONS_COLORIZE" "false"))
    #+END_SRC
*** clj-refactor
    #+BEGIN_SRC emacs-lisp
    (use-package inflections
      :ensure inflections)
    (use-package peg
      :ensure peg)
    (use-package edn
      :ensure edn
      :after ( peg))
    (use-package clj-refactor
      :ensure clj-refactor
      :after ( hydra s seq yasnippet paredit multiple-cursors clojure-mode cider edn inflections)
      :init
      (defun gb/clojure-mode-hook ()
        (clj-refactor-mode 1)
        (yas-minor-mode 1) ; for adding require/use/import
        (cljr-add-keybindings-with-prefix "C-c C-m"))

      (add-hook 'clojure-mode-hook #'gb/clojure-mode-hook))
    #+END_SRC
*** typed clojure
    #+BEGIN_SRC emacs-lisp
    (use-package typed-clojure-mode
      :after ( clojure-mode subword)
      :ensure typed-clojure-mode
      :init
      (add-hook 'clojure-mode-hook 'typed-clojure-mode))
    #+END_SRC
*** org babel clojure
    #+BEGIN_SRC emacs-lisp

    #+END_SRC
** cypher mode (neo4j)
   #+BEGIN_SRC emacs-lisp
   (use-package cypher-mode
     :defer 5)
   #+END_SRC
** eclim eclipse emacs integration (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package eclim
     :disabled t
     :config
     (global-eclim-mode)
     (custom-set-variables
      '(eclim-eclipse-dirs '("/Applications/Eclipse.app/Contents/Eclipse"))
      '(eclim-executable "/Applications/Eclipse.app/Contents/Eclipse/plugins/org.eclim_2.5.0/bin/eclim")))

   (use-package company-emacs-eclim
     :after ( eclim company)
     :disabled t
     :config
     (company-emacs-eclim-setup)
     (global-company-mode t))

   (use-package eclimd
     :after ( eclim)
     :disabled t)
   #+END_SRC
** elixir
   #+BEGIN_SRC emacs-lisp
   (use-package elixir-mode
     :ensure elixir-mode)
   #+END_SRC
** elm
   #+BEGIN_SRC emacs-lisp
   (use-package elm-mode
     :ensure elm-mode)
   #+END_SRC
** erlang
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package erlang
     :ensure erlang)
   #+END_SRC
**** erlang company
     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ivy-erlang-complete
       :ensure ivy-erlang-complete
       :after (ivy counsel erlang async))
     (use-package company-erlang
       :ensure company-erlang
       :after ( erlang ivy-erlang-complete company))
     #+END_SRC
** groovy
   #+BEGIN_SRC emacs-lisp
   (use-package groovy-mode
     :commands groovy-mode
     :ensure groovy-mode
     :init
     (progn
       ;; make sure for some labeled parameters in groovy to indent with 4
       (add-hook 'groovy-mode-hook
                 (lambda ()
                   (c-set-offset 'label 4)))))

   #+END_SRC
** kotlin
   #+BEGIN_SRC emacs-lisp
   (use-package kotlin-mode)
   (use-package flycheck-kotlin
     :after (kotlin-mode))
   (use-package ob-kotlin
     :after (kotlin-mode org))
   #+END_SRC
** haskell
   #+BEGIN_SRC emacs-lisp
   (use-package haskell-mode
     :ensure haskell-mode
     :bind (:map haskell-mode-map
                 ("C-c C-l" . haskell-process-load-file)
                 ("C-c C-n C-t" . haskell-process-do-type)
                 ("C-c C-n C-i" . haskell-process-do-info)
                 ("C-c h" . haskell-hoogle))
     :init
     (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
     (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
     (add-to-list 'exec-path "~/.local/bin"))
   #+END_SRC
*** company-ghci
    #+BEGIN_SRC emacs-lisp
    (use-package company-ghci
      :ensure company-ghci
      :after ( company haskell-mode)
      :init
      (push 'company-ghci company-backends)
      (add-hook 'haskell-mode-hook 'company-mode)
      (add-hook 'haskell-interactive-mode-hook 'company-mode))
    #+END_SRC
*** dante (intero fork, complete development environment for haskell)
    #+BEGIN_SRC emacs-lisp
    (use-package dante
      :ensure dante
      :after ( haskell-mode company flycheck s f dash)
      :commands 'dante-mode
      :init
      (add-hook 'haskell-mode-hook 'dante-mode)
      (add-hook 'haskell-mode-hook 'flycheck-mode))
    #+END_SRC
*** intero (complete development environment for haskell)
    - see [[https://commercialhaskell.github.io/intero/][here]]
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package intero
      :after ( haskell-mode company flycheck)
      :init
      (add-hook 'haskell-mode-hook 'intero-mode)
      (when (fboundp 'easy-escape-minor-mode) ;; make sure to disable easy escaping here (if present)
        (add-hook 'inter-mode (lambda() (easy-escape-minor-mode -1)))))
    #+END_SRC
*** flycheck-haskell (currently disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package flycheck-haskell
      :ensure flycheck-haskell
      :after ( haskell-mode flycheck))
    #+END_SRC
** web-mode
   #+BEGIN_SRC emacs-lisp
   (use-package web-mode
     :ensure web-mode
     :mode (("\\.phtml\\'" . web-mode)
            ("\\.tpl\\.php\\'" . web-mode)
            ("\\.[agj]sp\\'" . web-mode)
            ("\\.as[cp]x\\'" . web-mode)
            ("\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.dhtml\\'" . web-mode)
            ("\\.html?\\'" . web-mode))
     :config
     (progn
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)))
   #+END_SRC
** typescript
   #+BEGIN_SRC emacs-lisp
   ;; run ts repl in typescript-mode, allowing to send expressions to the interpreter
   ;; M-x run-ts ;; starts a comint buffer with repl
   (use-package ts-comint
     :ensure ts-comint
     :after ( typescript-mode)
     :init
     (setenv "NODE_NO_READLINE" "1")
     (defun run-tsun ()
       (interactive)
       (let ((buf (get-buffer "*Typescript*")))
         (if buf
             (switch-to-buffer buf)
           (progn
             (ansi-term "/bin/zsh" "Typescript")
             (comint-send-string "*Typescript*" "tsun\n")))))
     (add-hook 'typescript-mode-hook
               (lambda ()
                 (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
                 (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
                 (local-set-key (kbd "C-c b") 'ts-send-buffer)
                 (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
                 (local-set-key (kbd "C-c l") 'ts-load-file-and-go))))

   (use-package typescript-mode
     :ensure typescript-mode
     :mode (("\\.ts\\'" . typescript-mode)))

   (use-package tide
     :ensure tide
     :after ( typescript-mode)
     :init (progn
             (add-hook 'typescript-mode-hook #'gb/setup-tide-mode)
             (add-hook 'js2-mode-hook #'gb/setup-tide-mode)
             ;; (add-hook 'tide-mode-hook #'gb/setup-tide-mode)
             (add-hook 'web-mode-hook
                       (lambda ()
                         (when (string-equal "tsx" (file-name-extension buffer-file-name))
                           (gb/setup-tide-mode))))
             )
     :config
     (progn
       (defun gb/setup-tide-mode ()
         (interactive)
         (tide-setup)
         (flycheck-mode +1)
         (setq flycheck-check-syntax-automatically '(save mode-enabled))
         (eldoc-mode +1)
         (tide-hl-identifier-mode +1)
         (company-mode +1)
         (subword-mode +1)
         (setq typescript-indent-level 2))

       ;; aligns annotation to the right hand side
       (setq company-tooltip-align-annotations t)

       ;; use 2 for indent
       (setq typescript-indent-level 2)

       (setq json-reformat:indent-width 2)
       (setq js-indent-level 2)
       ;; formats the buffer before saving
       ;; (add-hook 'before-save-hook 'tide-format-before-save)

       ;; (flycheck-add-next-checker 'javascript-eslint 'jsx-tide 'append)
       ))
   #+END_SRC
** java script
   #+BEGIN_SRC emacs-lisp
   ;; (use-package tagedit)
   (use-package js2-mode
     :ensure js2-mode
     :mode (("\\.js\\'" . js2-mode)
            ("\\.jsx?\\'" . js2-jsx-mode))
     :config (setq js-indent-level 2))
   ;; (use-package js
   ;;   :after ( flycheck tagedit)
   ;;   :defer 5
   ;;   :config
   ;;   (add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
   ;;   (when (package-installed-p 'subword)
   ;;     (add-hook 'js-mode-hook 'subword-mode)
   ;;     (add-hook 'html-mode-hook 'subword-mode))
   ;;   (when (package-installed-p 'flycheck)
   ;;     (add-hook 'js-mode-hook 'flycheck-mode))
   ;;   (setq js-indent-level 2)
   ;;   (eval-after-load "sgml-mode"
   ;;     '(progn
   ;;        (require 'tagedit)
   ;;        (tagedit-add-paredit-like-keybindings)
   ;;        (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))


   ;;   ;; coffeescript
   ;;   (add-to-list 'auto-mode-alist '("\\.coffee.erb$" . coffee-mode))
   ;;   (when (package-installed-p 'subword)
   ;;     (add-hook 'coffee-mode-hook 'subword-mode))
   ;;   (add-hook 'coffee-mode-hook 'highlight-indentation-current-column-mode)
   ;;   (add-hook 'coffee-mode-hook
   ;;             (defun coffee-mode-newline-and-indent ()
   ;;               (define-key coffee-mode-map "\C-j" 'coffee-newline-and-indent)
   ;;               (setq coffee-cleanup-whitespace nil)))
   ;;   (custom-set-variables
   ;;    '(coffee-tab-width 4)))
   #+END_SRC
** java
*** other
    #+BEGIN_SRC emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.xtend\\'" . java-mode))
    #+END_SRC
*** jde (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
     ;; Add java development extension to loadpath
     ;;  (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp")
     ;;  (load "jde")

     ;; (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp/")
     ;; (use-package jde
     ;;   :disabled t
     ;;   :loader :path
     ;;   :config
     ;;   (defadvice custom-buffer-create  (after jde-set-default-dir-to-project-dir (options &optional name description) activate)
     ;;     "When customizing jde path variables set the default directory to the jde project file directory. This makes file completion work for relative paths."
     ;;     (when (and (listp options) ;; we want options to look like (list (list symbol 'custom-variable)), see customize-variable
     ;;                (eq (length options) 1)
     ;;                (listp (car options))
     ;;                (eq (length (car options)) 2)
     ;;                (or (eq 'custom-variable (cadar options)) (eq 'jde-custom-variable (cadar options))))
     ;;       (let ((symbol (caar options)))
     ;;         (if (memq symbol '(jde-global-classpath jde-sourcepath));; or we could use (jde-symbol-p symbol)
     ;;             ;; stolen from jde-project-file: find the project file where this symbol is saved
     ;;             (let* ((project-file-paths (nreverse (jde-find-project-files default-directory))))
     ;;               (when project-file-paths
     ;;                 (when (jde-save-needs-saving-p symbol project-file-paths)
     ;;                   ;; set the current directory to the directory the project file is in, ie the root for relative paths
     ;;                   (setq default-directory (expand-file-name ".." (caar (get symbol 'jde-project)))))))))))
     ;;   )

     ;; ;; (global-set-key (kbd "C-<tab>") 'jde-complete);; currently overshadowed by yasnippets


   #+END_SRC
*** java decompiler
    #+BEGIN_SRC emacs-lisp :tangle no
      ;; (add-to-list 'load-path "~/.emacs.d/java/")
      ;; (use-package javad
      ;;   :after ( javap-mode)
      ;;   :loader :path
      ;;   :defer 5
      ;;   :config
      ;;   ;; allows viewing decompiled version of a class file if jad is installed!
      ;;   ;;(load "~/.emacs.d/java/javad.el")

      ;;   (defun javad-find-class (&rest args)
      ;;     (interactive)
      ;;     (if (not (string= ".class" (substring (buffer-file-name) -6 nil)))
      ;;         nil
      ;;       (message "Show class as: [b]ytecode, [d]ecompiled or [i]dentity?")
      ;;       (let ((resp (read-char)))
      ;;         (cond
      ;;          ((= resp 98) (progn (javap-buffer) nil))
      ;;          ((= resp 100) (progn (javad-buffer) nil))
      ;;          (t nil))
      ;;         (let ((buff (current-buffer)))
      ;;           (switch-to-buffer buff)))))

      ;;   (add-hook 'find-file-hook 'javad-find-class)
      ;;   )
    #+END_SRC
*** java programming mode
    #+BEGIN_SRC emacs-lisp
     (use-package javap-mode
       :ensure javap-mode)
    #+END_SRC
** php 
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package php-mode
     
     :init
     ;; make sure that indentation of arrays is more readable
     (add-hook 'php-mode-hook (lambda ()
                                (defun ywb-php-lineup-arglist-intro (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (+ (current-column) c-basic-offset))))
                                (defun ywb-php-lineup-arglist-close (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (current-column))))
                                (c-set-offset 'arglist-intro 'ywb-php-lineup-arglist-intro)
                                (c-set-offset 'arglist-close 'ywb-php-lineup-arglist-close))))


 #+END_SRC
** python
 #+BEGIN_SRC emacs-lisp
   (use-package python)
   (use-package find-file-in-project
     :after ( ivy))
   (use-package elpy
     :after ( org flycheck find-file-in-project python)
     :mode (("\\.py\\'" . python-mode))
     :init
     (add-hook 'python-mode-hook #'elpy-enable)
     (add-hook 'python-mode-hook #'flycheck-mode))
 #+END_SRC
** scala ensime (enhanced scala mode for emacs, currntely disabled)
 #+BEGIN_SRC emacs-lisp :tangle no
 (use-package ensime
   :ensure ensime
   :after ( sbt-mode)
   :commands ensime
   :init
   (add-hook 'scala-mode-hook 'ensime-mode))
 #+END_SRC
** xml
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package nxml-mode
       :mode (("\\.xslt\\'" . nxml-mode)
              ("\\.xml\\'" . nxml-mode)))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (use-package xml+
       :after ( dash))
   #+END_SRC
* programming related
** editorconfig
   #+BEGIN_SRC emacs-lisp
      (use-package editorconfig
        :ensure editorconfig
       :config (editorconfig-mode 1))
   #+END_SRC
** flymake
   #+BEGIN_SRC emacs-lisp
   (use-package flymake
     :ensure flymake)
   (use-package flymake-easy
     :ensure flymake-easy
     :after ( flymake))
   (use-package flymake-yaml
     :ensure flymake-yaml
     :after ( flymake-easy)
     :init (add-hook 'yaml-mode-hook 'flymake-yaml-load))
   (use-package flymake-shell
     :ensure flymake-shell
     :after ( flymake-easy)
     :init (add-hook 'sh-set-shell-hook 'flymake-shell-load))
   (use-package flymake-json
     :ensure flymake-json
     :after ( flymake-easy)
     :init (add-hook 'js-mode-hook 'flymake-json-maybe-load))
   #+END_SRC
** flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure flycheck
       :config
       (progn
         (define-key flycheck-mode-map flycheck-keymap-prefix nil)
         (setq flycheck-keymap-prefix (kbd "C-c k"))
         (define-key flycheck-mode-map flycheck-keymap-prefix
           flycheck-command-map)
         ;; (add-hook 'after-init-hook 'global-flycheck-mode)
         ))
     (use-package flycheck-tip
       :ensure flycheck-tip
       :after ( flycheck))
     (use-package flycheck-pos-tip
       :ensure flycheck-pos-tip
       :after ( flycheck)
       :config
       ;; (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
       (flycheck-pos-tip-mode)
       (setq flycheck-tip-avoid-show-func nil))
   #+END_SRC
** projects
*** perspective (disabled - collision with company-box)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package perspective
     :config
     (progn
       ;; (persp-mode 1)
       (custom-set-faces
        '(persp-selected-face ((t (:foreground "Grey70")))))))
 #+END_SRC
*** projectile
    - see [[http://batsov.com/projectile/][here]]
 #+BEGIN_SRC emacs-lisp
 (use-package projectile
    :ensure projectile
    :config
   ;; projectile everywhere!
   ;; (projectile-global-mode)
   )
 #+END_SRC
*** persp-projectile (disabled - collision with company-box)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package persp-projectile
     :after ( projectile perspective helm)
     :bind (
       ;; switch project on super-s
       :map  projectile-mode-map
       ("s-s" . helm-projectile-switch-project)))
 #+END_SRC
** git
*** magithub
    - disabled because ghub+ fails to load (some interface failure to git hub)
    #+BEGIN_SRC emacs-lisp :tangle no
    (if hub-installed
    (use-package magithub
      :after ( magit ghub+ apiwrap)
      :config
      (progn (magithub-feature-autoinject t))))
    #+END_SRC
*** magit (and more)
 #+BEGIN_SRC emacs-lisp
  (use-package ediff
    :ensure ediff
    :config
    ;; make sure that ediff session does not open control window in separate frame, which mixes up exwm
    (setq ediff-window-setup-function (quote ediff-setup-windows-plain)))

     ;; TODO move this function to some general function pool
     (defun gb/display-buffer-fullframe (buffer alist)
       "Display BUFFER in fullscreen.

          ALIST is a `display-buffer' ALIST.

          Return the new window for BUFFER."
       (let ((window (display-buffer-pop-up-window buffer alist)))
         (when window
           (delete-other-windows window))
         window))

     (use-package magit-popup
       :ensure magit-popup
       :after ( async))
     (use-package magit
       :ensure magit
       :after ( counsel helm async dash with-editor git-commit magit-popup)
       :commands magit-status
       :bind (
         ("C-c v s" . magit-status)
         :map magit-mode-map
         ("C-x f" . counsel-git))
       :init
       (progn

         (defun gb/magit-log-trace-definition ()
           "Show log for the definition marked."
           (interactive)
           (let ((fname  (or (magit-file-relative-name)
                            (user-error "Buffer isn't visiting a file")))
                 (fn (or (buffer-substring-no-properties (region-beginning) (region-end))
                         (user-error "function not marked")))
                 (rev (or magit-buffer-refname
                         (magit-get-current-branch)
                         "HEAD")))
             (magit-log-trace-definition fname fn rev)))

         (defun gb/disable-smartscan ()
           ""
           (smartscan-mode -1))

         (add-hook 'magit-mode-hook 'gb/disable-smartscan))
       :config
       (require 'magit-mode)
       (setq magit-completing-read-function 'helm--completing-read-default)  ;; magit-ido-completing-read)
       (setq magit-fetch-arguments (quote ("--prune")))
       (setq magit-item-highlight-face nil)
       (setq magit-last-seen-setup-instructions "1.4.0")
       (setq magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n200")))
       (setq magit-pull-arguments (quote ("--rebase")))
       (setq magit-use-overlays nil)
      (setq magit-diff-refine-hunk t)
      (setq magit-diff-adjust-tab-width t)
      (setq magit-diff-highlight-trailing t)
      (setq magit-diff-hide-trailing-cr-characters t)

       ;; make sure that magit closes all other windows on the frame
       (when (fboundp 'gb/display-buffer-fullframe)
         (add-to-list 'display-buffer-alist
                      `(,(rx "*magit: ")
                        (gb/display-buffer-fullframe)
                        (reusable-frames . nil)))))

     ;; show git relevant change info in the fringe of the frame
     ;; git-gutter-fringe works with nlinum-mode !
     (use-package git-gutter
       :ensure git-gutter
       :config
       (progn
         (custom-set-faces
          '(git-gutter:unchanged ((t (:background "orange4")))))))

     (use-package git-gutter-fringe
       :ensure git-gutter-fringe
       :after ( git-gutter)
       :config (global-git-gutter-mode +1))

     (use-package magit-gh-pulls
       :after ( magit)
       :disabled t
       :defer 40
       :init
       (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))

     (use-package magit-filenotify
       :after ( magit)
       :disabled t
       :defer 40
       :init
       (add-hook 'after-save-hook 'magit-after-save-refresh-status)
       (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))

     ;; use automatic file notification to update magit status buffer
     ;; (add-hook 'magit-status-mode-hook 'magit-filenotify-mode )
     ;; currently no file notification package is available
     ;; Activate the mode inside the magit-status buffer by calling M-x magit-filenotify-mode [RET]. Repeat the same step to deactivate it again.
     ;; To always enable the mode when opening the magit-status buffer add magit-filenotify-mode to the magit-status-mode-hook.

     (use-package magit-gitflow
       :ensure magit-gitflow
       :after ( magit)
       :init
       (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
     ;; C-f in magit status buffer will invoke gitflow action selector.

     (use-package git-blamed
       :ensure git-blamed
       ) ;; enter git-blamed-mode colors background of lines according to commit (and should echo some info depending on cursor)

     (use-package git-timemachine
       :ensure git-timemachine
       :commands git-timemachine
       :config
       (defun gb/git-timemachine-show-selected-revision ()
         "Show last (current) revision of file."
         (interactive)
         (let (collection)
           (setq collection
                 (mapcar (lambda (rev)
                           ;; re-shape list for the ivy-read
                           (cons (concat (substring (nth 0 rev) 0 7) "|" (nth 5 rev) "|" (nth 6 rev)) rev))
                         (git-timemachine--revisions)))
           (ivy-read "commits:"
                     collection
                     :action (lambda (rev)
                               (git-timemachine-show-revision rev)))))

       (defun gb/git-timemachine ()
         "Open git snapshot with the selected version.  Based on ivy-mode."
         (interactive)
         (unless (featurep 'git-timemachine)
           (require 'git-timemachine))
         (git-timemachine--start #'gb/git-timemachine-show-selected-revision)))


 #+END_SRC
*** magit todo
    - shows todos within the source code in magit overview
     #+BEGIN_SRC emacs-lisp
     (use-package magit-todos
       :ensure magit-todos
       :after (a anaphora async dash f hl-todo magit pcre2el s)
       :config (magit-todos-mode))
     #+END_SRC
*** magit imerge
    - will allow for incremental merges
    - adds 'i' on the merge popup itself for starting incremental merges
    - incremental merges have the benefit of having minimal conflicts during one merging session,
      whenever one merge conflict is resolved, this can be persisted in the repo (can be published, left off, picked up again ...)
    - for more information look [[https://github.com/mhagger/git-imerge][here]]
    #+BEGIN_SRC emacs-lisp
      (if git-imerge-installed
      (use-package magit-imerge
        :after ( magit)))
    #+END_SRC
*** magit lfs
    #+BEGIN_SRC emacs-lisp
    (when git-lfs-installed 
      (use-package magit-lfs
        :defer 40
        :after ( magit)))
    #+END_SRC
** gitignore (creation with helm)
   simply call helm-gitignore and select language for which to create this gitignore
 #+BEGIN_SRC emacs-lisp
   (use-package helm-gitignore
     :commands helm-gitignore
     :after ( helm))
 #+END_SRC
** IMPLEMENT code library
   - [ ] add code mappings (java, clojure)
   - [ ] eval usefulness
 #+BEGIN_SRC emacs-lisp
   (use-package code-library)
 #+END_SRC
** speedbar (currently disabled, see sidebar)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package sr-speedbar
     :after ( bind-key)
     :config
     ;;================================================== sr-speedbar
     (setq sr-speedbar-right-side nil) ;; put on left side
     (setq sr-speedbar-default-width 50)
     (setq sr-speedbar-auto-refresh nil)
     (setq speedbar-use-images nil)
     (setq speedbar-update-flag nil)
     (setq speedbar-indentation-width 2)
     (setq speedbar-show-unknown-files t)

     (sr-speedbar-open) ;; gnus shows errors if speedbar was not open once (maybe because of the advice following delete other window)
     (sr-speedbar-toggle) ;; but since I dont want it to show in the beginning its toggled to hide
     ;; (other-window 1) ;; move cursor on to the scratch buffer
     ;; (enlarge-window-horizontally 32) ;; make sure that the "main" window is larger than the speed bar window (even when maximized later on)

     ;; adjustments for speedbar behaviour (speedbar is not becoming main window!)
     (defadvice delete-other-windows (after my-sr-speedbar-delete-other-window-advice activate)
       "Check whether we are in speedbar, if it is, jump to next window."
       (let ()
         (when (and (sr-speedbar-window-exist-p sr-speedbar-window)
                    (eq sr-speedbar-window (selected-window)))
           (other-window 1)
           )))
     (ad-enable-advice 'delete-other-windows 'after 'my-sr-speedbar-delete-other-window-advice)
     (ad-activate 'delete-other-windows)
     ;; (bind-key "s-a" 'sr-speedbar-toggle)
     )
 #+END_SRC
** markdown
   - see usage documentation on [[http://jblevins.org/projects/markdown-mode/][homepage]]
   #+BEGIN_SRC emacs-lisp
   (use-package markdown-mode
     :ensure markdown-mode
     :commands (markdown-mode gfm-mode)
     :mode (("\\.text\\'" . markdown-mode)
            ("\\.markdown\\'" . markdown-mode)
            ("README\\.md\\'" . gfm-mode)
            ("\\.md\\'" . markdown-mode))
     :config
     (progn))
   #+END_SRC
** markdown code block edit
   - allows C-' in a markdown code block to edit code in a separate buffer (like org mode does)
   #+BEGIN_SRC emacs-lisp
     (use-package edit-indirect)
     (use-package markdown-edit-indirect
       :after ( markdown-mode edit-indirect)
       :config
       (progn
         (eval-after-load 'markdown-mode
           '(define-key markdown-mode-map (kbd "C-c '") 'markdown-edit-indirect))))
   #+END_SRC
** plantuml
   - https://github.com/skuro/plantuml-mode
   #+BEGIN_SRC emacs-lisp 
       (custom-set-variables
        '(org-plantuml-jar-path (concat user-emacs-directory "plantuml.jar"))
        '(plantuml-jar-path (concat user-emacs-directory "plantuml.jar")))
     (use-package plantuml-mode
       :ensure plantuml-mode
       :after ( org)
       :mode ("\\.\\(puml\\|plantuml\\)\\'" . plantuml-mode)
       :config
       ;; (autoload 'plantuml-mode "plantuml-mode" nil t)
       (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
       ;; (add-to-list 'auto-mode-alist '("\\.puml$" . plantuml-mode))
       ;;(add-to-list 'auto-mode-alist '("\\.plantuml$" . plantuml-mode))
       )
     (use-package flycheck-plantuml
       :ensure flycheck-plantuml
        :after ( flycheck plantuml-mode)
        :defer t
        :init
        (flycheck-plantuml-setup)
          ;; (add-to-list 'puml-mode-hook #'(lambda () (message "enable flycheck")))
        )
   #+END_SRC
** dumb jump to definition
    - C-M g    jump to definition
    - C-M p    jump back
    - C-M q    like jump but shows tooltip
    #+BEGIN_SRC emacs-lisp
      (use-package dumb-jump
        :ensure dumb-jump
        :config
        (dumb-jump-mode))
    #+END_SRC
** cucumber tests for emacs
   mode for editing cucumber tests (*.feature)
   see [[https://github.com/ecukes/ecukes][here]]
   example project [[file:~/devel/emacs/Cask][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package feature-mode
     :defer 7)
   (use-package ecukes
     :defer 7)
   (use-package espuds
     :defer 7)
   #+END_SRC
* shell
** eshell
   #+begin_src emacs-lisp 
     ;; provide eldoc within eshell (and some more help)
     (use-package esh-help
       :after ( eshell)
       :config (setup-esh-help-eldoc))
     ;; provide z command in eshell  
     (use-package eshell-z
       :after ( eshell))
     (use-package eshell
       :config
       (progn
         (setq eshell-cmpl-autolist t)
         (setq eshell-cmpl-cycle-completions nil)
         (setq eshell-show-lisp-completions t)

         (defun pcmpl-git-commands ()
           "Return the most common git commands by parsing the git output."
           (with-temp-buffer
             (call-process-shell-command "LC_ALL=en_US git" nil (current-buffer) nil "help" "--all")
             (goto-char 0)
             (search-forward "available git commands")
             (let (commands)
               (while (re-search-forward
                       "^[[:blank:]]+\\([[:word:]-.]+\\)[[:blank:]]*\\([[:word:]-.]+\\)?"
                       nil t)
                 (push (match-string 1) commands)
                 (when (match-string 2)
                   (push (match-string 2) commands)))
               (sort commands #'string<))))

         (defconst pcmpl-git-commands (pcmpl-git-commands)
           "List of `git' commands.")

         (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
           "The `git' command to run to get a list of refs.")

         (defun pcmpl-git-get-refs (type)
           "Return a list of `git' refs filtered by TYPE."
           (with-temp-buffer
             (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
             (goto-char (point-min))
             (let (refs)
               (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
                 (push (match-string 1) refs))
               (nreverse refs))))

         (defun pcmpl-git-remotes ()
           "Return a list of remote repositories."
           (split-string (shell-command-to-string "git remote")))

         (defun pcomplete/git ()
           "Completion for `git'."
           ;; Completion for the command argument.
           (pcomplete-here* pcmpl-git-commands)
           (cond
            ((pcomplete-match "help" 1)
             (pcomplete-here* pcmpl-git-commands))
            ((pcomplete-match (regexp-opt '("pull" "push")) 1)
             (pcomplete-here (pcmpl-git-remotes)))
            ;; provide branch completion for the command `checkout'.
            ((pcomplete-match "checkout" 1)
             (pcomplete-here* (append (pcmpl-git-get-refs "heads")
                                      (pcmpl-git-get-refs "tags"))))
            (t
             (while (pcomplete-here (pcomplete-entries))))))

         (defun company-eshell-history (command &optional arg &rest ignored)
           (interactive (list 'interactive))
           (cl-case command
             (interactive (company-begin-backend 'company-eshell-history))
             (prefix (and (eq major-mode 'eshell-mode)
                          (let ((word (company-grab-word)))
                            (save-excursion
                              (eshell-bol)
                              (and (looking-at-p (s-concat word "$")) word)))))
             (candidates (remove-duplicates
                          (->> (ring-elements eshell-history-ring)
                               (remove-if-not (lambda (item) (s-prefix-p arg item)))
                               (mapcar 's-trim))
                          :test 'string=))
             (sorted t)))

         ;; (add-to-list 'company-backends 'company-eshell-history)
         ))
   #+end_src
** settings
   #+BEGIN_SRC emacs-lisp
     ;; make sure M-x shell opens into currently open window (and does not open a new one)
     (add-to-list 'display-buffer-alist
                  '("^\\*shell.*\\*$" . (display-buffer-same-window)))
     (require 'comint) ;; part of emacs
     (setq comint-password-prompt-regexp
             (concat comint-password-prompt-regexp
                     "\\|^.* passphrase.*\\'"))

     (setq-default sh-basic-offset 2)
     (setq-default sh-indentation 2)

     (setq warning-suppress-types '((undo discard-info)))
   #+END_SRC
** tmux (disabled for now)
   - enables interaction with tmux sessions
   - see https://github.com/syohex/emacs-emamux
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package emamux
       :config
       ;; (global-set-key (kbd "C-z") emamux:keymap)
       (custom-set-variables
        '(emamux:completing-read-type 'helm)))
   #+END_SRC
** shell here
   #+BEGIN_SRC emacs-lisp
     ;; open a shell at the current directory
     (use-package shell-here
       :bind (("C-c s !" . shell-here)))
     ;;      (define-key (current-global-map) "\C-c!" 'shell-here) ;
   #+END_SRC
** shell ansi colors configuration (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ansi-color
       :init (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
       :config
       (setq ansi-color-names-vector
             ["black" "tomato" "PaleGreen2" "gold1"
              "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])
       (setq ansi-color-map (ansi-color-make-color-map))

       (add-to-list 'comint-output-filter-functions 'ansi-color-process-output))
   #+END_SRC
** xterm color
   #+BEGIN_SRC emacs-lisp
     (use-package xterm-color
       :init (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter)
       :config
       ;; eterm-color-256 expects existence of this function
       ;; detected in: eterm-color-256: 0.3.12, xterm-color 1.7
       (defalias 'xterm-color--256 'xterm-color-256)
       (progn (setq comint-output-filter-functions (remove 'ansi-color-process-output comint-output-filter-functions))))
   #+END_SRC
** friendly iteractive shell
   #+BEGIN_SRC emacs-lisp
     (defun shell-fish ()
       "start a friendly interactive shell (fish) within ansi-term"
       (interactive)
       (ansi-term (executable-find "fish")))
   #+END_SRC
** bash completion
   #+BEGIN_SRC emacs-lisp
   (use-package bash-completion
     :config
     (setq bash-completion-prog (s-trim (shell-command-to-string "which bash")))
     (bash-completion-setup))
   #+END_SRC
** shell (bash) checking
   - built in shell editing mode, explicitly initialized here to enable flycheck-mode
   #+BEGIN_SRC emacs-lisp
     (use-package sh-script
       :after ( flycheck)
       :init
       (add-hook 'sh-mode-hook 'flycheck-mode))
   #+END_SRC
** zshell
   #+BEGIN_SRC emacs-lisp
     (defun start-zsh ()
       "start a  z shell within ansi-term"
       (interactive)
       (ansi-term "/usr/local/bin/zsh"))
   #+END_SRC
* ebooks
  #+BEGIN_SRC emacs-lisp
  (use-package ereader
    :after ( xml+ dash)
    :ensure t
    :mode ("\\.epub\\'" . ereader-mode))
  #+END_SRC
* pdf-tooling
  - TODO check whether all that is required tools are installed for pdf tools to function, message if not, install if ok
  #+BEGIN_SRC emacs-lisp
  ;; allow in emacs pdf view/annotate etc.
  ;; if not functional do the following: remove package and restart emacs, then allow rebuild of pdf tooling, restart again
  ;; new: use pdf-tool-install (works with nix os too, has to be a new version of pdf-tools though!)
  ;; old: to install under linux run 'sudo nix-shell -p autoconf automake libpng zlib poppler pkgconfig gcc --run make' in the build folder
  (if (and make-installed (or running-nixos poppler-installed) imagemagick-installed)
      (use-package pdf-tools
        :ensure pdf-tools
        :mode ("\\.pdf$" . pdf-view-mode)
        :init (progn
                ;; (add-hook 'after-init-hook 'pdf-tools-install)
                ;; (add-hook 'pdf-tools-mode-hook 'pdf-isearch-minor-mode)
                (add-hook 'pdf-view-mode-hook 'pdf-misc-minor-mode) ;; misc minor mode offset C-c C-p for printing pdf documents


                ;; copied from http://babbagefiles.blogspot.de/2017/11/more-pdf-tools-tricks.html
                (add-hook 'pdf-view-mode-hook (lambda ()
                                                (pdf-view-midnight-minor-mode))) ; automatically turns on midnight-mode for pdfs

                (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; set the amber profile as default (see below)

                (defun gb/pdf-no-filter ()
                  "View pdf without colour filter."
                  (interactive)
                  (pdf-view-midnight-minor-mode -1)
                  )

                ;; change midnite mode colours functions
                (defun gb/pdf-midnite-original ()
                  "Set pdf-view-midnight-colors to original colours."
                  (interactive)
                  (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values
                  (pdf-view-midnight-minor-mode)
                  )

                (defun gb/pdf-midnite-amber ()
                  "Set pdf-view-midnight-colors to amber on dark slate blue."
                  (interactive)
                  (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; amber
                  (pdf-view-midnight-minor-mode)
                  )

                (defun gb/pdf-midnite-green ()
                  "Set pdf-view-midnight-colors to green on black."
                  (interactive)
                  (setq pdf-view-midnight-colors '("#00B800" . "#000000" )) ; green
                  (pdf-view-midnight-minor-mode)
                  )

                (defun gb/pdf-midnite-colour-schemes ()
                  "Midnight mode colour schemes bound to keys"
                  (local-set-key (kbd "!") (quote gb/pdf-no-filter))
                  (local-set-key (kbd "@") (quote gb/pdf-midnite-amber))
                  (local-set-key (kbd "#") (quote gb/pdf-midnite-green))
                  (local-set-key (kbd "$") (quote gb/pdf-midnite-original))
                  )

                (add-hook 'pdf-view-mode-hook 'gb/pdf-midnite-colour-schemes)


                )
        :config
        (progn
          ;; (setq pdf-info-epdfinfo-program "~/.emacs.d/elpa/pdf-tools-20180428.1527/build/server/epdfinfo")
          (setq pdf-misc-print-programm (s-trim (shell-command-to-string "which lp")))
          (setq pdf-view-display-size (quote fit-page))
          (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge")))))
  #+END_SRC
* rest
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; '(canlock-password "0e8b34f24c62bdf6cc5585ec93c62be865aee099")
   '(coffee-tab-width 4)
   '(cursor-in-non-selected-windows nil)
   '(custom-safe-themes
     (quote
      ("84d2f9eeb3f82d619ca4bfffe5f157282f4779732f48a5ac1484d94d5ff5b279" "4848f52f443b88525a4e2fe4f620a20c40fad90a66a953613be90556b9eb7880" "db790b6031dbc390c8b9318b077f5825302dad9d82925f4c70eaddd22825aafa" "141bdb2503f744acaa2bd8defb015f3c8e9e581ff40ec9ae4f3a27917256edaa" "516ef72a7861d71b39bdd8ae3d2c19628abb916a1456ea93a400cc222f87442a" "05b3ea2f5a8d1913eda3a209bb4bd0091c2aa15e4de64e0580f45d2534428568" "e93f05b3616b9e19a79c3ebd107252684bc88ecb77798617e72443b70aae86d5" "c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223" "a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e" "26614652a4b3515b4bbbb9828d71e206cc249b67c9142c06239ed3418eff95e2" "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default)))
   '(desktop-save nil)
   '(desktop-save-mode nil)
   '(gnutls-verify-error nil)
   '(iedit-toggle-key-default nil) ;; disable C-; binding of iedit that is loaded via lispy
   '(ido-mode nil) ;; disable ido mode
;;   '(initial-frame-alist (quote ((fullscreen . maximized))))
   '(jde-jdk-doc-url "https://docs.oracle.com/javase/8/docs/api/")
   '(jde-jdk-registry
     (quote
      (("1.8.0_40" . "/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home")
       ("1.7.0_40" . "/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home"))))
   '(malabar-repl-grooysh "/usr/local/bin/groovysh")
   '(recentf-max-saved-items 80)
   '(region ((t (:background "gray45" :inverse-video nil))))
   '(rng-schema-locating-files
     (quote
      ((concat user-emacs-directory "ant-mode/ant-schemas.xml") "schemas.xml" "~/devel/xspec-read-only/editors/emacs/schemas.xml" "/Applications/Emacs.app/Contents/Resources/etc/schema/schemas.xml")))
   '(send-mail-function (quote smtpmail-multi-send-it))
   '(tool-bar-mode nil)
   '(truncate-lines nil)
   '(xslt-process-registered-stylesheets nil))

  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(col-highlight ((t (:background "gray63"))))
   '(hi-yellow ((t (:background "gray44"))))
   '(region ((t (:background "gray45" :inverse-video nil))))
   '(popup-isearch-match ((t (:background "RoyalBlue2"))))
   '(term-color-yellow ((t (:background "DarkGoldenrod4" :foreground "#f0c674")))))

  ;; load the color scheme similar to lighttable
  ;; (load-theme 'noctilux t)

  ;; (setq cheat-sheet-locations '("Emacs_Reference_Card.pdf"
  ;;                               "calccard.pdf"
  ;;                               "dired-ref.pdf"
  ;;                               "dired-refcard.gnu.pdf"
  ;;                               "gnus-booklet.pdf"
  ;;                               "gnus-refcard.pdf"
  ;;                               "magitCheatsheet.pdf"
  ;;                               "orgcard.pdf"
  ;;                               "paredit-cheatsheet.pdf"))

  ;; ;; can be either 'right or 'below,
  ;; (setq cheat-sheet-split-mode 'below)

  ;; (defun open-cheat-sheet (file-path)
  ;;   "split depending on customization var cheat-sheet-split-mode and load file from file-path"
  ;;   (cond
  ;;    ((equal cheat-sheet-split-mode 'right) (split-window-right))
  ;;    ((equal cheat-sheet-split-mode 'left) (split-window-left))
  ;;    ;;     ((equal cheat-sheet-split-mode 'above) (split-window-below))
  ;;    ((equal cheat-sheet-split-mode 'below) (split-window-below)))
  ;;   (other-window 1)
  ;;   (find-file file-path)
  ;;   (cond
  ;;    ((equal cheat-sheet-split-mode 'right) (pdf-view-fit-height-to-window))
  ;;    ((equal cheat-sheet-split-mode 'left) (pdf-view-fit-height-to-window))
  ;;    ;;     ((equal cheat-sheet-split-mode 'above) (progn (pdf-view-fit-width-to-window)))
  ;;    ((equal cheat-sheet-split-mode 'below) (pdf-view-fit-width-to-window)))
  ;;   (other-window -1))

  ;; (defun close-cheat-sheet (file-path)
  ;;   "close the cheat sheet that is displayed, deleting the respective window"
  ;;   (with-selected-window
  ;;       (get-buffer-window (get-file-buffer file-path))
  ;;     (delete-window)))

  ;; (defun cheat-sheet-toggle (file-path)
  ;;   "open the given cheatsheet (or close it, if already open)"
  ;;   (let ((fbuf (get-file-buffer file-path)))
  ;;     (if (and fbuf (get-buffer-window fbuf))
  ;;         (close-cheat-sheet file-path)
  ;;       (open-cheat-sheet file-path))))

  ;; (defun cheat-sheet-clojure-toggle ()
  ;;   "open the clojure cheatsheet"
  ;;   (interactive)
  ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/clojure/clojure-cheatsheet-usletter-color.pdf")))

  ;; (defun cheat-sheet-org-toggle ()
  ;;   "open the org-mode cheatsheet"
  ;;   (interactive)
  ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/orgcard.pdf")))

  ;; (defun cheat-sheet-dired-toggle ()
  ;;   "open the dired cheatsheet"
  ;;   (interactive)
  ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/dired-refcard.gnu.pdf")))

  ;; (defun cheat-sheet-magit-toggle ()
  ;;   "open the magit cheatsheet"
  ;;   (interactive)
  ;;   (cheat-sheet-toggle (expand-file-name "~/Documents/cheat-sheet/emacs/magitCheatsheet.pdf")))

  ;; clojure-cheatsheet
  ;; runs with existing repl only:
  ;; M-x clojure-cheatsheet opens a helm like search over severyl clojure concepts/functions etc.

  ;; focus
  ;; M-x focus-mode toggles this mode that focusses only on the construct under the cursor

  ;; helm-ag
  ;; search multi key word with M-x helm-ag


  ;; (add-to-list 'load-path "~/.emacs.d/clomacs/src/elisp/")
  ;; (require 'clomacs)

  ;; (clomacs-defun get-property System/getProperty)
  ;; (message (get-property "java.version"))

  ;; (use-package kanban)

  ;; (add-to-list 'load-path "~/git/local/hoclgen/src/elisp")
  ;; (require 'hoclgen)


  ;; (add-to-list 'load-path "~/.emacs.d/xml-customizations")
  ;; (load "xml-extensions.el")


  ;; C-c C-a annotate the marked region, or the word under point
  ;; annotations are saved in ~/.annotations



  ;; Set the defcustom variables defined in jiralib.el (actually only the jiralib-url is required, as the other 2 are usually computed from it correctly and is the case in the video demo):

  ;; 3 matches for "\bdefcustom\b" in buffer: jiralib.el
  ;;      55:(defcustom jiralib-host ""
  ;;     107:(defcustom jiralib-wsdl-descriptor-url
  ;;     120:(defcustom jiralib-url


  ;; Write your password in ~/.authinfo, with machine being the (computed) jiralib-host, and the port being 80 (even if you are using https for Jira):

  ;; machine JIRALIB-HOST login USERNAME password XXXXX port 80



#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs
          `(,(concat user-emacs-directory "snippets"))) ;; my snippets library

    ;; (add-hook 'prog-mode-hook #'yas-minor-mode) ;; make it a submode of all programming modes
    ;; (yas-global-mode 1) ;; make it global

    ;; Completing point by some yasnippet key
    (defun yas-ido-expand ()
      "Lets you select (and expand) a yasnippet key"
      (interactive)
      (let ((original-point (point)))
        (while (and
                (not (= (point) (point-min) ))
                (not (string-match "[[:space:]\n]" (char-to-string (char-before)))))
          (backward-word 1))
        (let* ((init-word (point))
               (word (buffer-substring init-word original-point))
               (list (yas-active-keys)))
          (goto-char original-point)
          (let ((key (remove-if-not
                      (lambda (s) (string-match (concat "^" word) s)) list)))
            (if (= (length key) 1)
                (setq key (pop key))
              (setq key (ido-completing-read "key: " list nil nil word)))
            (delete-char (- init-word original-point))
            (insert key)
            (yas-expand)))))


    (when (package-installed-p 'company)

      ;; Add yasnippet support for all company backends
      ;; https://github.com/syl20bnr/spacemacs/pull/179
      (defvar company-mode/enable-yas t
        "Enable yasnippet for all backends.")

      ;; instrument a backend ":with company-yasnippet"
      (defun company-mode/backend-with-yas (backend)
        (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      ;; instrument all existing backends with yasnippet
      (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

      ;; make sure that M-<tab> is available in yas-minor-mode
      (define-key yas-minor-mode-map (kbd "M-<tab>") #'company-try-hard)))
#+END_SRC
** yankpad
   - init (setq yankpad-file "~/yankpad.org")
   - use functions yankpad-map, yankpad-expand
   - see [[https://github.com/Kungsgeten/yankpad][homepage]]
   #+BEGIN_SRC emacs-lisp
     (use-package yankpad
       :init
       (when (package-installed-p 'company)
         ;; If you want to complete snippets using company-mode
         ;; (add-to-list 'company-backends #'company-yankpad)
         )
       :config
       (setq yankpad-file "~/yankpad.org"))
   #+END_SRC
* organizational (org, mail, news)
** elfeed
 #+BEGIN_SRC emacs-lisp
   (use-package elfeed
     :ensure elfeed
     :commands elfeed
     :bind (:map elfeed-search-mode-map
            ("l" . recenter-top-bottom)
            :map elfeed-show-mode-map
            ("l" . recenter-top-bottom))
     :config
     (progn
       (setq elfeed-use-curl t)
       (setq shr-width 80)
       (setq shr-image-animate nil)
       (custom-set-faces
        '(elfeed-search-feed-face ((t (:foreground "NavajoWhite2"))))
        '(elfeed-search-title-face ((t (:foreground "dark gray"))))
        '(elfeed-search-unread-title-face ((t (:inherit elfeed-search-title-face :foreground "DarkOrange2")))))
       ))

   ;; Load elfeed-org
   (use-package elfeed-org
     :ensure elfeed-org
     :after ( elfeed org dash)
     :init (progn
       ;; TOOD fix function that is not known here
       ;; only programming related books
       ;; (add-hook 'elfeed-new-entry-hook
       ;;           (elfeed-make-tagger :feed-url "pdfbooksplanet"
       ;;                               :entry-link '(not "programming")
       ;;                               :add 'junk
       ;;                              :remove 'unread))

       ;; only programming related books
       ;; (add-hook 'elfeed-new-entry-hook
       ;;          (elfeed-make-tagger :feed-url "BookDL"
       ;;                              :entry-link '(not "programming")
       ;;                             :add 'junk
       ;;                              :remove 'unread))

       ;; (add-hook 'elfeed-new-entry-hook
       ;;          (elfeed-make-tagger :feed-url "lobste\\.rs"
       ;;                              :entry-link '(not "emacs")
       ;;                              :add 'junk
       ;;                              :remove 'unread))

       )
     :config
     (progn

       ;; Initialize elfeed-org
       ;; This hooks up elfeed-org to read the configuration when elfeed
       ;; is started with =M-x elfeed=
       (elfeed-org)


       ;; Optionally specify a number of files containing elfeed
       ;; configuration. If not set then the location below is used.
       ;; Note: The customize interface is also supported.
       (setq rmh-elfeed-org-files (list "~/elfeed.org"))

       ;; show all news one week ago either unread or keep
       (setq-default elfeed-search-filter "@6-months-old +unread")

       (setf url-queue-timeout 30)


       ;; (setq elfeed-search-filter "@6-months-old +unread")
       ))

   (use-package noflet)

   (use-package elfeed-goodies
     :ensure elfeed-goodies
     :after ( elfeed popwin noflet ace-jump-mode) ;; powerline
     :config
     (progn
       (setq elfeed-goodies/entry-pane-size 0.5)
       (setq elfeed-goodies/powerline-default-separator (quote bar))
       (setq elfeed-goodies/tag-column-width 30)
       (elfeed-goodies/setup)
       ;; overwrite default function of elfeed goodies. elfeed maps this to M-v upon mode init
       (defun elfeed-goodies/show-ace-link ()
         (interactive)
         (scroll-down-command))))
 #+END_SRC
** gnus (mail)
*** gnu-firstentry
 #+BEGIN_SRC emacs-lisp
 ;; add support to send from different smtp accounts
 ;; do this before custom variables are set, otherwise send-mail-function won't be set correctly!
 (use-package smtpmail-multi)

 ;; closed by gnu-lastentry!
 (use-package gnus
   :commands gnus
   :after ( smtpmail-multi mm-decode hydra bbdb)
   :bind (
          :map gnus-group-mode-map
          ("<f1>" . hydra-gnus-group/body)
          ("C-c b l" . gnus-bookmark-bmenu-list)
          :map gnus-summary-mode-map
          ("<f1>" . hydra-gnus-summary/body)
          ("C-c b l" . gnus-bookmark-bmenu-list)
          ("C-c b m" . gnus-bookmark-set)
          ("C-c b s" . gnus-bookmark-set)
          :map gnus-article-edit-mode-map
          ("<f1>" . hydra-gnus-article-mime-part/body)
          :map gnus-article-mode-map
          ("<f1>" . hydra-gnus-article-mime-part/body)
          ("C-c b l" . gnus-bookmark-bmenu-list)
          :map message-mode-map
          ("<f1>" . hydra-gnus-article-mime-part/body)
          ("TAB" . company-try-hard)
          )
   :init  (progn
            ;; Sign messages by default
            (add-hook 'message-setup-hook 'mml-secure-sign-pgpmime)

            (defun gb/cache-sender-key ()
              "cache the gpg key based on the from field of this message"
              (interactive)

              (save-excursion
                (save-restriction
                  (message-narrow-to-headers)
                  (let ((from (message-fetch-field "from")))
                    (message (concat "cache password for " from))
                    (gb/cache-gpg-key from)))))

            (add-hook 'gnus-message-setup-hook 'gb/cache-sender-key)

            ;; make sure that truncate lines is off and word wrap is on when viewing articels
            (add-hook 'gnus-article-mode-hook
                      (lambda ()
                        (setq
                         fill-column 60
                         truncate-lines nil
                         word-wrap t))))
   :config ;; closing bracket follows way down !
 #+END_SRC
*** hydra
    #+BEGIN_SRC emacs-lisp
      ;;--------------------------------------------------------------------------------
      (require 'gnus-art)

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-summary ()
        "
              gnus summary
              ------------
              [_W_] : reply w/ original
              [_A_] : reply w/ original and all attachments
              [_v_] : save all mime parts

            %s(hydra-combine-functions-w-key-bindings 
              '((\"  [W] reply w/ original                \" . gnus-summary-wide-reply-with-original)
                (\"  [A] reply w/ original and attachments\" . gnus-summary-mail-forward)
                (\"  [v] save all mime parts              \" . gnus-summary-save-parts)))
            "
        ("W" gnus-summary-wide-reply-with-original :exit t)
        ("A" gnus-summary-mail-forward :exit t)
        ("v" gnus-summary-save-parts :exit t))

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-group ()
        "
             gnus group view
             ---------------
             [_G_]: search in (marked) group(s)  [_r_]: mark by regular expression   
             [_c_]: make a new group             [_m_]: mark this group              
             [_E_]: edit group                   [_U_]: unmark all groups            
              ^ ^                                [_u_]: unmark current group         

            %s(hydra-combine-functions-w-key-bindings
              '((\" [G] search in (marked) group(s) \" . gnus-group-make-nnir-group)
                (\" [c] make new group              \" . gnus-group-make-group)
                (\" [E] edit group                  \" . gnus-group-edit-group)
                (\" [r] mark by regular expression  \" . gnus-group-mark-regexp)
                (\" [m] mark this group             \" . gnus-group-mark-group)
                (\" [U] unmark all groups           \" . gnus-group-unmark-all-groups)
                (\" [u] unmark current group        \" . gnus-group-unmark-group)))
        "
        ("G" gnus-group-make-nnir-group :exit t)
        ("c" gnus-group-make-group :exit t)
        ("E" gnus-group-edit-group :exit t)
        ("r" gnus-group-mark-regexp)
        ("m" gnus-group-mark-group)
        ("U" gnus-group-unmark-all-groups :exit t)
        ("u" gnus-group-unmark-group))

      (defhydra hydra-gnus-article-mime-part ()
        "
                gnus article mime part
                ----------------------
                _o_: save mime part
                _e_: encrypt message
                _s_: sign message

            %s(hydra-combine-functions-w-key-bindings
                '((\"    [o] save mime part \" . gnus-mime-save-part)
                  (\"    [e] encrypt message\" . mml-secure-message-encrypt-pgpmime)
                  (\"    [s] sign message   \" . mml-secure-message-sign-pgpmime)))
              "
        ("o" gnus-mime-save-part)
        ("e" mml-secure-message-encrypt-pgpmime :exit t)
        ("s" mml-secure-message-sign-pgpmime :exit t))

    #+END_SRC
*** vars
    #+BEGIN_SRC emacs-lisp
      (setq gnus-cache-enter-articles nil)
      (setq gnus-cache-remove-articles (quote (dormant)))
      (setq gnus-extra-headers (quote (To Cc Keywords Gcc Newsgroups Content-Type)))
      (setq gnus-gcc-mark-as-read t)
      (setq gnus-large-newsgroup 800)
      (setq gnus-show-threads nil)
      (setq gnus-use-cache t)
      (setq gnus-visible-headers '("^From:" "^Newsgroups:" "^Subject:" "^Date:" "^Followup-To:" "^Reply-To:" "^Organization:" "^Summary:" "^Keywords:" "^To:" "^[BGF]?Cc:" "^Posted-To:" "^Mail-Copies-To:" "^Mail-Followup-To:" "^Apparently-To:" "^Gnus-Warning:" "^Resent-From:" "^X-Sent:" "^X-AnteSpam-Report:"))

      (setq message-send-mail-function (quote smtpmail-multi-send-it))

      ;; reply signed mails with signed mails
      (setq gnus-message-replysign t)
      (setq mm-decrypt-option (quote always))

      ;; nil = use default key to sign
      ;; guided = make sure that whenever signing is necessary, user is queried to select key
      (setq mm-sign-option nil)
      ;; use the sender to select default key
      (setq mml-secure-openpgp-sign-with-sender t)
      (setq mm-verify-option (quote known))
      (setq mml-secure-fail-when-key-problem t)

      (setq mm-fill-flowed nil)
      (setq mm-inline-large-images (quote resize))

      (setq nnmail-extra-headers (quote (To Newsgroups Cc Content-Type)))

      ;; gnus will try to build threads from old headers
      (setq gnus-fetch-old-headers t)
    #+END_SRC
*** gravatar
    - see [[https://www.gnu.org/software/emacs//manual/html_mono/gnus.html#Gravatars][here]]
    #+BEGIN_SRC emacs-lisp
    (setq gnus-treat-from-gravatar 'head) ;; show gravatar in from line
    ;; (setq gnus-treat-mail-gravatar 'head) ;; show gravator in to and cc line
    (setq gnus-gravatar-size 75)          ;; size of gravatar (in pixel)
    #+END_SRC
*** ui
 #+BEGIN_SRC emacs-lisp
   ;; eww background coloring (to prevent light gray background in htlm mails)
   (setq shr-color-visible-luminance-min 80)
   (setq shr-use-fonts nil) ;; don't use proportional fonts


   ;; Gnus formatting and colorizing

   ;; customize org link
   (custom-set-faces '(org-link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
   (custom-set-faces '(org-date ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))

   (copy-face 'default 'mysubject)
   (setq gnus-face-1 'mysubject)

   (copy-face 'default 'mytime)
   (set-face-foreground 'mytime "cornflowerblue")
   (setq gnus-face-2 'mytime)

   (copy-face 'default 'mythreads)
   (set-face-foreground 'mythreads "turquoise")
   (setq gnus-face-3 'mythreads)

   (copy-face 'default 'mygrey)
   (set-face-foreground 'mygrey "blue")
   (setq gnus-face-4 'mygrey)

   (copy-face 'default 'myblack)
   (set-face-foreground 'myblack "gold")
   (setq gnus-face-5 'myblack)

   (copy-face 'default 'mybiggernumbers)
   (set-face-foreground 'mybiggernumbers "seagreen")
   (setq gnus-face-6 'mybiggernumbers)


   (defun gnus-user-format-function-@ (header)
     "Display @ for message with attachment in summary line.
   You need to add `Content-Type' to `nnmail-extra-headers' and
   `gnus-extra-headers', see Info node `(gnus)To From Newsgroups'."
     (let ((case-fold-search t)
           (ctype (or (cdr (assq 'Content-Type (mail-header-extra header)))
                      "text/plain"))
           (indicator " ")
           (header-extra (mail-header-extra header))) ;; <-- check this
       (when  (or (string-match "^text/calendar" ctype) ;; calendar is deeply nested within, but this check works only for top level types
                  (string-match "^multipart/mixed" ctype)) 
         (setq indicator "@"))
       indicator))

   ;; make sure that (safe) inline images are shown in html messages
   (if w3m-installed
       (setq mm-text-html-renderer 'w3m))
   (setq gnus-inhibit-images nil)
   (setq w3m-display-inline-image t)
   (setq mm-html-inhibit-images nil) ;; allow inlining images
   ;; (setq mm-attachment-override-types '("image/.*"
   ;;                    "text/x-vcard"
   ;; 				   "application/pkcs7-mime"
   ;; 				   "application/x-pkcs7-mime"
   ;; 				   "application/pkcs7-signature"
   ;; 				   "application/x-pkcs7-signature"))
   (add-to-list 'mm-attachment-override-types "image/.*")

   ;; provide buttons to select between html message and pure text message!
   (setq gnus-buttonized-mime-types
         '("multipart/alternative" "multipart/signed")
         mm-discouraged-alternatives
         '("text/html" "image/.*"))

   (setq gnus-summary-line-format 
         (concat
          "%*%5{%U%R%z%}" ;; (U)nread (R)eplied (z)??
          "%4{|%}"
          "%2{%-5N%}" ;; (N) article number
          "%4{|%}"
          "%2{%-10&user-date;%}" ;; date
          "%4{|%}"
          "%5{%u&@;%}"  ;; gnus-user-format-function-@ to print @ for messages with attachments
          "%2{ %}%(%-24,24f" ;; (f) prints from (if not ignored address, else to)!
          "%4{|%}"
          "%2{%6k %}%)" ;; (k) human readable size 
          "%4{|%}"
          "%2{ %}%3{%B%}%1{%s%}\n") ;; (s)ubject
          )

   ;; (cond (window-system
   ;;        (setq custom-background-mode 'light)
   ;;        (defface my-group-face-1
   ;;          '((t (:foreground "Red" :bold t))) "First group face")
   ;;        (defface my-group-face-2
   ;;          '((t (:foreground "DarkSeaGreen4" :bold t)))
   ;;          "Second group face")
   ;;        (defface my-group-face-3
   ;;          '((t (:foreground "Green4" :bold t))) "Third group face")
   ;;        (defface my-group-face-4
   ;;          '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
   ;;        (defface my-group-face-5
   ;;          '((t (:foreground "Blue" :bold t))) "Fifth group face")))

   ;; (setq gnus-group-highlight
   ;;       '(((> unread 200) . my-group-face-1)
   ;;         ((and (< level 3) (zerop unread)) . my-group-face-2)
   ;;         ((< level 3) . my-group-face-3)
   ;;         ((zerop unread) . my-group-face-4)
   ;;         (t . my-group-face-5)))

   ;; make the default sorting of all groups to be sorted by date!
   (setq gnus-article-sort-functions '((not gnus-article-sort-by-date)))


   (setq gnus-summary-mode-line-format "Gnus: %p [%A / Sc:%4z] %Z")

   (setq-default
    gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
    gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
    gnus-thread-sort-functions '(gnus-thread-sort-by-date)
    gnus-sum-thread-tree-false-root ""
    gnus-sum-thread-tree-indent " "
    gnus-sum-thread-tree-leaf-with-other "├► "
    gnus-sum-thread-tree-root ""
    gnus-sum-thread-tree-single-leaf "╰► "
    gnus-sum-thread-tree-vertical "│")

   ;; make sure that summary/article are 35%/65% instead of 25%/75% (default)
   ;; (gnus-add-configuration '(article (vertical 1.0 (summary .35 point) (article 1.0))))
   (gnus-add-configuration
    '(article
      (horizontal 1.0 (vertical 50
                           (group 1.0))
               (vertical 1.0
                         (summary 0.35 point)
                         (article 1.0)))))
   (gnus-add-configuration
    '(summary
      (horizontal 1.0 (vertical 50
                 (group 1.0))
       (vertical 1.0
                 (summary 1.0 point)))))


   ;; turn off flowed mode
   (setq fill-flowed-display-column nil)


 #+END_SRC
*** polling new mails
 #+BEGIN_SRC emacs-lisp
     ;; make sure a timeout ends this tries if going offline
     (defadvice gnus-demon-scan-news (around gnus-demon-timeout activate)
       "Timeout for Gnus."
       (with-timeout
           (120 (message "Gnus timed out."))
         ad-do-it))

     ;; after gnus is started run timer to retrieve new mails!
     (setq gnus-startup-hook
           '(lambda ()
              (gnus-demon-add-handler 'gnus-demon-scan-news 15 nil) ; this does a call to gnus-group-get-new-news
              ))

     (defun gnus-frequent-check-new-mail ()
       "make checking mails run every 5 minutes"
       (interactive)
       (gnus-check-mail 5))

     (defun gnus-lazy-check-new-mail ()
       "make checking mails run every hour"
       (interactive)
       (gnus-check-mail 60))

     (defun gnus-normal-check-new-mail ()
       "make checking emails run ever 15 minutes"
       (interactive)
       (gnus-check-mail 15))

     (defun gnus-check-mail (minutes)  
       "make checking mails run every minutes"
       (gnus-demon-remove-handler 'gnus-demon-scan-news)
       (gnus-demon-add-handler 'gnus-demon-scan-news minutes nil)
       (message "now check every %s minutes" minutes))
 #+END_SRC
*** group line format
    #+BEGIN_SRC emacs-lisp
    ;; (M) marked articles
    ;; (S) subscribed group indicator
    ;; (G) group name
    ;; (y) # of unread
    ;; (t) estimated total number of articales
    ;; (D) group description
    (setq gnus-group-line-format "%M%S %-27uG %5y/%-10t %D\n")
    #+END_SRC
*** misc 
 #+BEGIN_SRC emacs-lisp
     (defun message-toggle-gcc ()
       "Insert or remove the \"Gcc\" header."
       (interactive)
       (save-excursion
         (save-restriction
           (message-narrow-to-headers)
           (if (message-fetch-field "Gcc")
               (message-remove-header "Gcc")
             (gnus-inews-insert-gcc)))))

 #+END_SRC
*** gnu-lastentry
 #+BEGIN_SRC emacs-lisp
 ) ;; closes req-package of gnus!
 #+END_SRC
*** nnir (make mails searchable)
**** add keybindings for searching imap groups (currently 'G G' within top top level)
**** construct hydra 
  #+BEGIN_SRC emacs-lisp
    ;; make imap searchable
    ;;(use-package nnir
    ;;  :after ( gnus))
  #+END_SRC
*** accounts (user specific stuff)
    #+BEGIN_SRC emacs-lisp
      (when mail-accounts-exists
            (use-package mail-accounts
              :load-path "~/.emacs.d/accounts/"
              :after (gnus)))
    #+END_SRC
** bbdb
*** bbdb itself
 #+BEGIN_SRC emacs-lisp
     ;; make sure that email addresses are stored in the bbdb (database)

   (use-package bbdb
     :init (progn
     ;; use ; on a message to invoke bbdb interactively
     (add-hook 'gnus-summary-mode-hook
               (lambda ()
                 (define-key gnus-summary-mode-map (kbd ";") 'bbdb-mua-edit-field)
                 )))
     :config

     ;; initialization
     (bbdb-initialize 'gnus 'message)
     (bbdb-mua-auto-update-init 'gnus 'message)

     (setq bbdb-layout (quote full-multi-line))

     ;; size of the bbdb popup
     (setq bbdb-pop-up-window-size 5)

     ;; ask for saving bbdb (t = ask, nil = don't ask, other = always save)
     (setq bbdb-offer-save "yes")

     ;; What do we do when invoking bbdb interactively
     (setq bbdb-mua-update-interactive-p '(query . create))

     ;; make sure we look at every address in a message and not only the
     ;; first one
     (setq bbdb-message-all-addresses t)

     (setq bbdb-address-label-list (quote ("" "home" "work" "other")))
     (setq bbdb-file "~/bbdb")
     (setq bbdb-phone-label-list (quote ("" "home" "work" "cell" "other")))

     )


 #+END_SRC
*** incremental search within bbdb (and more) [[https://github.com/aki2o/bbdb-][link]]
**** to open (during writing mails): M-x bbdb-:start-completion
**** keybinding in that mode is then 
      j ... Go to next record
      k ... Go to previous record
      h ... Go to previous char
      l ... Go to next char
      J ... Scroll down
      K ... Scroll up
      s ... Start incremental search
      S ... Start incremental search with the reverse configuration about using migemo
      a ... Show all record
      t ... Mark current record as To
      c ... Mark current record as Cc
      b ... Mark current record as Bcc
      u ... Unmark current record
      t ... Mark all listed record as To
      c ... Mark all listed record as Cc
      b ... Mark all listed record as Bcc
      u ... Unmark all listed record
      R ... Reload the latest record of BBDB
      q ... Finish with doing nothing
      RET ... Finish with the update of To/Cc/Bcc header (if necessary, open the mail buffer)
  #+BEGIN_SRC emacs-lisp
    (use-package bbdb-
      :ensure bbdb-
      :after ( bbdb)
      :config
      (bbdb-:setup))
  #+END_SRC
*** csv export/import
 #+BEGIN_SRC emacs-lisp
   (use-package bbdb-csv-import
     :after ( bbdb))
 #+END_SRC
*** extensive regex search in bbdb
 #+BEGIN_SRC emacs-lisp
   (use-package bbdb-ext
     :ensure bbdb-ext
     :after ( bbdb))
 #+END_SRC
*** DONE popup window for email selection in mail client (seems to be alternative to bbdb-) (deactivated)
    - seems no longer available
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package bbdb-handy
     :after ( bbdb)
     :config
     (bbdb-handy-enable))
 #+END_SRC
*** export entry as vcard
 #+BEGIN_SRC emacs-lisp
;;   (use-package bbdb-vcard
;;     :after ( bbdb))
 #+END_SRC
** calendar
 #+BEGIN_SRC emacs-lisp
     (setq calendar-latitude 53.55)
     (setq calendar-longitude 9.99)
     (setq calendar-location-name "Hamburg, D")
     (setq european-calendar-style t)
     (setq calendar-week-start-day 1)
     (setq display-time-24hr-format 1)

     (setq calendar-mark-diary-entries-flag t)
     (setq view-diary-entries-initially t)
     ;; the below had to be done if the given entry was not there before hand
     ;; thus all appointments are marked within the calendar now
     ;; echo "%%(org-diary)" >> ~/diary 

     (add-hook 'calendar-today-visible-hook 'calendar-mark-today) ;; mark today within the calendar view
     (custom-theme-set-faces 'user '(calendar-today ((t :foreground "orange"))))
     (custom-theme-set-faces 'user '(calendar-iso-week-face ((t :foreground "lightblue"))))

     ;; code below prints iso calendar weeks into the calendar
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute 'calendar-iso-week-face nil
                         :height 1.0)
     (setq calendar-intermonth-text
           '(propertize
             (format "%2d"
                     (car
                      (calendar-iso-from-absolute
                       (calendar-absolute-from-gregorian (list month day year)))))
             'font-lock-face 'calendar-iso-week-face))

 #+END_SRC
** IMPLEMENT org
*** org
  #+BEGIN_SRC emacs-lisp
        (use-package org
          :after ( hydra helm)
          :bind (
            :map  org-mode-map
            ("<f1>" . hydra-org-mode/body)
            ("s-i" . helm-org-in-buffer-headings)
            ("RET" . gb/org-smart-return)
            ("C-c l" . org-store-link)
            ("C-c t i" . org-toggle-item))
          :init (progn
          (add-hook 'after-change-major-mode-hook #'gb/activate-properties-in-org-mode)
          (add-hook 'org-mode-hook #'gb/enable-auto-fill-mode)
          ;; (add-hook 'org-mode-hook #'org-sticky-header)

          ;; make sure source blocks are collapsed at first
          ;; and C-x t b expands and recollapses them
          ;; see [[https://emacs.stackexchange.com/questions/7211/collapse-src-blocks-in-org-mode-by-default][here]]
          (defvar gb/org-block-visible nil)
          (defun gb/org-toggle-block-visibility ()
            ""
            (interactive)
            (if gb/org-block-visible
                (org-hide-block-all)
              (org-show-block-all))
            (setq-local gb/org-block-visible (not gb/org-block-visible)))
          (add-hook 'org-mode-hook #'gb/org-toggle-block-visibility)

          (define-key gb/toggle-map "b" #'gb/org-toggle-block-visibility)

          ;; ensure that adjusted save hook is not executed when org edit src save is executed
          (advice-add 'org-edit-src-save :around #'gb/wrap-org-edit-src-save)
          ;; ensure that read only mode is removed when org src edit is started
          (advice-add 'org-edit-special :before #'(lambda (orig-func &rest args) (read-only-mode -1)))


            )
          :init
          (progn
          (require 'ob-clojure) ;; not found in packages (20180510)
          (require 'org-inlinetask)

          (defun gb/org-smart-return (&optional ignore)
            "Add new list item, heading or table row with RET.
    A double return on an empty element deletes it.
    Use a prefix arg to get regular RET.
    reference: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/?utm_source=feedburner&utm_medium=twitter&utm_campaign=Feed:+TheKitchinResearchGroup+(The+Kitchin+Research+Group)"
            (interactive "P")
            (if ignore
                (org-return)
              (cond
               ;; Open links like usual
               ((eq 'link (car (org-element-context)))
                (org-open-at-point-global))
               ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
               ;; Johansson!
               ((org-inlinetask-in-task-p)
                (org-return))
               ;; add checkboxes
               ((org-at-item-checkbox-p)
                (org-insert-todo-heading nil))
               ;; lists end with two blank lines, so we need to make sure we are also not
               ;; at the beginning of a line to avoid a loop where a new entry gets
               ;; created with only one blank line.
               ((and (org-in-item-p) (not (bolp)))
                (if (org-element-property :contents-begin (org-element-context))
                    (org-insert-heading)
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")
                  (org-return)))
               ((org-at-heading-p)
                (if (not (string= "" (org-element-property :title (org-element-context))))
                    (progn (org-end-of-meta-data)
                           (org-insert-heading))
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")))
               ((org-at-table-p)
                (if (-any?
                     (lambda (x) (not (string= "" x)))
                     (nth
                      (- (org-table-current-dline) 1)
                      (org-table-to-lisp)))
                    (org-return)
                  ;; empty row
                  (beginning-of-line)
                  (setf (buffer-substring
                         (line-beginning-position) (line-end-position)) "")
                  (org-return)))
               (t
                (org-return)))))

          (defun gb/wrap-org-edit-src-save (orig-func &rest args)
            "remove save adjusted hook, execute save and add hook again.
    thus this function prevents org-babel tangle and setting the file on r/o when edited in org edit src mode"
            (remove-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
            (let ((res (apply orig-func args)))
              (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
              res))

          (defun gb/org-clock-in-switch-to-state-fn (state)
            "switch TODO to IMPLEMENT if clocking in!"
            (if (equal state "TODO")
                "IMPLEMENT"
              nil))

          (defun gb/org-global-props-key-re (key)
            "Construct a regular expression matching key and an optional plus and eating the spaces behind.
         Test for existence of the plus: (match-beginning 1)"
            (concat "^" (regexp-quote key) "\\(\\+\\)?[[:space:]]+"))

          (defun gb/org-global-props (&optional buffer)
            "Get the plists of global org properties of current buffer."
            (with-current-buffer (or buffer (current-buffer))
              (org-element-map (org-element-parse-buffer) 'keyword (lambda (el) (when (string-equal (org-element-property :key el) "PROPERTY") (nth 1 el))))))

          (defun gb/org-global-prop-value (key)
            "Get global org property KEY of current buffer.
           Adding up values for one key is supported."
            (let ((key-re (gb/org-global-props-key-re key))
                  (props (gb/org-global-props))
                  ret)
              (cl-loop with val for prop in props
                       when (string-match key-re (setq val (plist-get prop :value))) do
                       (setq
                        val (substring val (match-end 0))
                        ret (if (match-beginning 1)
                                (concat ret " " val)
                              val)))
              ret))

          ;; TODO: generalize to all properties
          (defun gb/activate-properties-in-org-mode ()
            (when (string= major-mode "org-mode")
              (let* ((readOnly (gb/org-global-prop-value "readonly")))
                (if (string= readOnly "yes")
                    (setq buffer-read-only t)))))

          :config
          ;; set org babel backgrounds for several languages
          (setq org-src-block-faces
                '(("emacs-lisp" (:background "#1b1010"))
                  ("java" (:background "#1b1010"))))

          ;; make sure latex is highlighted in org mode buffers
          ;; `latex'    Highlight LaTeX snippets and environments.
          ;;  `script'   Highlight subscript and superscript.
          ;;  `entities' Highlight entities.
          (setq org-highlight-latex-and-related '(latex script entities))

          ;; make sure that regular font in src block within org is 'white'
          (custom-set-faces '(org-block ((t (:foreground "gray75")))))
          (setq flycheck-keymap-prefix (kbd "C-c k"))

          ;;--------------------------------------------------------------------------------
          (defhydra hydra-org-mode ()
            "
              org mode
              ^-^------------------------------------------------
              _ci_: clock in             _cti_: toggle item     _cr_: org reveal    Movement:
              _co_: clock out                                                   C-c p previous bulletin
              _cq_: clock cancel/quit                                           C-c u up bulletin level
              _cj_: jump to clock                                               M-<ret>
              _cd_: display clock times                                         C-<ret>

              %s(hydra-combine-functions-w-key-bindings
                '((\"  [ci]  clock in            \" . org-clock-in)
                  (\"  [co]  clock out           \" . org-clock-out)
                  (\"  [cq]  clock cancel/quit   \" . org-clock-cancel)
                  (\"  [cj]  jump to clock       \" . org-clock-goto)
                  (\"  [cd]  display clock times \" . org-clock-display)
                  (\"  [cti] toggle item         \" . org-toggle-item)
                  (\"  [cr]  org reveal          \" . org-reveal)
                  ))
            "
            ("ci" org-clock-in :exit t)
            ("co" org-clock-out :exit t)
            ("cq" org-clock-cancel :exit t)
            ("cj" org-clock-goto :exit t)
            ("cd" org-clock-display :exit t)
            ("cti" org-toggle-item :exit t)
            ("cr" org-reveal :exit t))


          ;; Resume clocking tasks when emacs is restarted
          (org-clock-persistence-insinuate)

          ;; make sure that clock display will include all times (even last year ...)
          (setq org-clock-display-default-range (quote untilnow))

          ;; Yes it's long... but more is better ;
          (setq org-clock-history-length 35)

          ;; Resume clocking task on clock-in if the clock is open
          (setq org-clock-in-resume t)

          ;; name the drawer to be "clocking"
          (setq org-clock-into-drawer "CLOCKING")

          ;; The format string used when creating CLOCKSUM lines.
          (setq org-duration-format '((special . h:mm)))
          (setq org-time-clocksum-format
            (quote
             (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))) ;; make sure that clock sums in org mode show hours and minutes only (no days)

          ;; Change task state to IMPLEMENT when clocking in (only if in STATE TODO)
          (setq org-clock-in-switch-to-state (function  gb/org-clock-in-switch-to-state-fn))

          ;; mark checked lists a bit differently
          (font-lock-add-keywords
              'org-mode
              `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
              'append)

          (setq org-ellipsis "…") ;; make the ... at the end (that indicates folding) be a bit less invasive
          (setq org-hide-leading-stars t) ;; each level only one star
          (setq org-special-ctrl-a/e t) ;; jump to the head text only (not to the star marking the head)

          ;; replace dashes and bullets with utf-8 bullet
          ;; (font-lock-add-keywords 'org-mode
          ;;                         '(("^ +\\([-*]\\) "
          ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

          ;; make level headings larger / bold
          ;; (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
          ;;                             ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
          ;;                             ((x-list-fonts "Verdana")         '(:font "Verdana"))
          ;;                             ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
          ;;                             (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
          ;;      (base-font-color     (face-foreground 'default nil 'default))
          ;;      (headline           `(:inherit default :weight bold )))

            (custom-theme-set-faces 'user
          ;;                          `(org-document-title ((t ( :height 1.5 :underline nil))))
          ;;                          `(org-level-8 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-7 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-6 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-5 ((t (,@headline ,@variable-tuple))))
          ;;                          `(org-level-4 ((t (:foreground "#a97167"))))
          ;;                          `(org-level-3 ((t (:foreground "#4fa8a8" ,@headline))))
          ;;                          `(org-level-2 ((t (:foreground "#989848" ,@headline :height 1.1))))
                                    `(org-level-1 ((t (:foreground "#de935f")))))


          ))
  #+END_SRC
*** org mobile
    - this will put all org files (known to the system) into the transfer folder which is not what I want, I don't want all files to be
      synced via Dropwizard
    - could be tamed to not use all agenda files!
    #+BEGIN_SRC emacs-lisp
      (use-package org-mobile
        :commands org-mobile-pull org-mobile-push
        :after ( org)
        :init
          (progn
            (defun gb/ensure-org-mobile-secret ()
              "ensure that the org mobile sync secret is set"
                ;; used for encryption of org mode files // should be executed after above commands only!
              (if (string-empty-p org-mobile-encryption-password)
                  (let ((auth-map (jde-read-properties-file "~/.org-mobile.auth.gpg")))
                    (setq org-mobile-encryption-password (gethash "org-mobile-encryption-secret" auth-map)))))

            (advice-add 'org-mobile-pull :before #'(lambda () (gb/ensure-org-mobile-secret)))
            (advice-add 'org-mobile-push :before #'(lambda () (gb/ensure-org-mobile-secret)))

            )
        :config
        (progn
        ;; Set to the location of your Org files on your local system
        (setq org-directory "~")
        ;; Set to the name of the file where new notes will be stored
        (setq org-mobile-inbox-for-pull "~/org-dropbox/flagged.org")
        ;; Set to <your Dropbox root directory>/MobileOrg.
        (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
        ;; make sure that no agenda files are put into tranfer folder
        (setq org-mobile-files (quote ("~/notes.synced.org")))
        ;; (setq org-mobile-agendas nil)

        ;; make sure encryption is used
        (setq org-mobile-use-encryption t)
        ))
    #+END_SRC
*** org capture
    - for capture templates see [[http://orgmode.org/manual/Template-elements.html#Template-elements]]
    - intro for capture templates see http://cestlaz.github.io/posts/using-emacs-23-capture-1/
  #+BEGIN_SRC emacs-lisp
    (use-package org-capture
      :after ( org)
      :bind ("C-c c" . org-capture)
      :init (progn
        ;;
        (defun gb/org-file-lineno-store-link ()
          "provide function that stores a file link with line number (when matching the wanted major mode)"
          (cond
           ((string-match "\\(emacs-lisp-mode\\|nxml-mode\\)" (format "%s" major-mode))
            (let* ((link (format "file:%s::%d" (file-truename buffer-file-name)
                                 (line-number-at-pos))))
              (org-store-link-props
               :type "file"
               :link link)))))

        ;; when storing a file link, store line number with it (when matching the wanted major mode)
        (add-hook 'org-store-link-functions 'gb/org-file-lineno-store-link)
        )
      :config
      (progn 

        (setq org-default-notes-file "~/notes.org")

        ;; TODO: define additional capture templates
        (setq org-capture-templates
              (append '(("t" "Todo" entry (file+headline "~/notes.org" "Tasks") "* TODO %?\n  %i\n  %a"))
                      org-capture-templates))

        ;; make sure that org templates for ical export into org agenda works
        ;; (gnus-calendar-insinuate-org-templates)


        ;; necessary, else an error is reported during org-magit-store-link
        ;; (setq with-editor-file-name-history-exclude nil)
        ))
  #+END_SRC
*** org agenda
  #+BEGIN_SRC emacs-lisp
    (use-package org-agenda
      :after ( org helm) ;; agenda-accounts are option
      :config
      (progn

        ;;don't show tasks as scheduled if they are already shown as a deadline
        (setq org-agenda-skip-scheduled-if-deadline-is-shown t)

        ;;don't give a warning colour to tasks with impending deadlines
        ;;if they are scheduled to be done
        (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))

        ;;don't show tasks that are scheduled or have deadlines in the
        ;;normal todo list
        (setq org-agenda-todo-ignore-deadlines (quote all))
        (setq org-agenda-todo-ignore-scheduled (quote all))

        ;; sort agend entries by,
        ;; time-up       : Put entries with time-of-day indications first, early first
        ;; category-up   : Sort alphabetically by category, A-Z.
        ;; priority-down : Sort numerically by priority, high priority first.
        ;; category-keep : Keep the default order of categories, corresponding to the sequence in org-agenda-files.
        (setq org-agenda-sorting-strategy
              '((agenda time-up category-up)
                (todo priority-down todo-state-up category-down)
                (tags priority-down category-keep)
                (search category-keep)))

        ;; show repeated org agenda entries only once
        (setq org-agenda-show-future-repeats nil)

        ;;open agenda in current window
        (setq org-agenda-window-setup (quote current-window))
        ;;warn me of any deadlines in next 7 days
        (setq org-deadline-warning-days 7)
        ;; set only org agenda files that are currently reachable!
        ;; jump between these files <C-'>
        ;; these files are used for org agenda display of dates/todos etc.

        ;; show a fortnite
        (setq org-agenda-span 14)

        ;; include all diary events into org-agenda view
        (setq org-agenda-include-diary t) ;; this includes the holidays, too


        ;; make sure that a todo cannot switch to done, if one of its descendants is not done yet
        (setq org-enforce-todo-dependencies t)
        ;; make sure that todo cannot switch to done if a checkbox within its descendants is not checked!
        (setq org-enforce-todo-checkbox-dependencies t)

        ;; customize todo lists
        (setq org-todo-keywords
              '((sequence "TODO"               ;; currently to do task
                          "IMPLEMENT(i!)"      ;; currently implementing this to do
                          "TEST(t@/!)"         ;; currently testing this to do
                          "ACCEPT(a@/!)"       ;; accepted by tester
                          "PLANNED"            ;; planned as future task
                          "|"                  ;; separates todo from done state
                          "OBSOLETE(o!)"       ;; now obosolete 
                          "CARRY OVER(c!)"     ;; carried over to new to do
                          "DONE(d!)"           ;; finally done
                          )))
        (setq org-todo-keyword-faces
              '(("PLANNED" . "lightblue")
                ("TODO" . "red") 
                ("IMPLEMENT" . (:foreground "orange" :weight bold))
                ("TEST" . "yellow")
                ("ACCEPT" . (:foreground "gray" :weight bold))
                ("OBSOLETE" . "darkgreen")
                ("CARRY OVER" . "brown")
                ("DONE" . "green")))))

  #+END_SRC
*** org agenda user specific stuff
    #+BEGIN_SRC emacs-lisp
      (when agenda-accounts-exists
        (use-package agenda-accounts
          :after ( org org-agenda helm)
          :load-path "~/.emacs.d/accounts/"
          :config
          (progn
            (bind-key "i" #'gb/org-agenda-diary-entry org-agenda-keymap) ;; don't use :bind, since loading should be done before actully hitting this key!
            (defun gb/org-agenda-diary-entry ()
              "enter a new date into diary and allow selection of which calendar this should go into"
              (interactive)
              ;; now select and set org-agenda-diary-file
              (let* ((filename (helm-comp-read "calendar: " gb/org-calendar-files)) ;; <- provided by agenda-accounts
                     (fullname (concat "~/" filename)))
                (if (file-exists-p fullname)
                    (setq org-agenda-diary-file fullname)))
              (org-agenda-diary-entry)))))
    #+END_SRC
*** ical accept invitations into calendar
    allow to accept invitations and record these into the org-capture-file
    #+BEGIN_SRC emacs-lisp
      ;; (add-to-list 'load-path "~/.emacs.d/ical-event-master/")
      ;; (use-package gnus-calendar

      ;;   :loader :path
      ;;   :after ( org)
      ;;   :config
      ;;   (gnus-calendar-setup)
      ;;   ;; to enable optional iCalendar->Org sync functionality
      ;;   ;; NOTE: both the capture file and the headline(s) inside must already exist
      ;;   ;; remove entry from org capture templates (which are used to actually insert the invitation)
      ;;   (setq org-capture-templates (-remove (lambda (x) (string= gnus-calendar-org-template-name (second x))) org-capture-templates))
      ;;   ;; put all new events into agenda.org which is synced with the itemis work calendar (not private)
      ;;   (setq gnus-calendar-org-capture-file "~/agenda.org")
      ;;   ;; heading-1 within the org file, under which the events are created
      ;;   (setq gnus-calendar-org-capture-headline '("Calendar"))
      ;;   ;; do the setup with the given values
      ;;   (gnus-calendar-org-setup))
    #+END_SRC
*** gcal (see [[https://github.com/myuhe/org-gcal.el][link]]) currently not in use (may be useful if authentification used by org-caldav is no longer accessible)
    - BEFORE EXECUTING "org-gcal-sync", execute "org-gcal-fetch"
    - org-gcal-sync: sync org files with calendars
    - org-gcal-fetch: initially fetch all calendar events into org files (before fetch, the org files should be completely empty!)
    - org-gcal-post-at-point: post/edit org block at point to google calendar
    - org-gcal-referesh-token: refresh oauth token (expires in 1h)
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (use-package org-gcal
        :after ( calendar-accounts org)
        :commands org-gcal-sync org-gcal-fetch org-gcal-post-at-point org-gcal-refresh-token
        :config
        (progn 
            (require 'calendar-accounts)
            (gb/load-calendar-credentials))))
    #+END_SRC
*** caldav sync
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (use-package org-caldav
        :after ( org calendar-accounts oauth2)
        :commands org-caldav-sync
        :config
        (setq org-icalendar-timezone "Europe/Berlin")
        (setq org-caldav-delete-org-entries 'never)
        (setq org-caldav-delete-calendar-entries 'never)
        (setq org-caldav-debug-level 3)

        (require 'calendar-accounts)
        (gb/load-calendar-credentials)

        ;; redefine sync to cal
        (require 'org-caldav)
        ;;(setq org-caldav-url 'google)

        ;; make sure cal is not deleted
        (defun org-caldav-delete-event (uid)
          "Delete event UID from calendar.
      Returns t on success and nil if an error occurs.  The error will
      be caught and a message displayed instead."
          (message "executing patched version of org-caldav-delete-event")
          (org-caldav-debug-print 1 (format "(Deleting) event UID %s." uid))
          (condition-case err
              (progn
                ;; (url-dav-delete-file (concat (org-caldav-events-url) uid org-caldav-uuid-extension))
                t)
            (error
             (progn
               (message "Could not delete URI %s." uid)
               (org-caldav-debug-print 1 "Got error while removing UID:" err)
               nil))))

        ;; make sure that update never deletes from calendar
        (defun old-org-caldav-update-events-in-cal (icsbuf)
          "Update events in calendar.
      ICSBUF is the buffer containing the exported iCalendar file."
          (message "executing patched version of org-caldav-update-event-in-cal")
          (org-caldav-debug-print 1 "=== Updating events in calendar")
          (with-current-buffer icsbuf
            (widen)
            (goto-char (point-min))
            (let ((events (append (org-caldav-filter-events 'new-in-org)
                                  (org-caldav-filter-events 'changed-in-org)))
                  (counter 0)
                  (url-show-status nil)
                  (event-etag (org-caldav-get-event-etag-list))
                  uid)
              ;; Put the events via CalDAV.
              (dolist (cur events)
                (setq counter (1+ counter))
                (if (eq (org-caldav-event-etag cur) 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Was already put previously." (car cur)))
                  (org-caldav-debug-print 1
                                          (format "Event UID %s: Org --> Cal" (car cur)))
                  (widen)
                  (goto-char (point-min))
                  (while (and (setq uid (org-caldav-get-uid))
                              (not (string-match (car cur) uid))))
                  (unless (string-match (car cur) uid)
                    (error "Could not find UID %s" (car cur)))
                  (org-caldav-narrow-event-under-point)
                  (org-caldav-cleanup-ics-description)
                  (org-caldav-maybe-fix-timezone)
                  (org-caldav-set-sequence-number cur event-etag)
                  (message "Putting event %d of %d" counter (length events))
                  (if (org-caldav-put-event icsbuf)
                      (org-caldav-event-set-etag cur 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Error while doing Org --> Cal" (car cur)))
                    (org-caldav-event-set-status cur 'error)
                    (push (list org-caldav-calendar-id (car cur)
                                'error 'error:org->cal)
                          org-caldav-sync-result))))
              ;; Get Etags
              (setq event-etag (org-caldav-get-event-etag-list))
              (dolist (cur events)
                (let ((etag (assoc (car cur) event-etag)))
                  (when (and (not (eq (org-caldav-event-status cur) 'error))
                             etag)
                    (org-caldav-event-set-etag cur (cdr etag))
                    (push (list org-caldav-calendar-id (car cur)
                                (org-caldav-event-status cur) 'org->cal)
                          org-caldav-sync-result)))))
            ;; Remove events that were deleted in org 
            (let ((events (org-caldav-filter-events 'deleted-in-org))
                  (url-show-status nil)
                  (counter 0))
              (dolist (cur events)
                (setq counter (1+ counter))
                (message "(no really) deleting event %d from %d" counter (length events))
                ;; (org-caldav-delete-event (car cur))
                (push (list org-caldav-calendar-id (car cur)
                            'deleted-in-org 'removed-from-cal)
                      org-caldav-sync-result)
                (setq org-caldav-event-list
                      (delete cur org-caldav-event-list))))
            ;; Remove events that could not be put
            (dolist (cur (org-caldav-filter-events 'error))
              (setq org-caldav-event-list
                    (delete cur org-caldav-event-list)))))

        ))
    #+END_SRC
*** accounts for calendar sync
    #+BEGIN_SRC emacs-lisp
      (when calendar-accounts-exists
          (use-package calendar-accounts
            :after ( org)
            :load-path "~/.emacs.d/accounts/"))
    #+END_SRC
*** german holidays into calendar
    #+BEGIN_SRC emacs-lisp
      (use-package german-holidays
        :after ( org)
        :config
        ;; (setq holiday-other-holidays holiday-german-holidays)
        ;; make sure that the right holidays are used (and no others)
        (setq calendar-holidays holiday-german-holidays))
        ;; (setq calendar-holidays
        ;;       (append (if (boundp 'local-holidays) local-holidays '())  
        ;;               (if (boundp 'other-holidays) other-holidays '())
        ;;               holiday-german-holidays)))
    #+END_SRC
*** org bullets
 #+BEGIN_SRC emacs-lisp
 (use-package org-bullets
   :ensure org-bullets
   :after ( org)
   :init
   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
   :config
   (setq org-bullets-bullet-list '("●" "￮" "◉" "◦" "∙" "⚬" "◯" "◎" "○" "◌" "◎" "○" "☉" "⚪" "⊙" "❍" "⊚" "⊛" "⚫" "∘"))
   ;; override fontify buffer of org-bullets, since it forces fontifying again, which was already done => waste of time
   (defun org-bullets--fontify-buffer ()
     (when font-lock-mode
       (if (and (fboundp 'font-lock-flush)
              (fboundp 'font-lock-ensure))
           (with-no-warnings
             (font-lock-fontify-buffer))))))
 #+END_SRC
*** level 3
**** level 4
***** level 5
****** level 6
******* level 7
******** level 8
********* level 9
********** level 10
*********** level 11
************ level 12
************* level 13
************** level 14
*** password manager
 #+BEGIN_SRC emacs-lisp
   (use-package org-password-manager
     :ensure org-password-manager
     :bind (:map org-mode-map
                 ("C-c s b" . gb/browse-to-link-property)
                 ("C-c s u" . org-password-manager-get-username)
                 ("C-c s p" . org-password-manager-get-password)
                 ("C-c s g" . org-password-manager-generate-password))
     :after ( org)
     :config
     (defun gb/browse-to-link-property ()
       "get the property ':LINK:' from the entry at point and browse to url given as value"
       (interactive)
       (browse-url (org-entry-get (point) "LINK" t))))
 #+END_SRC
*** hide passwords in org files
    - loaded from [[https://raw.githubusercontent.com/jekor/hidepw/master/hidepw.el][here]]
    - hides passwords in password manager (any entry with ':PASSWORD:')
    #+BEGIN_SRC emacs-lisp
      (if (file-exists-p "~/.emacs.d/additionals/hidepw.el")
          (use-package hidepw
            :load-path "~/.emacs.d/additionals/"
            :after ( org)
            :init (progn
              (add-hook 'org-mode-hook  'hidepw-mode)
              )
            :config
            (progn
              (setq hidepw-pattern ":.*PASS.*: \\(.*\\)")
              ))
        (message "WARNING: hidepw.el not found. passwords will not be hidden in gpg files."))
    #+END_SRC
*** export modules (e.g. ox-confluence)
 #+BEGIN_SRC emacs-lisp
   ;;      (add-to-list 'load-path "~/.emacs.d/org-mode-exports/")
   ;;      (use-package ox-confluence
   ;;        :after ( org)
   ;;        :commands org-confluence-export-as-confluence
   ;; ;;       :load-path "~/.emacs.d/org-mode-exports/"
   ;;        :loader :path)
 #+END_SRC
*** personal blogs
    - expects ~/Document/blog/org-jekyll.el to exist
    - download from [[http://github.com/juanre/org-jekyll][here]]
    - documentation [[http://juanreyero.com/open/org-jekyll/index.html][here]]
 #+BEGIN_SRC emacs-lisp
   (if (file-exists-p "~/Documents/blog/org-jekyll.el")
       (use-package org-jekyll
         :after ( org)
         :defer 3
         :load-path "~/Documents/blog"))
 #+END_SRC
*** make org export use better highlighting with htmlize
 #+BEGIN_SRC emacs-lisp
    (use-package htmlize
      :defer 30)
 #+END_SRC
*** IMPLEMENT helm org rifle
**** find keybindings
  #+BEGIN_SRC emacs-lisp
    (use-package helm-org-rifle
       :after ( helm org)
       :commands helm-org-rifle helm-org-rifle-directories helm-org-rifle-files)
  #+END_SRC
**** available functions
***** helm-org-rifle
      searches all open org files
***** helm-org-rifle-current-buffer
      searches the current buffers org file
***** helm-org-rifle-directories
      Shows results from selected directories; with prefix, recursively.
***** helm-org-rifle-files
      Shows results from selected files.
*** org appt (notification of agenda items)
    #+BEGIN_SRC emacs-lisp
    (use-package appt
      :after ( org)
      :defer 20
      :init (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view
      :config
      (setq appt-time-msg-list nil)    ;; clear existing appt list
      (setq appt-display-interval '10) ;; warn every 10 minutes from t - appt-message-warning-time
      (setq
       appt-message-warning-time '10  ;; send first warning 10 minutes before appointment
       appt-display-mode-line nil     ;; don't show in the modeline
       appt-display-format 'window)   ;; pass warnings to the designated window function
      (appt-activate 1)                ;; activate appointment notification
      (display-time)                   ;; activate time display

      (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
      (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly

      ;; set up the call to terminal-notifier
      (defvar gb/appt-notifier-path (s-trim (shell-command-to-string "which notify-send")))

      (defun gb/appt-send-notification (title msg)
        (shell-command (concat gb/appt-notifier-path " " msg " -a " title)))

      ;; designate the window function for my-appt-send-notification
      (defun gb/appt-display (min-to-app new-time msg)
        (gb/appt-send-notification
         (format "'Appointment in %s minutes'" min-to-app)    ;; passed to -title in terminal-notifier call
         (format "'%s'" msg)))                                ;; passed to -message in terminal-notifier call

      (setq appt-disp-window-function (function gb/appt-display)))

    #+END_SRC
*** org review
    #+BEGIN_SRC emacs-lisp
      (use-package org-review
        :commands org-review-insert-next-review org-review-insert-last-review
        :after ( org))
    #+END_SRC
*** org ref
    - see https://github.com/jkitchin/org-ref
    #+BEGIN_SRC emacs-lisp
      (use-package org-ref
        :commands org-ref-insert-link
                  org-ref-helm-insert-ref-link
                  org-ref-list-of-tables
                  org-ref-list-of-figures
                  org-ref-helm-insert-label-link
        :after ( org helm-bibtex pdf-tools ivy hydra helm))
    #+END_SRC
*** org clip
    - ox-clip-formatted-copy copies selected region of org mode file as rtf into clipboard for insertion into e.g. open office
    #+BEGIN_SRC emacs-lisp
    (use-package ox-clip
      :commands ox-clip-formatted-copy
      :after ( org htmlize))
    #+END_SRC
*** org babel
    #+BEGIN_SRC emacs-lisp
     ;; set jar path for ditaa
     ;; sh 'brew info ditaa | grep -oe "/usr/local[^ ]*"' produces path to /usr/local/Cellar/ditaa/0.10
     ;; within this dir the file INSTALL_RECEIPT.json exists.
     ;; within this json file, under the key source.version.stable = '0.10' the version string is accessible
     ;; thus the org-ditaa-jar-path can be constructed (which is true for mac os brew systems)
     (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_10.jar") ;; "/usr/local/bin/ditaa"

     (custom-set-faces
      `(org-block-begin-line ((t ( ;;:underline "#A7A6AA"
                                  :height 0.8 :foreground "#606060"))))
      `(org-block-end-line ((t (
      ;; :overline "#A7A6AA"
      :height 0.8 :foreground "#606060"))))
      )
     ;; set sed command for org babel
     (setq org-babel-sed-command "/usr/local/opt/gnu-sed/libexec/gnubin/sed")

     (setq org-src-fontify-natively t)
     (setq org-src-tab-acts-natively t)
     (setq org-edit-src-content-indentation 0)

     ;; (addToList org-babel-shell-names "fish")

     ;; do not ask for confirmation when executing functions in org babel
     ;; (setq org-confirm-babel-evaluate nil)
     ;; Disable confirmation question when evaluating (C-c C-c) these languages
     (defun gb/org-confirm-babel-evaluate (lang body)
       (not (or (string= lang "plantuml")
                ;; ... add more above this line when needed ...
                )))
     (setq org-confirm-babel-evaluate 'gb/org-confirm-babel-evaluate)

     ;; redisplay images after org babel execute
     (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)


    ;;    - original source http://www.holgerschurig.de/en/emacs-init-tangle/
    (defun gb/speedy-emacs-init-tangle (filename)
      "This function will write all source blocks from FILENAME into
    ~/.emacs.d/init.el that are ...

    - not marked as =tangle: no=
    - doesn't have the TODO state =CANCELLED=
    - have a source-code of =emacs-lisp="
      (require 'org)
      (let* ((body-list ())
             (output-file "~/.emacs.d/init.el")
             (org-babel-default-header-args (org-babel-merge-params org-babel-default-header-args
                                                                    (list (cons :tangle output-file)))))
        (message "Writing %s ..." output-file)
        (save-restriction
          (save-excursion
            (org-babel-map-src-blocks filename
                                      (let* ((info (org-babel-get-src-block-info 'light))
                                             (tfile (cdr (assq :tangle (nth 2 info))))
                                             (match))
                                        (save-excursion
                                          (catch 'exit
                                            (org-back-to-heading t)
                                            (when (looking-at org-outline-regexp)
                                              (goto-char (1- (match-end 0))))
                                            (when (looking-at (concat " +" org-todo-regexp "\\( +\\|[ \t]*$\\)"))
                                              (setq match (match-string 1)))))
                                        (unless (or (string= "no" tfile)
                                                    (string= "CANCELED" match)
                                                    (not (string= "emacs-lisp" lang)))
                                          (add-to-list 'body-list body)))))
          (with-temp-file output-file
            (insert (format ";; Don't edit this file, edit '%s' instead ...\n\n" filename))
            (insert (apply 'concat (reverse body-list)))
            (emacs-lisp-mode)
            (condition-case nil
                (check-parens)
              ;; error case is not executed even though user-error should be signaled if an error occurs
              (user-error (with-current-buffer (generate-new-buffer "*Generated init.el*")
                       (insert-file output-file)
                       (emacs-lisp-mode)
                       (check-parens)
                       (switch-to-buffer "*Generated init.el*")))))
          (message "Wrote %s ..." output-file))))

     ;; execute org babel if current major mode is org-mode
     ;; and the file has source code regions
     ;; and the file defines a header-args property with value :tangle ...
     ;; if this file writes into ~/.emacs.d/init.el then gb/speedy-emacs-init-tangle is used
     (defun gb/tangle-on-save-org-mode-file()
       (when (string= major-mode "org-mode")
         (progn
           (let ((has-source-regions (gb/buffer-contains-string "^ *#\\+BEGIN_SRC"))
                 (should-tangle (gb/buffer-contains-string "^#\\+PROPERTY: +header-args +:tangle"))
                 (target-is-initel (gb/buffer-contains-string (concat "^#\\+PROPERTY: +header-args +:tangle +" (regexp-quote "~/.emacs.d/init.el")))))
             (if (and has-source-regions should-tangle)
                 (progn
                   (when (package-installed-p 'yankpad)
                     (remove-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))
                   (when (package-installed-p 'pretty-mode)
                     (global-pretty-mode -1))
                   (when ligatures-enabled
                     (remove-hook 'prog-mode-hook
                                  #'add-fira-code-symbol-keywords))

                   (message "executing org-babel-tangle ...")
                   (if target-is-initel
                       (gb/speedy-emacs-init-tangle (buffer-file-name))
                     (let ((inhibit-message t))
                       (org-babel-tangle)))
                   (message "executing org-babel-tangle ... done.")

                   (when ligatures-enabled
                     (add-hook 'prog-mode-hook
                               #'add-fira-code-symbol-keywords))
                   ;; check whether readonly should be applied again
                   ;; only if currently not in detailed edit mode
                   (gb/activate-properties-in-org-mode)
                   ;; the following currently takes about 3 seconds (which I don't want to spend)
                   ;;(when (package-installed-p 'pretty-mode)
                   ;;  (global-pretty-mode 1))
                   (when (package-installed-p 'yankpad)
                     (add-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))))))))

     ;; execute org babel on safe (if major mode is org-mode
     (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)

     ;; set default header args for plantuml
     (setq org-babel-default-header-args:PlantUML
           '((:results . "file") (:exports . "results") (:noweb . "yes") (:cmdline . "-charset UTF-8")))

     ;; use cider as backend for clojure
     (setq org-babel-clojure-backend (quote cider))

     ;; function is renamed to ...x (since it should not collide with impl. in org)
     (require 'ob-clojure) ;; load this first, then define the new function
     (defun org-babel-execute:clojure (body params)
       "Execute a block of Clojure code with Babel. Changes by GB"
       (let ((expanded (org-babel-expand-body:clojure body params))
             result)
         (cl-case org-babel-clojure-backend
           (cider
            (require 'cider)
            (let ((result-params (cdr (assq :result-params params))))
              (setq result
                    (nrepl-dict-get
                     (nrepl-sync-request:eval
                      expanded (cider-current-connection)) ;; <------------- change in cider api
                     (if (or (member "output" result-params)
                             (member "pp" result-params))
                         "out"
                       "value")))))
           (slime
            (require 'slime)
            (with-temp-buffer
              (insert expanded)
              (setq result
                    (slime-eval
                     `(swank:eval-and-grab-output
                       ,(buffer-substring-no-properties (point-min) (point-max)))
                     (cdr (assq :package params)))))))
         (org-babel-result-cond (cdr (assq :result-params params))
           result
           (condition-case nil (org-babel-script-escape result)
             (error result)))))

     ;; enable all languages listed below within org babel
     (when (version<= "9.0.5" (org-version))
       ;; (require 'ob-clojurescript)
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((java . t)
          (clojure . t)
          ;; (clojurescript . t)
          (ditaa . t)
          (dot . t)
          ;; (elixir . t)
          (emacs-lisp . t)
          (gnuplot . t)
          (groovy . t)
          (latex . t) ;; needs org-edit-latex
          ;; (max . t) ;; maxima
          (plantuml . t)
          ;; (prolog . t)
          (python . t)
          ;; (scala . t)
          (scheme . t)
          (sed . t)
          (shell . t)
          ;; (sml . t) ;; standard ml
          (sql . t))))

    #+END_SRC
**** org babel clojurescript
     - prerequisite is availability of lumo (arch: 'yaourt -S lumo-git')
     - lumo is expected in /usr/local/bin/lumo (crete symlink might be necessary)
     #+BEGIN_SRC emacs-lisp
     (use-package ob-clojurescript
       :ensure ob-clojurescript)
     #+END_SRC
**** org babel lfe
     - use e.g. '#+BEGIN_SRC lfe :session mysession'
     - see [[https://github.com/zweifisch/ob-lfe][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-lfe
       :defer 10
       :after ( org))
     #+END_SRC
**** org babel mongo
     - use with following parameters for begin_src block
       :db        Database name
       :host      Host
       :port      Port
       :user	  Username
       :password  Password
       :mongoexec Mongo executable
     - see [[https://github.com/krisajenkins/ob-mongo][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-mongo
       :defer 10
       :after ( org))
     #+END_SRC
**** org babel redis
     - use e.g. '#+BEGIN_SRC redis db: 127.0.0.1:6379'
     - see [[https://github.com/stardiviner/ob-redis][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-redis
       :defer 10
       :after ( org))
     #+END_SRC
**** org babel translate
     - translate a babel source code e.g. '#+BEGIN_SRC translate :src de :dest it'
     - src can be omitted (is then auto)
     - see [[https://github.com/krisajenkins/ob-translate][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-translate
       :defer 10
       :after ( org))
     #+END_SRC
**** org babel typescript
     #+BEGIN_SRC emacs-lisp
     (use-package ob-typescript
       :ensure ob-typescript
       :after ( org))
     #+END_SRC
**** org babel kotlin
     #+BEGIN_SRC emacs-lisp
     (use-package ob-kotlin
       :defer 10
       :after ( org))
     #+END_SRC
**** org babel elixir
     #+BEGIN_SRC emacs-lisp
     (use-package ob-elixir
       :ensure ob-elixir
       :after ( org))
     #+END_SRC
**** org babel browser
     #+BEGIN_SRC emacs-lisp
     (use-package ob-browser
       :defer 10
       :after ( org))
     #+END_SRC
*** ob async
    - add ':async t' to #begin_src header, execution of block (C-c C-c within babel block) executes asynchronously)
    - see [[https://github.com/astahlman/ob-async][here]]
    #+BEGIN_SRC emacs-lisp
    (use-package ob-async
      :ensure ob-async
       :after ( org async))
    #+END_SRC
*** adaptive warp
    #+BEGIN_SRC emacs-lisp
      (use-package adaptive-wrap)
    #+END_SRC
*** insertion of web images
    - allow insertion of images via url, which automatically downloads
      into a local folder and creates a link within the org file
      [[https://github.com/tashrifsanil/org-easy-img-insert]]
    #+BEGIN_SRC emacs-lisp
      (use-package org-easy-img-insert
        :after ( org)
        :bind ("C-c i" . org-easy-img-insert)
        :config (progn))
    #+END_SRC
*** org reveal (presentation)
    #+BEGIN_SRC emacs-lisp
    (use-package ox-reveal
      :ensure ox-reveal
      :after ( org htmlize)
      :config
      (progn
        (setq org-reveal-root "./reveal.js"))) ;; look into local folder
    #+END_SRC
*** org table sticky headers
    - see [[https://github.com/cute-jumper/org-table-sticky-header][home page]]
    - headers of org tables stay in the header line while scrolling them out of view
    #+BEGIN_SRC emacs-lisp
      (use-package org-table-sticky-header
        :ensure org-table-sticky-header
        :after ( org)
        :init
        (progn (add-hook 'org-mode-hook 'org-table-sticky-header-mode)))
    #+END_SRC
*** org pdfview links
    - see [[https://github.com/markus1189/org-pdfview][homepage]]
    - executing M-x org-store-link within pdf-view-mode, will store a link that can be inserted into org mode via C-c C-l
    - when opening this link, pdf-view-mode is opened instead of system default pdf viewer!
    #+BEGIN_SRC emacs-lisp
      (use-package org-pdfview
        :ensure org-pdfview
        :after (org pdf-tools))
      (progn
        (defun ensure-org-pdfview ()
          "ensure that package org-pdfview is loaded"
          (require 'org-pdfview))
        (when (fboundp 'org-mode)
          (add-hook 'org-mode-hook #'ensure-org-pdfview))
        (when (fboundp 'pdf-view-mode)
          (add-hook 'pdf-view-mode-hook #'ensure-org-pdfview)))

      (use-package org-pdfview
        :after ( org pdf-tools))
    #+END_SRC
*** org magit
    #+BEGIN_SRC emacs-lisp
    (use-package orgit
      :after ( org magit)
      :defer 40)
    #+END_SRC
** slack (disabled)
 #+BEGIN_SRC emacs-lisp :tangle no

   (use-package slack
     :ensure t
     :disabled t
     :init           
     (setq slack-enable-emoji t) ;; if you want to enable emoji, default nil
     ;; (setq slack-room-subscription '(clojurians itemisHamburg))

     :config  
     (slack-start)
     (let* ((auth-map (jde-read-properties-file "~/.slack-auth.properties.gpg")))
       (slack-register-team
        :name "itemis-hh"
        :default t
        :client-id (gethash "slack-client-id" auth-map)
        :client-secret (gethash "slack-client-secret" auth-map)
        :token (gethash "slack-token" auth-map)
        :subscribed-channels '(general random))
       (slack-register-team
        :name "clojurians"
        :client-id (gethash "slack-client-id" auth-map)
        :client-secret (gethash "slack-client-secret" auth-map)
        :token (gethash "slack-token" auth-map)
        :subscribed-channels '(cider clojure-hamburg))
       ))


 #+END_SRC
* ido (disabled, now using helm)
** ido itself (configured to being not used, since it is started anyways)
   #+BEGIN_SRC emacs-lisp
   (use-package ido
     :config
     ;; ido-mode allows you to more easily navigate choices. For example,
     ;; when you want to switch buffers, ido presents you with a list
     ;; of buffers in the the mini-buffer. As you start to type a buffer's
     ;; name, ido will narrow down the list of buffers to match the text
     ;; you've typed in
     ;; http://www.emacswiki.org/emacs/InteractivelyDoThings
     (ido-mode 0)
     (setq ido-mode nil)

     ;; This allows partial matches, e.g. "tl" will match "Tyrion Lannister"
     (setq ido-enable-flex-matching t)

     ;; Turn this behavior off because it's annoying
     (setq ido-use-filename-at-point nil)

     ;; Don't try to match file across all "work" directories; only match files
     ;; in the current directory displayed in the minibuffer
     (setq ido-auto-merge-work-directories-length -1)

     ;; Includes buffer names of recently open files, even if they're not
     ;; open now
     (setq ido-use-virtual-buffers t)

     (defface ivy-current-match
       '((((class color) (background light))
          :background "#1a4b77" :foreground "white")
         (((class color) (background dark))
          :background "#65a7e2" :foreground "black"))
       "Face used by Ivy for highlighting first match.")

     (setq ivy-display-style 'fancy)
     )
   #+END_SRC
** ido grid (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-grid-mode
    :after ( ido)
    :disabled t
    :config
    ;; ido-grid-mode-max-columns 2
    ;; ido-grid-mode-min-columns 2
    (setq ido-grid-mode-max-rows 15
          ido-grid-mode-min-rows 10
          ido-grid-mode-max-columns 4
          ido-grid-mode-prefix-scrolls t
          ido-grid-mode-scroll-down #'ido-grid-mode-next-row
          ido-grid-mode-scroll-up #'ido-grid-mode-previous-row
          ido-grid-mode-order 'Row-mode ;; order is rows -> columns (t = columns -> rows)
          ido-grid-mode-start-collapsed nil) ;; collapsed = 1 row, on <tab> expand (if more than one is available)
    (ido-grid-mode 1))
#+END_SRC
** ido vertical (currently disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-vertical-mode
    :disabled t
    :after ( ido)
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))
#+END_SRC
** ido ubiquitous (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ido-ubiquitous
       :after ( ido)
       :disabled t
       :config 
       ;; This enables ido in all contexts where it could be useful, not just
       ;; for selecting buffer and file names
       (ido-ubiquitous-mode 1))   
   #+END_SRC
** flex ido (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
    (use-package flx-ido
      :after ( ido org)
      :disabled t
      :config
    (flx-ido-mode 1)
    (ido-mode 1)
    (ido-everywhere 1)
    ;; disable ido faces to see flx highlights.
    (setq ido-enable-flex-matching t)
    (setq ido-use-faces nil)
    (setq org-completion-use-ido t))   
   #+END_SRC
* helm
** helm
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure async) ;; TODO: add all async requirements, otherwise this will not work
  (use-package popup
    :ensure popup)
  (use-package helm-core
    :ensure helm-core
    :after ( async))
  (use-package helm
    :ensure helm
    :after ( async popup rainbow-delimiters ido)
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("s-f" . helm-for-files)
           ("C-x s-f" . helm-for-files)
           ("C-x C-b" . helm-mini) ;;helm-buffers-list
           ("C-s-i" . helm-semantic-or-imenu)
           ;; resume previous helm session whatever it was, with the selection that was active then
           ;; helm-resume
           )
    :init (progn
      ;; register new function
      (add-hook 'helm-minibuffer-set-up-hook
                'gb/helm-hide-minibuffer-maybe)
    )
    :config
    (progn
      ;; ignore files in boring file rexp list
      ;; make sure keyboard entry is displayed in header line of helm buffer
      (setq helm-echo-input-in-header-line t)

      ;; make sure that minibuffer stays untouched if entry is displayed in top of helm buffer
      (defun gb/helm-hide-minibuffer-maybe ()
        "Hide minibuffer in Helm session if we use the header line as input field."
        (when (with-helm-buffer helm-echo-input-in-header-line)
          (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
            (overlay-put ov 'window (selected-window))
            (overlay-put ov 'face
                         (let ((bg-color (face-background 'default nil)))
                           `(:background ,bg-color :foreground ,bg-color)))
            (setq-local cursor-type nil))))


      (helm-mode 1)
      (setq helm-display-function 'pop-to-buffer)
      (require 'helm-locate)
      (setq helm-locate-command "locate %s %s")
      (custom-set-faces
       '(match ((t (:background "#1d1f21" :foreground "DarkGoldenrod1" :inverse-video nil)))))
      (setq helm-split-window-default-side 'right)
      (setq helm-buffer-max-length nil)
      (setq helm-ff-skip-boring-files t)
      (require 'helm-files)
      (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/elpa/.*")
      (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/.*autoloads\.elc?$")
      (add-to-list 'helm-boring-file-regexp-list "TAGS$")
      (add-to-list 'helm-boring-file-regexp-list "ido\.last$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*cache\.elc?$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*bookmarks$")
      (add-to-list 'helm-boring-file-regexp-list "News/KILL$")
      (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/\.session$")
      (add-to-list 'helm-boring-file-regexp-list "\.newsrc$")
      (add-to-list 'helm-boring-file-regexp-list "\.newsrc\.eld$")
      (add-to-list 'helm-boring-file-regexp-list "\.elfeed/index$")
      (setq helm-M-x-always-save-history t)))
#+END_SRC
** helm cmd t
   #+begin_src emacs-lisp
     (use-package helm-cmd-t
       :bind (("s-r" . helm-cmd-t)
              ("s-t" . helm-cmd-t-repos))
       :config
       (setq helm-cmd-t-candidate-number-limit 60))
   #+end_src
** helm git grep
   #+begin_src emacs-lisp 
     (use-package helm-ls-git
       :ensure helm-ls-git
       :after ( helm)
       :bind (:map magit-mode-map
                   ("s-f" . helm-ls-git-ls)))
   #+end_src
   #+BEGIN_SRC emacs-lisp
     (use-package helm-git-grep
       :ensure helm-git-grep
       :after ( helm)
       :bind (("C-c g" . helm-git-grep)
              :map isearch-mode-map
              ("C-c g" . helm-git-grep-from-isearch)
              :map helm-map
              ("C-c g" . helm-git-grep-from-helm))
       ;; :config
       ;; (bind-key "C-c g" 'helm-git-grep)       
       ;; ;; Invoke `helm-git-grep' from isearch.
       ;; (bind-key "C-c g" 'helm-git-grep-from-isearch isearch-mode-map)
       ;; ;; Invoke `helm-git-grep' from other helm.
       ;; (bind-key "C-c g" 'helm-git-grep-from-helm helm-map)
       )
   #+END_SRC
** helm projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after ( helm projectile)
    :config
    (helm-projectile-on)) ;; enable helm projectile key bindings, helm-projectile-off restores old keybindings
#+END_SRC
** sort helm with flex
   - helm candidates are sorted using flx (more fuzzy sorting)
 #+BEGIN_SRC emacs-lisp
   (use-package helm-flx
     :ensure helm-flx
     :after ( helm)
     :config
     (progn
       (helm-flx-mode +1)
       ;; optional fuzzy matching for helm-M-x
       (setq helm-M-x-fuzzy-match t) 

       (setq helm-bookmark-show-location t)
       (setq helm-completion-in-region-fuzzy-match t)
       (setq helm-file-cache-fuzzy-match t)
       (setq helm-mode-fuzzy-match t)
       ;; ---
       (setq helm-ff-fuzzy-matching t)
       ;; only possible in unix environments (adds -b to locate)
       ;; (setq helm-locate-fuzzy-match t)
       (setq helm-etags-fuzzy-match t)
       (setq helm-recentf-fuzzy-match t)
       (setq helm-imenu-fuzzy-match t)
       (setq helm-buffers-fuzzy-matching t)
       (setq helm-lisp-fuzzy-completion t)
       (setq helm-apropos-fuzzy-match t)
       (setq helm-company-fuzzy-match t)
       (setq helm-projectile-fuzzy-match t)
       (setq helm-locate-library-fuzzy-match t)))
 #+END_SRC
** helm extensions
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package helm-ext
     :ensure helm-ext
     :after ( helm)
     :config
     (progn
       (helm-ext-ff-enable-skipping-dots nil) ;; skip . and .. directory entries in non-empty directories :: nil because renaming from dired to other open dir would not work
       (helm-ext-ff-enable-zsh-path-expansion t) ;; allow for /h/q/f/b to expand to /home/qjp/foo/bar
       (helm-ext-ff-enable-auto-path-expansion t) ;; expansion is done during typing
       (helm-ext-minibuffer-enable-header-line-maybe t) ;; allow helm expansion in mini buffer (using header line to do so)
       ;; additional command ace-jump-helm-line
       ))
   #+END_SRC
* vagrant docker ansible
** docker
#+BEGIN_SRC emacs-lisp
  (use-package docker
    :commands docker-machines docker-volumes docker-images docker-containers
    :ensure docker
    :config
    (progn
      (if (is-macos-p)
          (progn
            (setenv "DOCKER_TLS_VERIFY" "1")
            (setenv "DOCKER_HOST" "tcp://192.168.99.100:2376")
            (setenv "DOCKER_CERT_PATH" "~/.docker/machine/machines/docker-host-4gb-2cpu")
            (setenv "DOCKER_MACHINE_NAME" "docker-host-4gb-2cpu")))
      ))
  (use-package docker-tramp
    :ensure docker-tramp
    :after ( docker))
#+END_SRC
** vagrant
#+BEGIN_SRC emacs-lisp
  (use-package vagrant
    :commands vagrant-up vagrant-edit vagrant-status)
  (use-package vagrant-tramp
    :defer 20
    :after ( vagrant)
    :commands vagrant-tramp-term)
#+END_SRC
** ansible
*** ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ansible
        :defer 30
        :commands ansible)
    #+END_SRC
*** ansible-doc (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ansible-doc
      :defer 30
      :commands ansible-doc ansible-doc-mode)
    #+END_SRC
*** company-ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package company-ansible
      :defer 30
      :after ( company))
    #+END_SRC
* imenu
  - display imenu in separate buffer (through 'M-x imenu-list-minor-mode')
  - https://github.com/bmag/imenu-list
  #+BEGIN_SRC emacs-lisp
    (use-package imenu-list
      :ensure imenu-list)
    ;; (use-package imenu+)
  #+END_SRC
* imenu-anywhere
  show ido/helm menu for all etags of currently open buffers
  the commands are
  - imenu-anyhwere
  - helm-imenu-anywhere
  #+BEGIN_SRC emacs-lisp
    (use-package imenu-anywhere
      :ensure imenu-anywhere
      :bind (("s-i" . helm-imenu-anywhere)
             ("s-I" . helm-imenu-anywhere)))
  #+END_SRC
* crux (disabled)
  - look at https://github.com/bbatsov/crux for additional functions that might be of interest
#+BEGIN_SRC emacs-lisp :tangle no
(use-package crux
   :disabled t
   :bind (("C-u s-f" . crux-recentf-ido-find-file)) ;; recent file selection with ido
)
#+END_SRC
* flycheck-tip
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-tip)
#+END_SRC
* hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :bind (
           ( "<f1>" . hydra-allhydras/body) ;; globally defined, can be locally redefined
           ( "<M-f1>" . hydra-allhydras/body) ;; always jump to the global hydra
           ;; make buffer specific f1 bindings
           ;; :map org-agenda-mode-map
           ;; ( "<f1>" . hydra-org-agenda-view/body )
           )
    :config



    ;;--------------------------------------------------------------------------------
    ;; (when (package-installed-p 'org)
    ;;   (defun org-agenda-cts ()
    ;;     (ignore-errors
    ;;       (let* ((args (get-text-property
    ;;                     (min (1- (point-max)) (point))
    ;;                     'org-last-args)))

    ;;         (nth 2 args))))

    ;;   ;; currently not functional (probably because of hydra update)
    ;;   (defhydra hydra-org-agenda-view ()
    ;;     "
    ;;         org agenda view
    ;;         ------------------------------------------------------
    ;;         _d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
    ;;         _w_: ?w? week       _[_: inactive      _A_: arch-files
    ;;         _t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
    ;;         _m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
    ;;         _y_: ?y? year       _q_: quit          _L__l__c_: ?l?

    ;;       %s(hydra-combine-functions-w-key-bindings
    ;;         '((\"  [d]   day      \" . org-agenda-day-view)
    ;;           (\"  [w]   week     \" . org-agenda-week-view)
    ;;           (\"  [t]   fortnight\" . org-agenda-fortnight-view)
    ;;           (\"  [m]   month    \" . org-agenda-month-view)
    ;;           (\"  [y]   year     \" . org-agenda-year-view)
    ;;           (\"  [lLc] log mode \" . org-agenda-log-mode)
    ;;           (\"  [f]   follow   \" . org-agenda-follow-mode)
    ;;           (\"  [aA]  archive  \" . org-agenda-archives-mode)
    ;;           (\"  [r]   report   \" . org-agenda-clockreport-mode)
    ;;           (\"  [e]   entry    \" . org-agenda-entry-text-mode)
    ;;           (\"  [g]   grid     \" . org-agenda-toggle-time-grid)
    ;;           (\"  [D]   diary    \" . org-agenda-toggle-diary)
    ;;           ))
    ;;       "
    ;;     ("SPC" org-agenda-reset-view)
    ;;     ("d" org-agenda-day-view
    ;;      (if (eq 'day (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("w" org-agenda-week-view
    ;;      (if (eq 'week (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("t" org-agenda-fortnight-view
    ;;      (if (eq 'fortnight (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("m" org-agenda-month-view
    ;;      (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("y" org-agenda-year-view
    ;;      (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("l" org-agenda-log-mode
    ;;      (format "% -3S" org-agenda-show-log))
    ;;     ("L" (org-agenda-log-mode '(4)))
    ;;     ("c" (org-agenda-log-mode 'clockcheck))
    ;;     ("f" org-agenda-follow-mode
    ;;      (format "% -3S" org-agenda-follow-mode))
    ;;     ("a" org-agenda-archives-mode)
    ;;     ("A" (org-agenda-archives-mode 'files))
    ;;     ("r" org-agenda-clockreport-mode
    ;;      (format "% -3S" org-agenda-clockreport-mode))
    ;;     ("e" org-agenda-entry-text-mode
    ;;      (format "% -3S" org-agenda-entry-text-mode))
    ;;     ("g" org-agenda-toggle-time-grid
    ;;      (format "% -3S" org-agenda-use-time-grid))
    ;;     ("D" org-agenda-toggle-diary
    ;;      (format "% -3S" org-agenda-include-diary))
    ;;     ("!" org-agenda-toggle-deadlines)
    ;;     ("["
    ;;      (let ((org-agenda-include-inactive-timestamps t))
    ;;        (org-agenda-check-type t 'timeline 'agenda)
    ;;        (org-agenda-redo)))
    ;;     ("q" (message "Abort") :exit t)))

    ;;--------------------------------------------------------------------------------
    (defhydra hydra-profiler ()
      "
          profiler
          ^-^-------------------^-^-----------------
          _s_: start profiler   _r_: profiler report
          _e_: end profiler
        "
      ("s" profiler-start :exit t)
      ("e" profiler-stop :exit t)
      ("r" profiler-report :exit t))

    ;;--------------------------------------------------------------------------------
    (when (package-installed-p 'dash) 
      (defhydra hydra-dash ()
        "
           dash
           ^-^---------------------^-^--------------------------
           _h_ helm dash at point  _d_ dash at point
           ^ ^                     _D_ dash at point with docset

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [h] helm dash at point     \" . helm-dash-at-point)
              (\"  [d] dash at point          \" . dash-at-point)
              (\"  [D] dash at point w/ docset\" . dash-at-point-with-docset)))
        "
        ("h" helm-dash-at-point :exit t)
        ("d" dash-at-point :exit t)
        ("D" dash-at-point-with-docset :exit t)
        ))

    ;;--------------------------------------------------------------------------------
    (when (package-installed-p 'avy-zap)
      (defhydra hydra-avy ()
        "
          avy
          ^-^-------------------^-^-----------------
          _z_: zap up to char        _c_: jump to word 
          _Z_: zap to including char _l_: jump to line
          ^ ^                        _i_: jump to char within line

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [z] zap up to char       \" . avy-zap-up-to-char)
              (\"  [Z] zap to including char\" . avy-zap-to-char-dwim)
              (\"  [c] jump to word         \" . avy-goto-word-1)
              (\"  [l] jump to line         \" . avy-goto-line)
              (\"  [i] jump to char w/i line\" . avy-goto-char-in-line)))
        "
        ("c" avy-goto-word-1 :exit t)
        ("z" avy-zap-to-char :exit t)
        ("Z" avy-zap-to-char-dwim :exit t)
        ("l" avy-goto-line :exit t)
        ("i" avy-goto-char-in-line :exit t))) 

  (defhydra hydra-ui-info ()
       "
         ui-info
         -----------------------------
         _=_: what cursor position (C-u for font information)

         %s(hydra-combine-functions-w-key-bindings
            '((\" [=] what cursor position \" . what-cursor-position))))

       "
       ("=" what-cursor-position :exit t))

    ;;--------------------------------------------------------------------------------
    ;; TODO: install only those hydras that are actually defined
    (defhydra hydra-allhydras ()
      "
          list of all hydras
          ^--^------------------------^-^---------------
          _cr_: clojure refactoring   _m_ : multi cursor
          _n_ : navigate              _gm_: gnus mime
          _oa_: org agenda view       _gs_: gnus summary
          _om_: org mode              _gg_: gnus group
          _pp_: emacs profiler        _a_ : avy
          _i_ : ivy                   _d_ : dash
          _u_ : ui info
          ^ ^                         _q_ : quit
        "
      ("a" hydra-avy/body :exit t)
      ("cr" hydra-all-clojure-refactorings/body :exit t)
      ("m" hydra-multiple-cursors/body :exit t)
      ("n"  hydra-navigate-history/body :exit t)
      ("gs"  hydra-gnus-summary/body :exit t)
      ("gm" hydra-gnus-article-mime-part/body :exit t)
      ("gg" hydra-gnus-group/body :exit t)
      ("oa" hydra-org-agenda-view/body :exit t)
      ("om" hydra-org-mode/body :exit t)
      ("pp" hydra-profiler/body :exit t)
      ("i" hydra-ivy/body :exit t)
      ("d" hydra-dash/body :exit t)
      ("u" hydra-ui-info/body :exit t)
      ("q" (message "Abort") :exit t))

    )  
#+END_SRC
* TEST clear-text (mode that makes you use only the 1000 most common english words)
#+BEGIN_SRC emacs-lisp
  (use-package clear-text
    :commands clear-text-mode)
#+END_SRC
* guide keys (disabled)
** alternative to which-key
*** can be tuned to react to certain prefixes only
*** can be tuned to highlight displayed shortcuts based on regular expressions
*** [[https://github.com/kai2nenobu/guide-key]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package guide-key
  :disabled t
  :init
  (setq guide-key/guide-key-sequence '("C-c C-x"))
  (guide-key-mode 1))
(use-package guide-key-tip
  :disabled t
  :after ( guide-key))
#+END_SRC
* gnuplot
** major mode to edit .gp files and drive gnuplot directly from there
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot
    :mode ( "\\.gp\\'" . gnuplot-mode)
    :commands gnuplot-mode
    :config
    (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
    (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot-mode" t))
#+END_SRC
** alternative (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package gnuplot-mode
    :disabled t)
#+END_SRC
* graphviz dot
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :commands graphviz-dot-mode
    
    :config
    (setq graphviz-dot-view-command "xdot %s"))
#+END_SRC
* backup
** backup edited files
   #+BEGIN_SRC emacs-lisp
     ;; Write backup files to own directory
     (setq backup-directory-alist `(("." . ,(expand-file-name "~/file-backups")))
           backup-by-copying t
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC
** backup with version control and helm
  all files saved are automatically backed up using git.
  with M-x helm-backup while within the open file, old
  versions can be ediffed with the current
#+BEGIN_SRC emacs-lisp
  (use-package helm-backup
    :ensure helm-backup
    :after (helm)
    :init
    (add-hook 'after-save-hook 'helm-backup-versioning))
#+END_SRC
* latex (auctex)
** auctex
   #+BEGIN_SRC emacs-lisp
     (use-package tex-mode
       :ensure auctex
       :after ( flymake)
       :init (progn
         ;; latex, activate flyspell
         (add-hook 'TeX-mode-hook (lambda () (progn (flyspell-mode 1))))

         ;; activate auto fill mode
         (add-hook 'TeX-mode-hook #'gb/enable-auto-fill-mode)

         ;; make sure that flymake works with latex installation on mac
         (defun flymake-get-tex-args (file-name)
           (list "pdflatex" (list "-file-line-error" "-draftmode" "-interaction=nonstopmode" file-name)))
         (add-hook 'TeX-mode-hook (lambda () (flymake-mode 1)))       )
       :config
       (progn
         (setq TeX-auto-save t)
         (setq TeX-parse-self t)
         (setq TeX-save-query nil)

         (global-prettify-symbols-mode)

         ))
   #+END_SRC
** company for auctex
   - see [[https://github.com/alexeyr/company-auctex/][here]]
   - adds company backend for latex proposals
   #+BEGIN_SRC emacs-lisp
     (use-package company-auctex
       :ensure company-auctex
       :after ( tex-mode company yasnippet)
       :config (company-auctex-init))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (use-package company-math
       :ensure company-math
       :after ( company tex-mode)
       :init (add-hook 'TeX-mode-hook 'gb/latex-mode-setup)
       :config
       ;; local configuration for TeX modes
       (defun gb/latex-mode-setup ()
         (setq-local company-backends
                     (append '((company-math-symbols-latex company-latex-commands))
                             company-backends)))

       )
   #+END_SRC
** bibtex
   - check https://nickhigham.wordpress.com/2016/01/06/managing-bibtex-files-with-emacs/
   #+BEGIN_SRC emacs-lisp
     (use-package parsebib)
     (use-package let-alist)
     (use-package biblio-core
       :after ( let-alist seq dash))
     (use-package biblio
       :after ( biblio-core))
     (use-package helm-bibtex
       :after ( helm parsebib dash biblio))
   #+END_SRC
** latex extra
   - see [[https://github.com/Malabarba/latex-extra][here]]
   - add some extra navigation (C-c C-n/p next/previous, a/e beginning/end, f/b same level forward/back, u up one level)
   - content folding (tab)
   - white space handling (C-c C-q : fill paragraph similar to M-q)
  #+BEGIN_SRC emacs-lisp
    (use-package latex-extra
      :after ( tex-mode)
      :init (add-hook 'LaTeX-mode-hook #'latex-extra-mode))
  #+END_SRC
** do previewing with "M-x latex-preview-pane-mode"
   updates preview on every save
   disable by calling the same command again
  #+BEGIN_SRC emacs-lisp
  (use-package latex-preview-pane
    :after ( tex-mode pdf-tools)
    :commands latex-preview-pane-mode
    :config
    (progn
      ;; (require 'pdf-tools)
      (setq latex-preview-pane-use-frame (if gb/use-exwm t))
      (latex-preview-pane-enable)
      (require 'latex-preview-pane)
      ;;    NOTES: adjustments had to be made so that preview works with pdf-tools:
      (defun latex-preview-pane-update-p ()
        (if (eq (lpp/invoke-pdf-latex-command) 1)
            (progn
              (lpp/display-backtrace)
              (remove-overlays)
              (lpp/line-errors-to-layovers (lpp/line-errors))
              )

          (let ((pdf-filename (replace-regexp-in-string "\.tex$" ".pdf" (lpp/buffer-file-name)))
                (tex-buff (current-buffer))
                (pdf-buff (replace-regexp-in-string "\.tex" ".pdf" (buffer-name (get-file-buffer (lpp/buffer-file-name))))))
            (remove-overlays)
            ;; if the file doesn't exist, say that the file isn't available due to error messages
            (if (file-exists-p pdf-filename)
                (if (eq (get-buffer pdf-buff) nil)
                    (set-window-buffer (lpp/window-containing-preview) (find-file-noselect pdf-filename))
                  (progn
                    (set-window-buffer (lpp/window-containing-preview) pdf-buff)
                    (switch-to-buffer-other-window pdf-buff)
                    (doc-view-revert-buffer nil t)
                    (revert-buffer :NOCONFIRM t) ;; gb 20161117: added such that pdf-tools work, too!
                    (switch-to-buffer-other-window tex-buff)
                    ))

              ))))
      ))
  #+END_SRC
* bookmark+
   #+BEGIN_SRC emacs-lisp
     ;; adds lots of functions all starting with bmkp
     (use-package bookmark+)
   #+END_SRC
* dired
** configuration
   #+BEGIN_SRC emacs-lisp
   (use-package dired
     :commands dired
     :bind (("C-x d" . dired)
            :map dired-mode-map
            ("e" . gb/dired-ediff-files))
     :init
     (add-hook 'dired-mode-hook 'auto-revert-mode)
     (add-hook 'dired-mode-hook 'dired-omit-mode)
     :config
     (setq dired-dwim-target t) ;; try to guess the directory to use for dired
     (setq dired-listing-switches "-Alh --group-directories-first") ;; default switches for ls to be used for dired listing
     (setq diredp-hide-details-propagate-flag t) ;; opening subfolders inherit details flag (shown/hidden)
     (if gnu-ls-installed
         (setq insert-directory-program gnu-ls-bin-path))
     (setq  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..*")
     (setq dired-guess-shell-alist-user '(
                                          ("\\.mpe?g\\'\\|\\.avi\\'\\|\\.mp4\\'" "cvlc")
                                          ))
     ;; snippet from https://oremacs.com/2017/03/18/dired-ediff/
     (defun gb/dired-ediff-files ()
       "ediff two marked files (no questions asked)"
       (interactive)
       (let ((files (dired-get-marked-files))
             (wnd (current-window-configuration)))
         (if (<= (length files) 2)
             (let ((file1 (car files))
                   (file2 (if (cdr files)
                              (cadr files)
                            (read-file-name
                             "file: "
                             (dired-dwim-target-directory)))))
               (if (file-newer-than-file-p file1 file2)
                   (ediff-files file2 file1)
                 (ediff-files file1 file2))
               (add-hook 'ediff-after-quit-hook-internal
                         (lambda ()
                           (setq ediff-after-quit-hook-internal nil)
                           (set-window-configuration wnd))))
           (error "no more than 2 files should be marked")))))
   #+END_SRC
** dired sidebar
   #+BEGIN_SRC emacs-lisp
   (use-package vscode-icon
     :ensure vscode-icon
     :config
     ;; override the given function
     (defun vscode-icon-for-file (file)
       "Return an vscode icon image given FILE.

   Icon Source: https://github.com/vscode-icons/vscode-icons"
       (let ((default-directory
               (if (image-type-available-p 'imagemagick)
                   (concat vscode-icon-dir "23/") ;; <- originally 128 which is a bit large
                 (concat vscode-icon-dir
                         (number-to-string vscode-icon-size) "/"))))
         (if (file-directory-p file)
             (vscode-icon-dir file)
           (vscode-icon-file file)))))
   (use-package dired-sidebar
     :ensure dired-sidebar
     :bind (( "s-a" . dired-sidebar-toggle-sidebar))
     :after (dired dired-subtree all-the-icons vscode-icon)
     :init
     (progn
       (setq dired-sidebar-width 55)
       (setq dired-sidebar-icon-scale 0.18)
       (setq dired-sidebar-theme 'vscode)
       (setq dired-sidebar-use-term-integration t)
       (setq dired-sidebar-use-custom-font t)))
   #+END_SRC
** dired-du (size calc in dired)
   #+BEGIN_SRC emacs-lisp
   (use-package dired-du
     :ensure t
     :config
     (setq dired-du-size-format t)
     (setq dired-du-on-find-dired-ok t))
   #+END_SRC
** dired ls (lisp emulation)
   #+BEGIN_SRC emacs-lisp
     ;; useful in environments where ls is not a native program (e.g. windows)
     ;; allows usage of dired and ls switches
     (unless gnu-ls-installed
       (use-package ls-lisp
         :config
         (progn
           (setq ls-lisp-use-insert-directory-program nil)
           (setq ls-lisp-ignore-case 't))))
   #+END_SRC
** dired quick sort
   #+BEGIN_SRC emacs-lisp
   (when gnu-ls-installed
     (use-package dired-quick-sort
       :after ( dired hydra)
       :config
       (dired-quick-sort-setup)))
   #+END_SRC
** dired sort
   #+BEGIN_SRC emacs-lisp
     ;; popup dialog from dired buffer to set (sort) switches of ls command
     (use-package dired-sort-menu
       :after ( dired ls-lisp)
       :commands dired-sort-dialog)
   #+END_SRC
** dired+
   - adds nice coloring to expanded view of dired (coloring date part etc.)
   #+BEGIN_SRC emacs-lisp
   ;; adds lots of functions all starting with diredp-
   (use-package dired+
     :load-path "~/.emacs.d/additionals/")
   #+END_SRC
** dired rainbow
   #+BEGIN_SRC emacs-lisp
     (use-package dired-rainbow
       :ensure dired-rainbow
       :after ( dired)) ;; Extended file highlighting according to its type
   #+END_SRC
** dired subtree
   #+BEGIN_SRC emacs-lisp
     (use-package dired-subtree
       :ensure dired-subtree
       :after ( dired)
       :bind (:map dired-mode-map
              ("TAB" . dired-subtree-toggle)
              ("[" . dired-subtree-up))
       :commands dired-subtree-toggle) ;; toggle subtree open/close M-x dired-subtree-toggle
   #+END_SRC
* stripe-buffer
  add stripes to background of dired (or any other mode)
  #+BEGIN_SRC emacs-lisp
    (use-package stripe-buffer
      :init (progn
      ;; (add-hook 'dired-mode-hook 'turn-on-stripe-buffer-mode)
      ;; (add-hook 'dired-mode-hook 'stripe-listify-buffer)
      )
      :config
      (custom-set-faces
       '(stripe-highlight ((t (:background "gray15")))))
      )
  #+END_SRC
* figlet (text->ascii art)
  - 'M-x figlet' to enter a text that is transformed into asci art
  - C-u will allow the selection of the font additionally
  #+BEGIN_SRC emacs-lisp
  (use-package figlet
    :commands figlet)
  #+END_SRC
* suggest
  execute "M-x suggest" opens suggest mode
  define input, expected output and it will provide an emacs-lisp function that does exactly that
  (e.g. input = "Hello", output = "hello", result = (downcase "Hello") ;=> "hello")
  #+BEGIN_SRC emacs-lisp
    (use-package suggest
      :commands suggest)
  #+END_SRC
* visual regexp
  #+BEGIN_SRC emacs-lisp
    (use-package visual-regexp
      :ensure visual-regexp)
    (use-package visual-regexp-steroids
      :ensure visual-regexp-steroids
      :after ( visual-regexp)
      :config
      (progn 
        ;; bind key is used within config section, since vr/... are functions of visual-regexp which
        ;; are adviced by visual-regexp-steroids. If used within :bind-key, this package is not loaded!!
        (bind-key "M-%" #' vr/query-replace)
        ;; ("C-c r" . vr/replace)
        ;; ("C-r" . vr/isearch-backward)
        ;; ("C-s" . vr/isearch-forward)
        (bind-key "C-c m" #'vr/mc-mark)
        (setq vr/default-regexp-modifiers (quote (:I t :M t :S nil :U nil)))))
  #+END_SRC
* language server protocol mode
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point language server protocol mode")
#+END_SRC
  #+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp-mode)
  #+END_SRC
* nix specifics
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point nix specifics")
#+END_SRC
  #+BEGIN_SRC emacs-lisp
  ;; (use-package company-nixos-options)
  (use-package nix-mode)
  (use-package direnv
    :config
    (direnv-mode)
    (advice-add 'direnv--export :before #'(lambda (orig-func &rest args) (message "running direnv ..."))))
  #+END_SRC
* currently evaluated
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point currently evaluated")
#+END_SRC
** blimb (image manipulation using imagemagick)
   - lets you interactively select magick commands to manipulate the image in the buffer
   - it has command autocomplete, description and some parameter completion facilities
   - see [[https://github.com/walseb/blimp][homepage]]
   #+BEGIN_SRC emacs-lisp
   (use-package blimp
     :init (add-hook 'image-mode-hook 'blimp-mode))
   #+END_SRC
** emms (emacs music system)
   #+BEGIN_SRC emacs-lisp
   (use-package emms
     :ensure t
     :config
     (require 'emms-setup)
     (emms-all)
     (emms-default-players)
     (setq emms-source-file-default-directory "~/music/")
     (setq emms-playlist-buffer-name "*Music*")
     (setq emms-info-asynchronously t)
     (require 'emms-info-libtag) ;;; load functions that will talk to emms-print-metadata which in turn talks to libtag and gets metadata
     (setq emms-info-functions '(emms-info-libtag)) ;;; make sure libtag is the only thing delivering metadata
     (require 'emms-mode-line)
     (emms-mode-line 1)
     (require 'emms-playing-time)
     (emms-playing-time 1))
   #+END_SRC
** posframe (disabled)
   - posframe allows floating frames to be displayed at point position
   #+BEGIN_SRC emacs-lisp
   (use-package posframe)
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - posframe")
#+END_SRC
** flycheck-posframe
   - display flycheck results in posframe (as floating frame at point position)
   - enable via 'flycheck-posframe-mode' (not enabled by default)
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck-posframe
     :after (posframe))
   #+END_SRC
** helm-posframe (disabled)
   - show helm completion in a posframe
   - disabled because it is
     - not displayed at point position but at the bottom of the screen
     - it provides only a couple of lines for candidate selection
     - it has incompatibilities with exwm when running a graphical application (cannot s-b)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package helm-posframe
     :after (helm posframe)
     :init (helm-posframe-enable))
   #+END_SRC
** flycheck-package (elisp packages)
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck-package
     :ensure flycheck-package
     :after (flycheck))
   #+END_SRC
** ace helm line
   - display ace jump characters on each line (C-') when in helm mode
   #+BEGIN_SRC emacs-lisp
   (use-package ace-jump-helm-line
     :after ( helm)
     :bind (:map helm-map
            ( "C-'" . ace-jump-helm-line)))
   #+END_SRC
** screen cast -> gif
   #+BEGIN_SRC emacs-lisp
   (use-package gif-screencast) ;; one gif per user action
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - screen cast")
#+END_SRC
** async dired (execute several copy/zip etc. tasks asynchronously)
   - see [[https://vxlabs.com/2018/03/30/asynchronous-rsync-with-emacs-dired-and-tramp/][here]], [[https://truongtx.me/tmtxt-dired-async.html][here]] and [[https://truongtx.me/tmtxt-async-tasks.html][here]]
   - install elisp files
     git clone https://github.com/tmtxt/tmtxt-async-tasks.git
     git clone https://github.com/tmtxt/tmtxt-dired-async.git
   #+BEGIN_SRC emacs-lisp
   (when (and (file-exists-p "~/.emacs.d/additionals/tmtxt-async-tasks/tmtxt-async-tasks.el")
           (file-exists-p "~/.emacs.d/additionals/tmtxt-dired-async/tmtxt-dired-async.el"))
     (progn
       (use-package tmtxt-async-tasks
         :load-path "~/.emacs.d/additionals/tmtxt-async-tasks/")
       (use-package tmtxt-dired-async
         :after ( tmtxt-async-tasks dired)
         :load-path "~/.emacs.d/additionals/tmtxt-dired-async/"
         :bind (:map dired-mode-map
              ("C-c C-r" . tda/rsync)
              ("C-c C-z" . tda/zip)
              ("C-c C-u" . tda/unzip)
              ("C-c C-a" . tda/rsync-multiple-mark-file)
              ("C-c C-e" . tda/rysnc-multiple-empty-list)
              ("C-c C-d" . tda/rsync-multiple-remove-item)
              ("C-c C-v" . tda/rsync-multiple)
              ("C-c C-s" . tda/get-files-size)
              ("C-c C-q" . tda/download-to-current-dir)))))
   #+END_SRC
** sidebar and icons in terminal (additional icons)
   - install font-lock+ into additionals https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/font-lock%2B.el
   - install icons-in-terminal https://github.com/sebastiencs/icons-in-terminal#installation
   - install sidebar into additionals https://github.com/sebastiencs/sidebar.el
   - now on melpa: originally install frame-local into additionals https://github.com/sebastiencs/frame-local
   #+BEGIN_SRC emacs-lisp :tangle no
      (when (and (file-exists-p "~/.emacs.d/additionals/font-lock+.el")
                 ;; (file-exists-p "~/.local/share/icons-in-terminal/icons-in-terminal.el")
                 )
        (progn
          (use-package icons-in-terminal
            :after ( font-lock+)
            :load-path "~/.local/share/icons-in-terminal/")
          (when (file-exists-p "~/.emacs.d/additionals/sidebar.el/sidebar.el")
            (use-package ov)
            (use-package frame-local)
              ;; originally from here!
              ;; :load-path "~/.emacs.d/additionals/frame-local/"
            (use-package sidebar
              :after (projectile s dash dash-functional ov frame-local icons-in-terminal)
              :bind (("s-a" . gb/sidebar-toggle)
                     :map sidebar-mode-map
                     ("s-a" . sidebar-close))
              :load-path "~/.emacs.d/additionals/sidebar.el/"
              :config
              (defun sidebar-buffers-pre-command ()) ;; override default implementation
              (defun gb/sidebar-toggle ()
                ""
                (interactive)
                (if (sidebar-get-window t)
                    (sidebar-close)
                  (sidebar-open)))
              (custom-set-variables
               ;; '(sidebar-icon-powerline "")
               ;; '(sidebar-icon-modeline "")
               ;; '(sidebar-icon-header-end "")
               ;; '(sidebar-select-icon-right-header "")
               '(sidebar-mode-line-height 1.0)
               '(sidebar-width 50))
              (custom-set-faces
               '(sidebar-primary-color ((t (:background "dark goldenrod" :foreground "black"))))
               '(sidebar-select-line ((t (:background "dark goldenrod" :foreground "black" :box nil))))
               '(sidebar-suffix-path-header ((t (:foreground "#404040")))))))))
   #+END_SRC
** info colors
   #+BEGIN_SRC emacs-lisp
   (use-package info-colors
     :init (add-hook 'Info-selection-hook 'info-colors-fontify-node))
   #+END_SRC
** flycheck gradle
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck-gradle
     :after ( flycheck)
     :config (flycheck-gradle-setup))
   #+END_SRC
** atomic chrome - allow text edit are within browser to be edited with emacs
   - M-x atomic-chrome-start-server must be started within emacs
   - atomic-chrome extension must be installed within chrome
   - when within a text area of the browser, press the atomic-chrome button in the button bar, evoila, you are no in an emacs buffer editing
     the text area with life update!
   #+BEGIN_SRC emacs-lisp
     (use-package atomic-chrome
       :ensure atomic-chrome
       :config (atomic-chrome-start-server))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - atomic chrome")
#+END_SRC
** cakecrumbs (show hierarchy in header for css and html)
   #+BEGIN_SRC emacs-lisp
     (use-package cakecrumbs
       :config
       ;; Specify all major-mode (`cakecrumbs' decide how to deal with
       ;; cursor's context by variable `major-mode'.)
       (setq cakecrumbs-html-major-modes   '(html-mode web-mode nxml-mode sgml-mode))
       (setq cakecrumbs-jade-major-modes   '(yajade-mode jade-mode pug-mode))
       (setq cakecrumbs-scss-major-modes   '(scss-mode less-css-mode css-mode))
       (setq cakecrumbs-stylus-major-modes '(stylus-mode sass-mode))  ; currently, sass-mode use the same rule with stylus-mode

       ;; Auto `add-hook' for above major-mode.  (Auto enable `cakecrumbs'
       ;; for the major-modes which have specify in above variables)
       (cakecrumbs-auto-setup)

       ;; Set to number to refresh after idling N seconds.
       ;; Set to nil, refresh without any delay.
       (setq cakecrumbs-refresh-delay-seconds 0.1)

       ;; Appearances
       (setq cakecrumbs-separator " | ")
       (setq cakecrumbs-ellipsis "[...] ")

       ;; Ignore some patterns in selector string
       (setq cakecrumbs-ignored-patterns '(
                                           "[.]col-[a-z][a-z]-[0-9]+"  ; Bootstrap's .col-*
                                           ))
       )
   #+END_SRC
** auto-sudoedit
   - opens tramp sudo if file is readonly automatically (see [[https://github.com/ncaq/auto-sudoedit][here]])
   #+BEGIN_SRC emacs-lisp
   (use-package auto-sudoedit)
   #+END_SRC
** eshell auto suggestion
   #+BEGIN_SRC emacs-lisp
   (use-package esh-autosuggest
     :after ( company))
   #+END_SRC
** dimmer (disabled, mode line was dimmed, recheck 08.2018)
   - dim non selected buffers (slightly)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package dimmer
     :config (dimmer-activate))
   #+END_SRC
** eterm-256color
   - see [[http://github.com/dieggsy/eterm-256color][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package eterm-256color
     :after ( xterm-color)
     :init (add-hook 'term-mode-hook #'eterm-256color-mode))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - eterm-256color")
#+END_SRC
** pcre2el (replace regular expression syntax with more readable one)
   - see here
   #+BEGIN_SRC emacs-lisp
   (use-package pcre2el
     :ensure pcre2el
     :config (pcre-mode 1))
   #+END_SRC
** helm-exwm (allow for helm based change of exwm buffers)
   - see [[https://github.com/emacs-helm/helm-exwm][here]], problems documented [[https://github.com/emacs-helm/helm/issues/1889][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package helm-exwm
     :ensure helm-exwm
     :after ( exwm helm)
     :config
     (progn
       (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
       (setq helm-exwm-source (helm-exwm-build-source))
       (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                         helm-exwm-source
                                         helm-source-recentf))
     ))
   #+END_SRC
** indent-info (deactivated)
   - allows for display of current indent settings in the mode line
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package indent-info
     :config (global-indent-info-mode 1))
   #+END_SRC
** lsp-javascript-typescript (deactivated, for now, collision with tide)
   - see [[https://github.com/emacs-lsp/lsp-javascript]]
   - install lsp-javascript-typescript with npm: npm i -g javascript-typescript-langserver
   - currently disabled, does not compose well with tide (check whether tide should be disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package lsp-javascript-typescript
     :init
     (add-hook 'js-mode-hook #'lsp-javascript-typescript-enable)
     (add-hook 'typescript-mode-hook #'lsp-javascript-typescript-enable) ;; for typescript support
     (add-hook 'js3-mode-hook #'lsp-javascript-typescript-enable) ;; for js3-mode support
     (add-hook 'rjsx-mode #'lsp-javascript-typescript-enable) ;; for rjsx-mode support
     )
   #+END_SRC
** lsp-ui
   - emacs ui integration for lsp (like flycheck etc.)
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-ui
       :init
       (add-hook 'lsp-mode-hook 'lsp-ui-mode))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - lsp-ui")
#+END_SRC
** company lsp
   #+BEGIN_SRC emacs-lisp
   (use-package company-lsp
     :after ( company lsp-mode)
     :config (push 'company-lsp company-backends))
   #+END_SRC
** iy-goto-char
   - C-c f <char> : goto the next occurrance of <char>. <char> can then be repeatedly pressed to move on to the next after that
     #+BEGIN_SRC emacs-lisp
       (use-package iy-go-to-char
         :bind (("C-c f" . iy-go-to-char)
                ("C-c F" . iy-go-to-char-backward))
         )
     #+END_SRC
** edit-at-point
   - edit(copy,cut..) current things(word,symbol..) under cursor
   #+BEGIN_SRC emacs-lisp
   (use-package edit-at-point)
   #+END_SRC
** eno, ace like copy, cut, past and move
   #+BEGIN_SRC emacs-lisp
     (use-package eno
       :after ( dash edit-at-point)
       :bind
         (("M-s-w j" . eno-word-goto) ;; Meta super w as leader key
          ("M-s-w c" . eno-word-copy)
          ("M-s-w t" . eno-word-cut)
          ("M-s-w p" . eno-word-paste)
          ("M-s-b j" . eno-symbol-goto)
          ("M-s-b c" . eno-symbol-copy)
          ("M-s-b t" . eno-symbol-cut)
          ("M-s-b p" . eno-symbol-paste)
          ("M-s-s j" . eno-str-goto)
          ("M-s-s c" . eno-str-copy)
          ("M-s-s t" . eno-str-cut)
          ("M-s-s p" . eno-str-paste)
          ("M-s-l j" . eno-line-goto)
          ("M-s-l c" . eno-line-copy)
          ("M-s-l t" . eno-line-cut)
          ("M-s-l p" . eno-line-paste)
          ("M-s-p j" . eno-paren-goto)
          ("M-s-p c" . eno-paren-copy)
          ("M-s-p t" . eno-paren-cut)
          ("M-s-p p" . eno-paren-paste)))
   #+END_SRC
** flycheck inline
   - display flycheck error messages inline (not as popup)
   - check whether this clashes with other flycheck packages (like flycheck-tip and flycheck-pos-tip)
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-inline
       :ensure flycheck-inline
       :after ( flycheck inline-docs)
       :config
       (flycheck-inline-mode 1) ;; see readme
       )
   #+END_SRC
** flymd
   - opens firefox to display a live view of the markdown in the buffer.
     saving the buffer does automatically update the browser view of it!
   #+BEGIN_SRC emacs-lisp
     (if chromium-installed
         (use-package flymd
           :commands flymd-flyit
           :config
           ((progn )
            ;; make sure firefox is opened, since flymd-flyit does not work with chrome!
            (defun gb/flymd-browser-function (url)
              (let ((browse-url-browser-function 'browse-url-firefox))
                (browse-url url)))
            (setq flymd-browser-open-function 'gb/flymd-browser-function))))
   #+END_SRC
** pixel-scroll (pixel wise scrolling) currently disabled
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; currently on the load path by .emacs.d/additionals
     (if (not  (file-exists-p "~/.emacs.d/additionals/pixel-scroll.el"))
         (message "WARNING: pixel-scroll.el does not exist, it will not be installed")
       (progn
         (message "OK: pixel-scroll.el locally found, will be installed")
         (use-package pixel-scroll
           :load-path "~/.emacs.d/additionals/"
           :after ( sublimity-scroll)
           :config
           (progn
             (require 'sublimity-scroll)
             ;; redefine pre command for speed up of n no pre commands are present
             (defun sublimity--pre-command ()
               (save-excursion (goto-char (window-start)) (setq sublimity--prev-lin (string-to-number (format-mode-line "%l"))))
               (setq
                     sublimity--prev-col (window-hscroll)
                     sublimity--prev-buf (current-buffer)
                     sublimity--prev-wnd (selected-window)
                     sublimity--prepared t)
               (sublimity--run-hooks sublimity--pre-command-functions))
             (setq gb/modeline-enabled t)
             (defun gb/modeline ()
               ""
               (if gb/modeline-enabled
                   (spaceline-ml-main)))
             (defun sublimity-scroll--vscroll-effect (lins)
               (save-excursion
                 (let* ((pixel-scroll-last-line (and (not (equal major-mode 'org-mode)) (> (abs lins) 5)))
                        (speeds (sublimity-scroll--gen-speeds (if pixel-scroll-last-line (* (signum lins) (- (abs lins) 1)) lins)))
                        (cursor-type (and (not sublimity-scroll-hide-cursor) cursor-type)))
                   ;; (message (concat "scroll: " (number-to-string lins) ", at: " (number-to-string (nlinum--line-number-at-pos))))
                   ;; (message pixel-scroll-last-line)
                   (sublimity-scroll--vscroll (- lins))
                   (setq gb/modeline-enabled nil)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (gb/modeline)))))
                   (dolist (speed speeds)
                     (progn
                       (sublimity-scroll--vscroll speed)
                       (force-window-update (selected-window))
                       (redisplay)))
                   (setq gb/modeline-enabled t)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (spaceline-ml-main)))))
                   (if  (and (> lins 0) pixel-scroll-last-line)
                       (progn (pixel-scroll-up 1)))
                   (if (and (< lins 0) pixel-scroll-last-line)
                       (pixel-scroll-down 1))
                   )))))))
   #+END_SRC
** helm google
   #+BEGIN_SRC emacs-lisp
   (use-package helm-google
     :commands helm-google helm-google-suggest
     :after ( helm)) ;; quick google searches, really ?
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - helm google")
#+END_SRC
** ivy swiper hydra
   #+BEGIN_SRC emacs-lisp
   (use-package ivy-hydra
     :after ( hydra ivy)) ;; adds an hydra for ivy/swiper TODO: include into own hydras
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - ivy swiper hydra")
#+END_SRC
** ripgrep over directory trees
   #+BEGIN_SRC emacs-lisp
   (use-package ripgrep
     :commands ripgrep-regexp) ;; allow M-x ripgrep-regexp (search in directory + subdirectories)
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - rip grep")
#+END_SRC
** elisp refs (find references to elisp functions....)
   #+BEGIN_SRC emacs-lisp
   (use-package elisp-refs) ;; allow M-x elisp-refs-...
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - elisp efs")
#+END_SRC
** company bib tex
   #+BEGIN_SRC emacs-lisp
   (use-package company-bibtex
     :after ( company tex-mode)) ;; add bibtex references using company
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - bib tex")
#+END_SRC
** cider stuff
   #+BEGIN_SRC emacs-lisp
   ;; C-c C-t (hydra for test in cider)
   ;; C-c M-r (hydra for repl)
   ;; C-c M-t (test)
   ;; C-c C-d (hydra for documentation)
   ;; (use-package cider-hydra ;; adds hydras
   ;;   :ensure cider-hydra
   ;;   :after ( hydra cider))
   (use-package cider-decompile ;; decompilation extension for cider [https://github.com/clojure-emacs/cider-decompile]
     :ensure cider-decompile
     :after ( cider javap-mode))
   ;; (use-package cider-profile ;; CIDER profiling support [https://github.com/thunknyc/nrepl-profile]
   ;;   :defer 10
   ;;   :after ( cider)
   ;;   :init
   ;;   (progn
   ;;     (add-hook 'cider-mode-hook 'cider-profile-mode)
   ;;     (add-hook 'cider-repl-mode-hook 'cider-profile-mode)))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - cider stuff")
#+END_SRC
** window / frame tiling
   #+BEGIN_SRC emacs-lisp
   (use-package tile
     :commands tile tile-select tile-frames-horizontal tile-frames-vertically tile-frames-top-to-bottom tile-frames-side-by-side) ;; see [https://github.com/IvanMalison/tile], tiles windows into predefined setups
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - window / frame")
#+END_SRC
** bug hunter
   #+BEGIN_SRC emacs-lisp
   (use-package bug-hunter ;; allows via commands to hunt bugs in emacs lisp files see https://github.com/Malabarba/elisp-bug-hunter

     :commands bug-hunter-file bug-hunter-init-file)

   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - bug hunter")
#+END_SRC
** flycheck scala (deactivated, ensime provides all functionality needed here)
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; install flycheck for scala
   (use-package flycheck-scala-sbt
     :after ( ensime flycheck)
     :defer t
     :init
     (progn
       (add-hook 'scala-mode-hook 'flycheck-scala-sbt-init)))

   ;; allow detection of language
   #+END_SRC
** natural language detection
   #+BEGIN_SRC emacs-lisp
   (use-package language-detection
     :commands language-detection-buffer)
   #+END_SRC
** butler (jenkins interface for emacs)
   #+BEGIN_SRC emacs-lisp
     (use-package butler
       :commands butler-status
       :config
       (progn
         ;; add server to the list
         ;; (add-to-list 'butler-server-list
         ;;          '(jenkins "SERVER-NAME"
         ;;                    (server-address . "https://jenkins-address")
         ;;                    (server-user . "user")
         ;;                    (server-password . "pass")))

         ;; add server with authfile
         ;; (add-to-list 'butler-server-list
         ;;              '(jenkins "SERVER-NAME"
         ;;                        (server-address . "https://jenkins-addres")
         ;;                        (auth-file . "~/.authinfo.gpg")))
         ;; The following line should exist in ~/.authinfo.gpg:
         ;; machine SERVER-NAME login USERNAME password PASSWORD
         ))
   #+END_SRC
** mode for unix tool pass
   #+BEGIN_SRC emacs-lisp
   (use-package passmm
     :commands passmm-list-passwords)
   #+END_SRC
** wolfram (currently disabled)
   - check [[https://github.com/hsjunnesson/wolfram.el][link]]
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package wolfram)
   #+END_SRC
** yaml
   #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode
     :ensure yaml-mode
     :mode (("\\.yml\\'" . yaml-mode)
            ("\\.yaml\\'" . yaml-mode)))
   (use-package yaml-tomato
     :ensure yaml-tomato
     :after ( yaml-mode)
     :commands (yaml-tomato-show-current-path yaml-tomato-copy))
   #+END_SRC
** agda (deactivated)
   - 'agda-mode locate' will provide the path to agda.el which in turn holds all code to actually implement the agda mode.
   - this will however not readly integrate smoothly with req-package but is alright for the time being I guess.
   #+BEGIN_SRC emacs-lisp :tangle no
     (load-file (let ((coding-system-for-read 'utf-8))
                     (shell-command-to-string "agda-mode locate")))
   #+END_SRC
** historian
   #+BEGIN_SRC emacs-lisp
   (use-package historian)
   #+END_SRC
** org-brain
   organize org files within org-brain-path into somthing like a mindmap / wiki that can be browsed
   check the [[https://github.com/Kungsgeten/org-brain][home page]]
   #+BEGIN_SRC emacs-lisp
     (use-package org-brain
       :after ( org dash helm-org-rifle)
       :commands org-brain-open org-brain-visualize org-brain-insert-link
       :config
       (progn
         (setq org-brain-path "~/brain")
         (if (not (file-exists-p org-brain-path))
             (make-directory org-brain-path t))
         (defun helm-org-rifle-brain ()
           "Rifle files in `org-brain-path'."
           (interactive)
           (helm-org-rifle-directories (list org-brain-path)))))
   #+END_SRC
** org edit latex (edit latex code in separate buffer)
   - see [[https://github.com/et2010/org-edit-latex][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package org-edit-latex
     :after ( org tex-mode)
     :defer 60)
   #+END_SRC
** helm books
   - allows searching for book titles using the google book api with helm
   #+BEGIN_SRC emacs-lisp
   (use-package helm-books
     :commands helm-books)
   #+END_SRC
** symbol-overlay
   - see [[https://github.com/wolray/symbol-overlay/][here]]
   - add some keylinks
   - allow highlighting of symbols
   #+BEGIN_SRC emacs-lisp
   (use-package symbol-overlay
     :ensure symbol-overlay
     :config (setq symbol-overlay-colors '("dodger blue" "spring green" "orchid" "salmon")))
   #+END_SRC
** smart hungry delete
   - possible replacement for hungry-delete
   - do smart delete of spaces
   #+BEGIN_SRC emacs-lisp
     (use-package smart-hungry-delete
       :ensure smart-hungry-delete
       :bind (("S-<backspace>" . smart-hungry-delete-backward-char)
   		      ("C-S-d" . smart-hungry-delete-forward-char)))
   #+END_SRC
** org recent headings
   - keep a list of lru org headings to choose from
   #+BEGIN_SRC emacs-lisp
     (use-package org-recent-headings
       :after ( org)
       :bind (("M-s-^" . org-recent-headings-helm)) ;; equivalent to M-s-i
       :config
       (progn
         (org-recent-headings-mode)))
   #+END_SRC
** org sticky headers
   - keep last header of org in head line displayed if other wise scrolling out of view
   - problematic, sometimes org-sticky-header is empty
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package org-sticky-header
     :after ( org))
   #+END_SRC
** lsp with source-graph language servers
   #+BEGIN_SRC emacs-lisp
   ;; (use-package lsp-go :after ( lsp-mode))
   ;; (use-package lsp-haskell :after ( lsp-mode))
   (use-package lsp-java
     :defer 10
     :after ( lsp-mode))
   ;; (use-package lsp-python :after ( lsp-mode))
   ;; (use-package lsp-rust :after ( lsp-mode))
   #+END_SRC
** ledger (accounting manager)
   #+BEGIN_SRC emacs-lisp
     (when ledger-installed
       (use-package ledger-mode
         :ensure ledger-mode)
       (use-package flycheck-ledger
         :ensure flycheck-ledger
         :after ( ledger-mode flycheck)))
   #+END_SRC
** move frames around
   #+BEGIN_SRC emacs-lisp
     (defun move-frame-right-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame))))
                  (maxx (-  (display-pixel-width) 800)))
              (set-frame-position (selected-frame) (min (+ xpos 800) maxx) ypos)))

     (defun move-frame-left-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame)))))
              (set-frame-position (selected-frame) (max (- xpos 800) 0) ypos)))
   #+END_SRC
** json-navigator
   #+BEGIN_SRC emacs-lisp
   (use-package json-navigator)
   #+END_SRC
** dired-collapse
   - collapse empty directories (like src/main/java... is done by github)
   #+BEGIN_SRC emacs-lisp
   (use-package dired-collapse
     :commands dired-collapse-mode)
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - dired-collapse")
#+END_SRC
** org-pomodoro (time management technique)
   - install libnotify (e.g. nix-env -iA nixos.libnotify)
   #+BEGIN_SRC emacs-lisp
     (use-package org-pomodoro
       :after ( appt)
       :commands org-pomodoro-clock-in
       :init (add-hook 'org-pomodoro-finished-hook 'gb/pomodoro-finished-notification)
       :config
       (progn
         (defun notify-osx (title message)
           (call-process "terminal-notifier"
                         nil 0 nil
                         "-group" "Emacs"
                         "-title" title
                         "-sender" "org.gnu.Emacs"
                         "-message" message))
         (defun gb/pomodoro-finished-notification ()
           "notify user about finished pomodoro"
           (if (is-macos-p)
               (notify-osx "Pomodoro completed" "Time for a short break")
             (message "Pomodoro completed, time for a short break") ;; notification for unix missing
             ))
         (setq org-pomodoro-play-sounds nil)
         ))
   #+END_SRC
** comint (shell extensions)
   - see [[https://github.com/riscy/shx-for-emacs/blob/master/README.org][homepage]]
   - e.g. additional highlighting
   - given on the home page:
     - Display graphics and plots in the shell with a simple markup language (e.g., <view image.png>)
     - Add event-driven and timed behaviors to any shell session
     - Open any filename or URL by arrowing up to it and pressing <enter>
     - Yank any line to the prompt by arrowing up to it and pressing C-<enter>
     - Check the time a command was run by mousing over its prompt
   #+BEGIN_SRC emacs-lisp
   (use-package shx
     :ensure shx
     :init (progn
        ;; add hook for shell
        (add-hook 'shell-mode-hook #'shx-mode)
     )
     :config
        ;;(shx-global-mode 1) ;; global shx mode resulted in "text read only" error in ielm when pressing return
     )
   #+END_SRC
** ob-rust
   #+BEGIN_SRC emacs-lisp
   (use-package ob-rust
     :after( org))
   #+END_SRC
** underline with char
   - call with prefix command let's you select with which char to underline
   - underlines previous line up to its end with '-'
   #+BEGIN_SRC emacs-lisp
     (use-package underline-with-char
       :commands underline-with-char)
   #+END_SRC
** yarn mode
   - open yarn lock files in a read only mode
   #+BEGIN_SRC emacs-lisp
   (use-package yarn-mode
     :ensure yarn-mode
     :mode (("\\yarn.lock\\'" . yarn-mode)))
   #+END_SRC
** all the icons dired
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-dired
       :after ( all-the-icons dired))
   #+END_SRC
** all the icons gnus
   - on hold, icons disturb custom ui settings of gnu
   - [ ] test this package with gnus ui customizations off
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package all-the-icons-gnus
     :after ( gnus all-the-icons dash)
     :config (all-the-icons-gnus-setup))
   #+END_SRC
** docker compose mode
   #+BEGIN_SRC emacs-lisp
   (use-package docker-compose-mode
     )
   #+END_SRC
** comint (bifocal)
   - will automatically split a comint buffer, if scrolling into the history (by bifocal-up, down, next, prev)
     this will enable you to view current comint output (or just keep the input line) while looking at the history of the buffer
   #+BEGIN_SRC emacs-lisp
   (use-package bifocal
     :commands bifocal-mode)
   #+END_SRC
** popwin (make windows like help, completion show in a popupwindow that can be closed via C-g
   #+BEGIN_SRC emacs-lisp
     (use-package popwin
       :ensure popwin
       :config
       (popwin-mode 1)
       (setq popwin:popup-window-height 30))
   #+END_SRC
** ranger (file browser/previewer, using dired)
   #+BEGIN_SRC emacs-lisp
     (use-package ranger
       :ensure ranger
       :config
       (setq ranger-hide-cursor nil))
   #+END_SRC
** neotree (deactivated)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package neotree
       :config
         (progn
         (setq neo-theme (if (display-graphic-p) 'nerd 'arrow))
         (setq neo-window-width 35)
         (setq neo-banner-face '((t (:foreground "DarkGoldenrod3" :weight bold))))
         (setq neo-dir-link-face '((t (:foreground "DarkOrange1"))))
         (setq neo-expand-btn-face '((t (:foreground "DarkOrange1"))))
         (setq neo-file-link-face '((t (:foreground "burlywood1"))))
         (setq neo-smart-open t)
         (setq projectile-switch-project-action 'neotree-projectile-action)))
   #+END_SRC
* to test
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point to test")
#+END_SRC
** deadgrep - ripgrep front end
** helm-tail - tailing of several sources
** lsp-html - lsp frontend for html serving
** project-abbrev - project specific abbrev expansion
** template-overlays - overlays for template regions
** company-posframe (company in separate frame, alternative to company box?)
** exwm-edit (allow to edit any editable field within exwm into a separate buffer just as atomic-chrome)
** company-nginx (allow for company completion of nginx files)
** rustic (major mode for rust)
** company-prescient (ordering and filtering of candidates)
** organize imports java
   - needs configuration, see here https://github.com/jcs090218/organize-imports-java
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package organize-imports-java)
   #+END_SRC
** ccls (c++ language server for lsp ui)
   - see here https://github.com/MaskRay/emacs-ccls
** karma test runner integration
   - upbo
** gif-screencast
   - allow screencast recording single gif for each action, combining them into animated gifs thereafter
   - https://github.com/Ambrevar/emacs-gif-screencast
** ob-clojure-literate
** org-noter
   - keep notes in an org file that scrolls with the original
** org-send-ebook
   - send an ebook link to an external device (ebook reader) from org mode
** scp (use scp to transfer files)
** smart-jump (smart go to definition)
** network-watch (allows hooks to run when network is goiing down/up)
** latexdiff (diff between two latex files)
** easy-jekyll (tool to manage jekyll blogs)
** orca (org-capture configuration)
   - allows filing based on the url it was captured from into special files/headers etc.
** lsp-javacomp
   - lsp support for java using [[https://github.com/tigersoldier/JavaComp][java-comp]]
** archive-rpm
   - provide an interface for rpm package open (extends archive-mode)
** zoom
   - keeps balanced windows, zooming the one currently having the focus
** ox-hugo
   - export org markdown to hugo blog entries
   - see [[https://github.com/kaushalmodi/ox-hugo][here]]
** shrink-path
   - do fish like reduciton of paths (e.g. for modeline)
** highlight-function-calls
   - highlight functions in lisp specially
** org-mind-map
   - translate an org file into a mind map
** org-super-agenda
   - see [[https://github.com/alphapapa/org-super-agenda][here]]
   - This package lets you "supercharge" your Org daily/weekly agenda. The idea is to group items into sections, rather than having them all
     in one big list.
   - lets you group agenda entries based on tags, regex on title, todo status etc.
** org-projectile-helm
   - This package aims to provide an easy interface to creating per project org-mode TODO headings.
** org-category-capture
   - This package aims to provide an easy interface to creating per project org-mode TODO headings.
     #+BEGIN_SRC emacs-lisp
     (use-package org-category-capture
       :after ( org))
     #+END_SRC
** treemacs (tre
** projectile-codesearch (use codesearch to query projects)
** zop-to-char (more options during zap to char)
** sx (elaborate stack exchange interface for emacs)
** swiper-helm (helm interface for swipter)
** html5-schema (html5 support for nXML)
** magit-tbdiff (diffing extension for magit)
   - git-tbdiff is a git extension that allows diffs for topic branches
   - tbdiff shows the differences between two versions of a patch series, or more generally, two sets of commits (ignoring merges). To do
     this in a meaningful way, it tries to find a good correspondence between commits in the two versions (see Algorithm below), and then
     shows the difference between the pairs found. It also copes with removal and addition of commits.
   - see [[https://github.com/magit/magit-tbdiff][link]]
** indium (java script development environment)
   - [[https://github.com/NicolasPetton/Indium][home page]]
** company suggest (propose sentence completion based on wikionary or google)
   - company-suggest, see [[https://github.com/juergenhoetzel/company-suggest][here]]
* look at
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point look at")
#+END_SRC
** powerthesaurus - interface to powerthesaurus.org
** eglot - lsp client (for multiple languages)
** pickle - Major mode for editing cucumber gherkin files.
** attrap - Attrap! provides a command to attempt to fix the flycheck error at point.(haskel and elisp currently)
** git-msg-prefix, provide prefix for commit messages based on previous commit messages and the like
** org-wild-notifier, customizable notifier for org agenda entries (global or per entry)
** texfrag
   - allow tex fragments preview in (almost) any buffer
   - see [[https://github.com/TobiasZawada/texfrag][here]]
** counsel-tramp
** helm-selected
** use-package-ensure-system-package
   - require binaries / packages of the underlying system for installation of package
   - if provided with installation script might even execute the appropriate installation
   - see [[https://github.com/waymondo/use-package-ensure-system-package][here]]
* discarded
** pinentry (obsolete as of emacs 26)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package pinentry
       :config
       (progn
         (pinentry-start)
         ))
   #+END_SRC
** company quickhelp - produces help popups for company candidates (replaced by company-box)
   #+BEGIN_SRC emacs-lisp :tangle no
       (use-package company-quickhelp
         ;; :ensure company-quickhelp
         :after (company-box)
         :config
         (progn
           ;; (company-quickhelp-mode 1)
           (setq company-quickhelp-use-propertized-text t)
           (setq company-quickhelp-max-lines 30)
           ;; (setq company-quickhelp-color-background "gray80")
           ;; (setq company-quickhelp-color-foreground "black")
           ))
   #+END_SRC
** exwm-surf
   - allows to control surf within exwm
   - surf is a webkit based browser that works as embedded x application and can thus be embedded into emacs directly
   - don't need this, since chromium or firefox can be directly embedded into exwm
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point 4")
#+END_SRC
* tested but discarded
** diminish (hide minor modes from spaceline mode line) (obsolete now)
   - its still a dependency of use-package, so its still loaded
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package diminish) ;; actual diminishing of modes is executed after init is completely run (see end of file)
   #+END_SRC
** use line if no region (deactive, currently evaluating easy-kill)
   uses a line as region if no active region is selected and a
   command is issued that works on regions
   (not: M-% replace)
   (yes: C-w)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package whole-line-or-region
     :config
     (whole-line-or-region-mode 1))
   #+END_SRC
** mode icons (disabled)
   - no longer used, since spaceline brings its own set of mode icons
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package mode-icons
     :disabled t
     :config
     (mode-icons-mode)
     (setq mode-icons-desaturate-inactive t)
     (setq mode-icons-desaturate-active nil)
     (setq mode-icons-grayscale-transform t))

     ;; (defvar minor-mode-icon-list
     ;;   '((paredit-mode paredit-mode-hook "~/icons/clojure-icon-small.png" png))
     ;;   "define a list of icon replacements for the given minor modes")

     ;; (defun install-minor-mode-icons (rem-minor-mode-icon-list)
     ;;   (let* ((minor-mode-icon (car rem-minor-mode-icon-list))
     ;;          (rem-minor-mode-icon-list-new (cdr rem-minor-mode-icon-list)))
     ;;     (if minor-mode-icon
     ;;         (add-hook (nth 1 minor-mode-icon)
     ;;                   `(lambda ()
     ;;                      (let* ((mode-id (nth 0 ,minor-mode-icon))
     ;;                             (icon-path (nth 2 ,minor-mode-icon))
     ;;                             (icon-type (nth 3 ,minor-mode-icon))
     ;;                             (image-line `(image :type ,icon-type :file ,icon-path :ascent center :margin ( 3 . 0 )))
     ;;                             (minor-mode-element (assoc mode-id minor-mode-alist)))
     ;;                        (if (message "FORMATSTRING" &optional ARGS)inor-mode-element
     ;;                          (setf (cdr minor-mode-element) (list (propertize "dummy" 'display image-line))))))))
     ;;     (if rem-minor-mode-icon-list-new
     ;;         install-minor-mode-icons rem-minor-mode-icon-list-new)))

     ;; (install-minor-mode-icons minor-mode-icon-list)
 #+END_SRC
** fonts with ligatures (realized differently)
   - the following is not functional within (my) emacs => it is not tangled
     #+BEGIN_SRC emacs-lisp :tangle no

       ;; if font with ligatures is selected, define some font compositions
       (when (string= gb/default-font "Fira Code")
         (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
                        (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
                        (36 . ".\\(?:>\\)")
                        (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
                        (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                        (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
                        (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
                        (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                        (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
                        (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                        (48 . ".\\(?:x[a-zA-Z]\\)")
                        (58 . ".\\(?:::\\|[:=]\\)")
                        (59 . ".\\(?:;;\\|;\\)")
                        (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
                        (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                        (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                        (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
                        (91 . ".\\(?:]\\)")
                        (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                        (94 . ".\\(?:=\\)")
                        (119 . ".\\(?:ww\\)")
                        (123 . ".\\(?:-\\)")
                        (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                        (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
                        )
                      ))
           (dolist (char-regexp alist)
             (set-char-table-range composition-function-table (car char-regexp)
                                   `([,(cdr char-regexp) 0 font-shape-gstring])))))
     #+END_SRC
** major mode icons
   - does not work with spaceline (nor powerline)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package xpm)
     (use-package major-mode-icons
       :after ( xpm)
       :config
       (progn
         (setq mode-line-end-spaces
               (quote ((:eval (major-mode-icons/show)))))
         (major-mode-icons-mode 1)))
   #+END_SRC
** helm-navi
   - does not work together with current org-mode and hide-pw
     (opening password file does not start folded, passwords are shown)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package outshine)
   (use-package navi-mode)
   (use-package outorg)
   (use-package helm-navi
     :after ( outshine navi-mode)
     :commands helm-navi helm-navi-headings)
   #+END_SRC
** smex
   - replaced by helm-M-x, a helm interface to M-x
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Enhances M-x to allow easier execution of commands. Provides
     ;; a filterable list of possible commands in the minibuffer
     ;; http://www.emacswiki.org/emacs/Smex
     (use-package smex
       :ensure t
       :disabled t
       :bind (("M-x" . smex))
       :config
       (progn
       (setq smex-save-file (concat user-emacs-directory ".smex-items"))
       (smex-initialize)))
   #+END_SRC
* exwm (emacs window manager)
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point exwm")
#+END_SRC
  - C-c C-q <next key>: results in next key being send to the x-application unmodified
  - infos
    - eclipse usage
      - since eclipse is configured to use emacs key bindings they may collide with exwm and emacs native keybindings.  Thus it makes more
        sense to use eclipse in key mode (TODO: automatically switch to key mode when in eclipse).  However, if in key mode, buffer
        switching via C-x C-b is not available. To switch back to line mode use s-r (which resets exwm for this application).
  - [[https://github.com/ch11ng/exwm/wiki/Configuration-example][example configuration]]
  #+BEGIN_SRC emacs-lisp
  (when gb/use-exwm
    (use-package xelb
      :after (helm-external helm ace-window windmove)
      :ensure xelb)
    (use-package exwm
      :after (xelb)
      :bind (("<XF86MonBrightnessUp>" . gb/brightness-up)
             ("<XF86MonBrightnessDown>" . gb/brightness-down)
             ("<XF86AudioLowerVolume>" . gb/audio-lower-volume)
             ("<XF86AudioRaiseVolume>" . gb/audio-raise-volume)
             ("<XF86AudioMute>" . gb/audio-mute-volume)
             ("<s-f6>" . gb/brightness-up)
             ("<s-f5>" . gb/brightness-down)
             ("<s-f2>" . gb/audio-lower-volume)
             ("<s-f3>" . gb/audio-raise-volume)
             ("<s-f1>" . gb/audio-mute-volume))
      :init (progn
              (defun gb/brightness-up ()
                ""
                (interactive)
                (shell-command "xbacklight -inc 10")
                (let ((brightness (s-trim (shell-command-to-string "xbacklight -get"))))
                  (message (s-concat "brightness up, now: " brightness " %%"))))
              (defun gb/brightness-down ()
                ""
                (interactive)
                (shell-command "xbacklight -dec 10")
                (let ((brightness (s-trim (shell-command-to-string "xbacklight -get"))))
                  (message (s-concat "brightness down, now: " brightness " %%"))))
              (defun gb/audio-lower-volume ()
                ""
                (interactive)
                (shell-command "pactl set-sink-volume 0 -10%")
                (message (s-concat "volume down, now " (gb/get-volume-lr-escaped))))
              (defun gb/get-volume-lr-escaped ()
                ""
                (s-replace "%" "%%" (s-trim (shell-command-to-string  "pactl list sinks | grep -A 9 \"Sink #0\" | grep \"Volume:\" | awk '{ print $5 \" / \" $12 }'"))))
              (defun gb/audio-raise-volume ()
                ""
                (interactive)
                (shell-command "pactl set-sink-volume 0 +10%")
                (message (s-concat "volume up, now " (gb/get-volume-lr-escaped))))
              (defun gb/lock-screen ()
                "lock screen"
                (interactive)
                (shell-command "xset s activate"))
              (defun gb/screensaver-enable ()
                "enable screen saver"
                (interactive)
                (shell-command "xset s default"))
              (defun gb/screensaver-disable ()
                "enable screen saver"
                (interactive)
                (shell-command "xset s noblank"))
              (defun gb/audio-mute-volume ()
                ""
                (interactive)
                (shell-command "pactl set-sink-mute 0 toggle")
                (message (s-concat "now muted: " (s-trim (shell-command-to-string "pactl list sinks | grep -A 9 \"Sink #0\" | grep \"Mute:\" | awk '{ print $2 }'")))))
              (defun gb/hibernate-laptop ()
                "put laptop into hibernation (complete off, store memory onto disc)"
                (interactive)
                (shell-command-to-string "xfce4-power-manager") ;; make sure the power manager is running
                (shell-command-to-string "systemctl hibernate"))
              (defun gb/suspend-laptop ()
                "put laptop into suspension (soft off, still uses power to keep memory up to date)"
                (interactive)
                (shell-command-to-string "xfce4-power-manager") ;; make sure the power manager is running
                (shell-command-to-string "systemctl suspend"))
              (defun gb/reboot--immediately ()
               "immediately execute reboot, without running hooks nor asking questions"
               (shell-command "reboot"))
              (defun gb/reboot ()
                "reboot pc"
                (interactive)
                (when (yes-or-no-p "Reboot PC?")
                  (progn
                    (add-hook 'kill-emacs-hook #'gb/reboot--immediately t)
                    (save-buffers-kill-emacs))))
              (defun gb/shutdown--immediately ()
               "immediately execute shutdown, without running hooks nor asking questions"
               (shell-command "shutdown -h now"))
              (defun gb/shutdown ()
                "reboot pc"
                (interactive)
                (when (yes-or-no-p "Shutdown PC?")
                  (progn
                    (add-hook 'kill-emacs-hook #'gb/shutdown--immediately t)
                    (save-buffers-kill-emacs)))))

      :ensure exwm)
    (use-package exwm-config
      :after ( exwm )
      :config
      (exwm-config-default)

      (if (shell-command-to-string "ps -A | grep VBoxClient")
          (message "OK: VBoxClient seems to be running, thus clipboard sharing is probably active")
        (message "ERROR: VBoxClient is not running! Clipboard sharing is not available"))

      (defun gb/start-if-not-running (filename)
        "start this program if not already running"
        (let* ((program (file-name-base filename))
               (is-executable (file-executable-p filename))
               (is-running (not (string-empty-p (shell-command-to-string (concat "ps -A | grep " program))))))
          (cond ((and is-executable is-running) (message (format "OK: %s already running." program)))
                (is-executable (progn (message (format "OK: starting %s." program))
                                      (start-process-shell-command filename nil)))
                (t (message (format "WARNING: program %s could not be run." filename))))
          ))

      (defun gb/get-second-monitor ()
        "get the second monitor if connected"
        (s-trim (shell-command-to-string "xrandr | grep -v disconnected | grep connected | grep -v primary | awk '{ print $1 }'")))

      (defun gb/get-primary-monitor ()
        "get the second monitor if connected"
        (s-trim (shell-command-to-string "xrandr | grep -v disconnected | grep connected | grep primary | awk '{ print $1 }'")))

      ;; make sure multi monitor support is active
      (when gb/dual-monitor-setup
        (progn
          (let ((second-monitor (gb/get-second-monitor))
                (primary-monitor (gb/get-primary-monitor)))
            (message "Starting multimonitor support for exwm.")
            (require 'exwm-randr)
            (setq exwm-randr-workspace-output-plist `(0 ,primary-monitor 1 ,second-monitor)) ;; 0 "DP-2"
            (add-hook 'exwm-randr-screen-change-hook
                      `(lambda ()
                         (shell-command (s-concat "xrandr --output " ,primary-monitor " --left-of "  ,second-monitor " --auto"))
                         (if (s-equals? ,second-monitor "DP-0")
                             (let* ((xrandrmode (s-trim (shell-command-to-string (s-concat "xrandr -q | grep " ,second-monitor " -A 1 | tail -n 1 | awk '{ print $1; }'")))))
                               (shell-command (s-concat "xrandr --output " ,second-monitor " --mode " xrandrmode))))))
            (exwm-randr-enable))))

      ;; The following example demonstrates how to set a key binding only available
      ;; in line mode. It's simply done by first push the prefix key to
      ;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
      ;; The example shorten 'C-c q' to 'C-q'.
      (push ?\C-q exwm-input-prefix-keys)
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)


      (exwm-input-set-key (kbd "s-<left>") #'windmove-left)
      (exwm-input-set-key (kbd "s-<right>") #'windmove-right)
      (exwm-input-set-key (kbd "s-<up>") #'windmove-up)
      (exwm-input-set-key (kbd "s-<down>") #'windmove-down)

      (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") #'gb/brightness-up)
      (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") #'gb/brightness-down)
      (exwm-input-set-key (kbd "<XF86AudioLowerVolume>") #'gb/audio-lower-volume)
      (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") #'gb/audio-raise-volume)
      (exwm-input-set-key (kbd "<XF86AudioMute>") #'gb/audio-mute-volume)
      (exwm-input-set-key (kbd "<s-f6>") #'gb/brightness-up)
      (exwm-input-set-key (kbd "<s-f5>") #'gb/brightness-down)
      (exwm-input-set-key (kbd "<s-f2>") #'gb/audio-lower-volume)
      (exwm-input-set-key (kbd "<s-f3>") #'gb/audio-raise-volume)
      (exwm-input-set-key (kbd "<s-f1>") #'gb/audio-mute-volume)

      (defun gb/wrap-in-exwm-reset (interactive-function)
        "run exwm reset right before calling the given function"
        (interactive)
        (when (and exwm-class-name
                   (or ;; (string= exwm-class-name "Chromium")
                    (string= (downcase exwm-class-name) "eclipse")))
          (exwm-reset))
        (funcall interactive-function))

      ;; switch buffers
      (exwm-input-set-key (kbd "s-b") (lambda () (interactive) (gb/wrap-in-exwm-reset #'helm-mini)))
      ;; open files
      (exwm-input-set-key (kbd "s-f") (lambda () (interactive) (gb/wrap-in-exwm-reset #'helm-for-files)))
      ;; select window via ace
      (exwm-input-set-key (kbd "s-o") (lambda () (interactive) (gb/wrap-in-exwm-reset #'ace-select-window)))
      ;; helm-M-x
      (exwm-input-set-key (kbd "s-SPC") #'helm-M-x) ;; may have problems jumping off from eclipse

      (defun gb/exwm-distinct-exwm-buffer-names ()
        "list of distinct running exwm buffers/programs"
        (-distinct
         (map-values-apply
          (lambda (name)
            (->> name
                 (buffer-name)
                 (replace-regexp-in-string "<[0-9]*>$" "")
                 (downcase)))
          exwm--id-buffer-alist)))

      (require 'helm-external)
      (defun gb/exwm-program-select (program)
        "select a native (unix) program to execute, select the buffer named as
         the program instead, if such a buffer exists"
        (interactive (list
                      (helm-comp-read
                       "RunProgram: "
                       (helm-external-commands-list-1 'sort)
                       :must-match t
                       :del-input nil
                       :name "External Commands"
                       :history helm-external-command-history)))
        ;; (exwm-reset)
        (if (-contains? (gb/exwm-distinct-exwm-buffer-names) program)
            (exwm-workspace-switch-to-buffer (capitalize program))
          ;; (exwm-reset) ;; make sure that keyboard is no longer captured
          (helm-run-external-command program)))

      ;; start programs
      (exwm-input-set-key (kbd "s-1") #'gb/exwm-program-select) ;; do not wrap, since it already resets exwm

      (setq gb/simulation-keys `(
                                 ;; see http://ergoemacs.org/emacs/keystroke_rep.html for syntax of key definition
                                 ;; movement
                                 ;; read-key-sequence-vector can be used to get key-sequences as used as first element
                                 (,(kbd "C-b") . left)
                                 (,(kbd "M-b") . C-left)
                                 (,(kbd "C-f") . right)
                                 (,(kbd "M-f") . C-right)
                                 (,(kbd "C-p") . up)
                                 (,(kbd "C-n") . down)
                                 (,(kbd "C-a") . home)
                                 (,(kbd "C-e") . end)
                                 (,(kbd "M-v") . prior)
                                 (,(kbd "C-v") . next)
                                 (,(kbd "C-d") . delete)
                                 (,(kbd "M-d") . (S-C-right delete))
                                 (,(kbd "<M-backspace>") . (S-C-left delete))
                                 (,(kbd "C-k") . (S-end delete))
                                 (,(kbd "M->") . (C-end))
                                 (,(kbd "M-<") . (C-home))
                                 ;; cut/paste.
                                 (,(kbd "C-w") . ?\C-x)
                                 (,(kbd "M-w") . ?\C-c)
                                 (,(kbd "C-y") . ?\C-v)
                                 ;; marking
                                 (,(kbd "C-x h") . ?\C-a) ;; will work in emacs 27 first time [?\C-x ?h]
                                 ;; other
                                 (,(kbd "C-g") . escape)
                                 ;; search
                                 (,(kbd "C-s") . ?\C-f)))
      (setq exwm-input-simulation-keys gb/simulation-keys)

      ;; You can hide the mode-line of floating X windows by uncommenting the
      ;; following lines
      (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
      (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

      ;; You can hide the minibuffer and echo area when they're not used, by
      ;; uncommenting the following line
      ;; (setq exwm-workspace-minibuffer-position 'bottom)

      ;; show all exwm buffers in all workspaces (no restriction)
      (setq exwm-workspace-show-all-buffers t)
      ;; automatic moving of x window from inactive workspace by switching buffer
      (setq exwm-layout-show-all-buffers t)

      ;; enable system tray which is displayed in the message area all the way to the right
      (require 'exwm-systemtray)
      (exwm-systemtray-enable)

      ;; somehow the switch of workspace fails if some graphic program (like eclipse or chromium) is running
      ;; this does not fix the problem, though

      (defun gb/exwm-after-switch ()
        "do some adjustments due to exwm switches with char/line mode"
        (progn
          (when (and exwm-class-name
                     (or ;; (string= exwm-class-name "Chromium")
                      (string= (downcase exwm-class-name) "eclipse")))
            (progn
              ;; (setq-local exwm-input-prefix-keys '(?\C-l))
              (message "eclipse specific exwm settings applied.")
              (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))
              (exwm-input-set-local-simulation-keys nil)))
          (when (and exwm-class-name
                     (or (string= (downcase exwm-class-name) "google-chrome")
                         (string= (downcase exwm-class-name) "firefox")
                         (string= (downcase exwm-class-name) "chromium-browser")))
            (progn
              (message "local-sim-keys set for browser")
              (let ((sim-keys (append gb/simulation-keys
                                      `((,(kbd "C-S-s") . C-k)                   ;; search with search engine (C-S-s)
                                        (,(kbd "C-M-s") . f6)                    ;; jump into adresse bar (C-M-s)
                                        ))))
                (exwm-input-set-local-simulation-keys sim-keys))))))

      ;;(add-hook 'buffer-list-update-hook #'gb/exwm-after-switch)
      ;; (remove-hook 'buffer-list-update-hook #'gb/exwm-after-switch)
      (add-hook 'helm-after-action-hook #'gb/exwm-after-switch)
      (add-hook 'helm-quit-hook #'gb/exwm-after-switch)


      ;; start pasystray from within emacs, starting it within xinitrc does not work
      (add-hook 'exwm-init-hook
                (lambda ()
                  (gb/start-if-not-running (s-trim (shell-command-to-string "which pasystray")))
                  ;; (start-process "yabar" nil  "/usr/bin/yabar") ;; see here: https://github.com/geommer/yabar
                  ))

      ;; ensure that eclipse switches to char line mode
      ;; and does not use simulation keys, since i have emacs binding enabled in eclipse
      (add-hook 'exwm-manage-finish-hook #'gb/exwm-after-switch)

      (defadvice switch-to-buffer (after switch-to-buffer-check-exwm-buffer activate)
        "switch to char mode if target buffer is eclipse (or any other buffer that should be in char mode)"
        (when (and exwm-class-name
                   (or ;; (string= exwm-class-name "Chromium")
                    (string= (downcase exwm-class-name) "eclipse")
                    ))
          (progn
            (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))
            (setq exwm-input-set-local-simulation-keys nil)))
        )

      ))


  #+END_SRC
* finish - up
  #+BEGIN_SRC emacs-lisp
  (report-elapsed "enter finish - up")

  (require 'server)
  ;; start a server to allow reuse of this server when opening other files from within the os
  (unless (server-running-p)
    (server-start))
  ;; (maximize-frame)
  (gb/do-after-display-system-init
   (toggle-frame-fullscreen)
   (ido-mode 0)
   (midnight-mode 1))
  (setq gc-cons-threshold 80000)
  (report-elapsed "exit finish - up")
  #+END_SRC

#  LocalWords:  flyspell

