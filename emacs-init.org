#+title: init.el
#+property: ^ nil
#+property: header-args :tangle ~/.emacs.d/init.el :comments both
#
# execute org-babel-tangle to actually export the code into a init.el (directly into the emacs directory)
#   c-c c-v t  (org-babel-tangle)
#
# on first run
#   - an error occurs (error "no executable `epdfinfo' found") when installing pdf-tools
#     just answer the upcoming question whether to compile pdf-tools with 'yes'
#     and wait until buffer *compile pdf-tools* reports compilation finished
#     restart emacs: the error should not come up any more!
#   - on autoinstall, installation may stop after xelb:
#     execute '(kill-emacs)' and restart emacs, after that exwm should
#     should be installed and all further installation should complete
#
# make sure to take a look at the message buffer
#   - entries with 'preinstall' mark packages that are installed up front
#   - entries with 'ok: ... installed' mark checks for external programs that are needed for some packages to work
#
* first
#+begin_src emacs-lisp
  (setq gb/completion-framework 'ivy) ;; 'helm | 'selectrum | 'ivy
  (set-background-color "black")
  (set-foreground-color "white")
  (when (file-exists-p "~/media/gnu-small.png")
    (insert "\n")
    (insert-image (create-image "~/media/gnu-small.png"))
    (insert "\n\n"))
  (setq gb/playing-startup-sound nil)
  (defun gb/play-startup-sound ()
    (interactive)
    (let ((default-output "alsa_output.pci-0000_00_1f.3.analog-stereo"))
      (shell-command-to-string "amixer sset Master on") ;; unmute
      (shell-command-to-string (format "pactl set-default-sink %s" default-output))
      (shell-command-to-string (format "pactl set-sink-volume %s 30%%" default-output))
      (start-process-shell-command "startup" nil  "play ~/sound/it_crowd.mp3")))

  (defun gb/play-startup-sound-when-ctrlkey-down ()
    ""
    (when (and (executable-find "getEventDeviceFor")
               (executable-find "evtest")
               (not gb/playing-startup-sound))
      (let* ((tp-input (shell-command-to-string "getEventDeviceFor 'TouchPad'"))
             ;; play the sound only if control is pressed on startup!
             (tp-play-ok (shell-command-to-string (format "sudo evtest --query %s EV_KEY 274 || echo -n \"ok\"" tp-input)))
             (kb-input (shell-command-to-string "getEventDeviceFor 'kmonad-internal-keyboard'"))
             ;; play the sound only if middle touchpad button is pressed on startup!
             (kb-play-ok (shell-command-to-string (format "sudo evtest --query %s EV_KEY 29 || echo -n \"ok\"" kb-input)))
             (kb-usb-input (shell-command-to-string "getEventDeviceFor 'kmonad-filco-usb'"))
             ;; play the sound only if middle touchpad button is pressed on startup!
             (kb-usb-play-ok (shell-command-to-string (format "sudo evtest --query %s EV_KEY 29 || echo -n \"ok\"" kb-usb-input)))
             (kb-bt-input (shell-command-to-string "getEventDeviceFor 'kmonad-filco-bluetooth'"))
             ;; play the sound only if middle touchpad button is pressed on startup!
             (kb-bt-play-ok (shell-command-to-string (format "sudo evtest --query %s EV_KEY 29 || echo -n \"ok\"" kb-bt-input))))
        (when (and (or (equal "ok" kb-play-ok)
                       (equal "ok" tp-play-ok)
                       (equal "ok" kb-usb-play-ok)
                       (equal "ok" kb-bt-play-ok))
                   (executable-find "pactl")
                   (executable-find "play")
                   (executable-find "amixer"))
          (gb/play-startup-sound)
          (setq gb/playing-startup-sound t)))))

  (gb/play-startup-sound-when-ctrlkey-down)
#+end_src
* elpa-mirror (see https://github.com/redguardtoo/elpa-mirror)
  #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/additionals/")
    (when (file-exists-p "~/.emacs.d/additionals/elpa-mirror.el")
      (require 'elpa-mirror))
    (setq elpamr-default-output-directory "~/repo/myelpa")
    (setq use-elpa-mirror nil)
    (setq elpamr-debug t)
  #+end_src
* use-package
  - enable this for precompilation (still needs work on this init file though)
  #+BEGIN_SRC emacs-lisp
  ;; (eval-when-compile
  ;;   (require 'use-package))
  #+END_SRC
* preset
  - things to setup before anything else happens
  #+BEGIN_SRC emacs-lisp
    (setq gb/log-startup-timing nil) ;; set true for timing messages during startup
    (setq gb/debug-package nil) ;; fails on all packages that could not be loaded but are not mandatory either

    (setq gb/list-of-faces-to-set '()) ;; add-to-list all the customizations wanted, are set on setting up fonts at the end of the initialisation process
    (setq gb/time (float-time))

    (setq gc-cons-threshold 800000000)

    (defun report-elapsed (msg-prefix)
      "record an message time since last call of this function"
      (if gb/log-startup-timing
          (progn
            (setq gb/elapsed-time (- (float-time) gb/time))
            (setq gb/time (float-time))
            (message (format "%s: %f seconds" msg-prefix gb/elapsed-time)))))

    (report-elapsed "preset")
  #+END_SRC
* benchmarking
  - simply call M-x profiler-report after loading
    #+BEGIN_SRC emacs-lisp
      (if gb/log-startup-timing
          (profiler-start 'cpu))
    #+END_SRC
  - provide measure-time macro
    #+begin_src emacs-lisp
      (defmacro measure-time (&rest body)
        "Measure the time it takes to evaluate BODY and return this in ms."
        (let ((time-sym (gensym 'time)))
          `(let (
                 (,time-sym (current-time)))
             ,@body
             (float-time (time-since ,time-sym)))))

      ;; (measure-time (progn (dotimes (i 100) (1+ 1))))

    #+end_src
* info
  - information about this file and usages of certain functionalities
** el-get packages
   - example of how to load packages dynamically via el-get from git sources
   #+BEGIN_SRC emacs-lisp :tangle no
   (el-get-bundle org-brain
                  :url "https://github.com/Kungsgeten/org-brain.git"
                  :features org-brain)
   (if (el-get-package-is-installed 'org-brain)
       (el-get 'sync 'org-brain))
   (req-package org-brain
                :loader :el-get
                :require org dash helm-org-rifle
                :commands org-brain-open org-brain-visualize org-brain-insert-link
                :config
                (progn
                  (setq org-brain-path "~/brain")
                  (if (not (file-exists-p org-brain-path))
                      (make-directory org-brain-path t))
                  (defun helm-org-rifle-brain ()
                    "Rifle files in `org-brain-path'."
                    (interactive)
                    (helm-org-rifle-directories (list org-brain-path)))))
   #+END_SRC
** use-package
*** deferred loading with arbitrary key binding (even key chords are this possible) UNCHECKED!!
    - this code:
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ace-jump-mode
      ;; :defer t ;; valid because of key registration in init
      :init
      (autoload 'ace-jump-mode "ace-jump-mode" nil t)
      (bind-key "c-." 'ace-jump-mode))
    #+END_SRC
    - is equivalent with this code (loading is done when the key is used)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ace-jump-mode
      :bind (("c-." . ace-jump-mode)))
    #+END_SRC
** helm locate
   helm uses /usr/bin/locate to actually provide a list of possible candidates.  the configuration goes into /etc/locate.rc (open within
   /sudo::/etc/locate.rc).
** helm-m-x
*** command history
    - is saved in extended-command-history and saved through the
      package 'session' which stores lots of session information into
      the file .session in the .emacs.d
* enhancements and todos
  list of todos and enhancements to be implmented, checked, verified (some day)
** TODO write major-mode-hydra s
** TODO switch gnus mail sync with google calendar to org-gcal
** TODO lsp-mode: check what packages have to be deactivated in order to not interfere with lsp-mode and company suggestions
** TODO allow duplex/non-duplex configuration of printer / printing (see org header "printer")
** TODO minimap mode results in ligatures being misplaced!
** IMPLEMENT describe each packages' benefit for my configuration
** TODO define something like layers
   e.g. layer for core, editing, navigation, programming ... such that these layers can be easily switched off and on at the top of the init
   file
** IMPLEMENT find keybinding for jumplist, complete jumplist-hook-commands
   - state "implement"  from "todo"       [2015-11-16 mon 12:58]
** IMPLEMENT list modes actually in use and think about optimal key/function binding
   - state "implement"  from "planned"    [2016-11-28 mon 08:08]
*** gnus
*** elfeed
*** paradox
*** org
**** org babel
**** org timers
*** latex
*** clojure
*** java
*** java script
*** docker
** TEST amplify org-mode
   #+BEGIN_SRC emacs-lisp :tangle no
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; org-mode agenda options                                                ;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;don't show tasks as scheduled if they are already shown as a deadline
   (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
   ;;don't give awarning colour to tasks with impending deadlines
   ;;if they are scheduled to be done
   (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
   ;;don't show tasks that are scheduled or have deadlines in the
   ;;normal todo list
   (setq org-agenda-todo-ignore-deadlines (quote all))
   (setq org-agenda-todo-ignore-scheduled (quote all))
   ;;sort tasks in order of when they are due and then by priority
   (setq org-agenda-sorting-strategy
         (quote
          ((agenda deadline-up priority-down)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
   #+END_SRC
** PLANNED explore org-contacts as bbdb replacement (look [[https://julien.danjou.info/projects/emacs-packages#org-contacts][here]] and [[http://kitchingroup.cheme.cmu.edu/blog/2016/12/22/context-specific-org-mode-speed-keys/?utm_source=feedburner&utm_medium=twitter&utm_campaign=feed:+thekitchinresearchgroup+(the+kitchin+research+group)][here]])
** PLANNED add additional modes to store linenumbers when capturing
   [[file:~/.emacs.d/init.el::org-file-lineno-store-link][file:~/.emacs.d/init.el::org-file-lineno-store-link]]
** PLANNED rebind C-x C-k keymacros to some other binding (since C-x C-k is used for killing buffers and windows)
** PLANNED define additional capture templates
   [[file:~/.emacs.d/init.el::org-capture-templates][file:~/.emacs.d/init.el::org-capture-templates]]
** PLANNED adjust selfinsertion commands to put the charater where expected (depending on the mode)
   - see http://mbork.pl/2015-10-31_Smart_comma_and_other_punctuation
** PLANNED define hydra for dired
** PLANNED define hydra for pdf-tools
** DONE install xcape into the linux installtions to allow for using space as control where possible
   - State "DONE"       from "PLANNED"    [2018-07-07 Sat 21:56]
   - configuring needs to be streamlined to allow space-down key-down key-up space-up to work as control
   - all other uses (especially space-down key-down space-up key-up should function as space then key) should work as with normal space mapping
** DONE check magit ediffing with exwm, seems to have trouble with control window!
   - State "DONE"       from "TODO"       [2017-11-16 Thu 06:52]
** DONE synchronise linux and mac os x init
   - State "DONE"       from "IMPLEMENT"  [2017-10-04 Wed 21:47]
   - state "implement"  from "todo"       [2017-01-27 fr 20:02]
*** todo some org-babel packages are not resolved during bootstrap of init.el (sed, shell, groovy)
*** todo loadpath dependencies that should be resolved
    - ob-clojure
    - javad
    - gnus-calendar
    - ox-confluence (obsolete)
    - org-jekyl (obsolete)
*** done require the emacs package manager, add available repositories and intialize packet manager
    make sure that the initial (minimal set) packages needed are all loaded
    - dash
    - maxframe
    - bind-key
    - key-chord
    - benchmark (currently via loadpath)
** DONE undo-tree workaround: [2017-02-25 Sat] currently org src block fontification is disabled if undo tree is called, since undo tree exits on up/down in the tree
** DONE disable smart region '/' in gnus (since / is used to narrow selection and is not used to surround selected text in this context)
** DONE commit message should not store any cursor position info but should always start at the beginning of the buffer
   - session does probably store this position even though COMMIT_EDITMSG is explicitly excluded from this behaviour
   - look at M-x customize-group session-name  session-name-disable-regexp
** DONE todo define keybindings depending on keyboard layout => e.g. key-chords won't make sense in us-keyboard layout
   - State "DONE"       from              [2017-06-26 Mon 16:45]
** DONE pixel wise scrolling
   - look at sublimity defvar 'sublimity--post-vscroll-functions' which is called for scrolling with the amount of lines to actually scroll
     (negative for up). this could be used to actually call pixelwise scrolling on the last line of the scroll action which would make the
     scrolling much more smooth.
** DONE selected workaround: [2017-02-22 Wed] reactivate package selected, currently running in an error, thus expand/contract region does not work anymore
** DONE extend check prerequisites to check multiple programs to exist
** DONE copy windows setup into separate region
   - State "DONE"       from "IMPLEMENT"  [2017-02-18 Sa 06:37]
   - State "IMPLEMENT"  from "TODO"       [2017-02-14 Di 15:57]
** DONE check gnus with extended setup
   - State "DONE"       from "TODO"       [2016-12-23 Fr 12:04]
** DONE when in multicursor, hungry delete should fall back to normal delete
   - State "DONE"       from "TODO"       [2016-12-23 Fr 11:47]
   - is there a mc/keymap? there C-d and <BACKSPACE> could be mapped to different functions
** DONE inserting appointments into org-agenda should make it possible to decide into which calendar this should go
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:49]
** DONE make sure that proportional font is not bold!
   - State "DONE"       from "TODO"       [2016-11-29 Di 21:30]
** DONE remove bind-key with req-package :bind entries, since these bindings will result in loading the package (if not present yet)!
   - State "DONE"       from "IMPLEMENT"  [2016-11-28 Mon 08:07]
   - State "IMPLEMENT"  from "TODO"       [2016-11-06 So 18:12]
** DONE plantuml-mode and puml-mode are both installed, only one should reside
   - State "DONE"       from "TODO"       [2016-11-28 Mon 08:06]
** DONE put this file into version control
   - State "DONE"       from "TODO"       [2016-11-06 So 18:20]
** OBSOLETE elfeed: filter news depending on title/feed/url etc.
   - state "test"       from "todo"       [2016-04-08 fri 15:55]
** OBSOLETE todo accepting invitations go into agenda, syncing google calendar goes into gcal
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:45]
   it seems that accepted invitations (accepted within emacs from mail) does not correctly sync with google calendar
** OBSOLETE todo move diminish at the end of file to the respective packages
   - State "OBSOLETE"   from              [2017-06-26 Mon 16:44]
* initial unsetting of global keys
  - these keys are either used (remapped) in other packages / own code
  #+BEGIN_SRC emacs-lisp
  (global-unset-key "\C-z")     ;; (now mapped to prefix -- dash)
  (global-unset-key "\C-x\C-k") ;; keyboard makros prefix (now mapped to kill buffer)
  (global-unset-key "\M-%")     ;; replaced by visual-regexp ...
  ;; unbind super key bindings with the given keys
  (dolist (key '(& \, \^ \` \| \~ \?))
    (global-unset-key (kbd (concat "s-" (symbol-name key))))
    (global-unset-key (kbd (concat "s-" (upcase (symbol-name key))))))
  ;; unbind super key bindings with letters (lower and upper case variant)
  (dotimes (i 26)
    (let ((letter (byte-to-string (+ 65 i))))
      (global-unset-key (kbd (concat "s-" letter)))
      (global-unset-key (kbd (concat "s-" (downcase letter))))))
  #+END_SRC
* check account configuration files
  #+BEGIN_SRC emacs-lisp
    (setq agenda-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/agenda-accounts.el")))
    (setq calendar-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/calendar-accounts.el")))
    (setq mail-accounts-exists (file-exists-p (concat user-emacs-directory "accounts/mail-accounts.el")))
    (setq private-exists (file-exists-p (concat user-emacs-directory "accounts/private.el")))

    (when private-exists
      (use-package private
        :load-path "~/.emacs.d/accounts/"))

  #+END_SRC
* initial setting of vars
  #+BEGIN_SRC emacs-lisp
    ;; must be set before loading use-package in order to work
    (setq use-package-enable-imenu-support t) ;; enable locating package loaded by use-package within init.el
    (setq running-nixos nil)
    (setq  frame-inhibit-implied-resize t) ;; inhibit font (or other) based resize of frames
    (put 'list-timers 'disabled nil)
    (put 'list-threads 'disabled nil)
  #+END_SRC
* initial function setup
  #+BEGIN_SRC emacs-lisp
  (defun slurp (file-name)
    "Return file content."
    (with-temp-buffer
      (insert-file-contents file-name)
      (buffer-string)))

  (defun jde-read-properties-file (file-name)
    "read a java properties file and provide a map with key value pairs.
    property files are transformed such that multiline properties are heeded,
    double colon is heeded and spaces after the key and before the value are
    discarded."
    (let* ((file-string (slurp file-name))
           (file-string-nomultiline (replace-regexp-in-string "[^\\\\]\\(\\\\\n *\\)" "" file-string nil nil 1)) ;; incomplete! 1
           (file-string-nobackslash-escaping (replace-regexp-in-string "\\\\\\\\" "\\\\" file-string-nomultiline))
           (file-string-nodoublecolon-and-spaces (replace-regexp-in-string " *\\(:\\|=\\) *" "=" file-string-nobackslash-escaping))
           (prop-matches (re-seq "^[^#!=:][^=:]*\\(=\\|:\\)[^=:\n]+$" file-string-nodoublecolon-and-spaces))
           (hash-map (make-hash-table :test 'equal)))
      (--map
       (let* ((splitted-prop (split-string it "="))
              (key (nth 0 splitted-prop))
              (value (nth 1 splitted-prop)))
         (puthash key value hash-map))
       prop-matches)
      hash-map))
  ;; 1 what should be tested if an unbalanced backslash is present at the end of the line.
  ;;   currently the test checks whether there is a single backslash at the end of the line!

  (defun is-ms-windows-p ()
    "check whether this system is microsoft windows"
    (if (string-match "windows" (symbol-name system-type))
        t
      nil))

  (defun is-linux-p ()
    "check whether this system is a linux"
    (if (string-match "linux" (symbol-name system-type))
        t
      nil))

  (defun is-macos-p ()
    "check whether this system is mac os"
    (if (string-match "darwin" (symbol-name system-type))
        t
      nil))

  (defun is-_nix-p ()
    "check whether this is a *nix derivative (either linux or macos)"
    (or (is-linux-p) (is-macos-p)))
  #+END_SRC
* proxy setup (if present)
  #+BEGIN_SRC emacs-lisp
  (if (file-exists-p (concat user-emacs-directory "accounts/proxy-account.el"))
      (load-file (concat user-emacs-directory "accounts/proxy-account.el")))
  #+END_SRC
* package setup
  #+BEGIN_SRC emacs-lisp
    (report-elapsed "enter package setup")
    (require 'package)

    ;; package access either through secure https, or insecure http
    (setq secure-package-access t)


    (when gb/debug-package
      (setq ;; add verbosity level to use package
       ;; use-package-verbose t
       ;; make sure that use-package does minimal reporting to the message buffer
       use-package-expand-minimally t))

    (if use-elpa-mirror
        (setq package-archives
              '(("myelpa" . "https://raw.githubusercontent.com/gunther-bachmann/myelpa/master/")))        ;; (setq package-archives '(("myelpa" . "~/repo/myelpa/")))
      (progn
        (if secure-package-access
            (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                                     ("myelpa" . "https://raw.githubusercontent.com/gunther-bachmann/myelpa/master/")
                                     ("melpa-stable" . "https://stable.melpa.org/packages/")
                                     ("org" . "https://orgmode.org/elpa/")
                                     ("melpa" . "https://melpa.org/packages/")
                                     ))
          (message "INSECURE PACKAGE ACCESS, BEWARE!")
          (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                                   ("myelpa" . "https://raw.githubusercontent.com/gunther-bachmann/myelpa/master/")
                                   ("melpa-stable" . "http://stable.melpa.org/packages/")
                                   ("org" . "http://orgmode.org/elpa/")
                                   ("melpa" . "http://melpa.org/packages/"))))

        (setq package-archive-priorities
              '(("myelpa" . 0)  ;; local is of highest priority
                ("melpa-stable" . 20)  ;; stable is preferred
                ("melpa" . 10)
                ;; ("gnu" . 0)
                ))))

    (setq package-menu-async (is-_nix-p)) ;; defaulting operations to be async (is problematic on windows systems)

    (when (< emacs-major-version 27)
      (package-initialize)) ;; cannot use t as parameter since initialization is necessary for init file to work

    (defun require-package (package)
      "refresh package archives, check package presence and install if it's not installed"
      (if (null (require package nil t))
          (progn
            (let* ((ARCHIVES (if (null package-archive-contents)
                                 (progn (package-refresh-contents)
                                        package-archive-contents)
                               package-archive-contents))
                   (AVAIL (assoc package ARCHIVES)))
              (if AVAIL
                  (package-install package)))
            (require package))))

    (setq package-to-install-initially
          '( dash
             ht
             maxframe
             bind-key
             ;; key-chord
             validate
             use-package
             seq
             ;; see here https://github.com/jabranham/system-packages
             ;; allows for system manager actions (detecting the system manager)
             system-packages
             ;; see here  https://github.com/jwiegley/use-package
             ;; makes sure that a system program is installed
             use-package-ensure-system-package
             s))

    (use-package benchmark-init
      :ensure t
      :demand t
      :config
      ;; To disable collection of benchmark data after init is done.
      (add-hook 'after-init-hook 'benchmark-init/deactivate))

    ;; add mac specific packages
    (when (is-macos-p)
      (add-to-list 'package-to-install-initially 'exec-path-from-shell))

    (dolist (package package-to-install-initially)
      (progn
        (message (concat "Preinstall/require " (symbol-name package)))
        (require-package package)))

    ;; TODO: recheck now and then. error is present in req-package version 1.2
    ;; initialize unbound req-package variable (otherwise an error happens during startup)
    ;;(if (not (boundp 'req-package-paths))
    ;;    (setq req-package-paths (ht)))

    (report-elapsed "exit package setup")
  #+END_SRC
** paradox (package list alternative)
   #+BEGIN_SRC emacs-lisp 
     (use-package paradox
       :after (hydra)
       :commands gb/paradox-list-packages
       :bind (:map paradox-menu-mode-map ("<f1>" . hydra-paradox-list-packages/body))
       :init
       (progn
         (report-elapsed ":init-enter paradox")
         (defun gb/paradox-list-packages ()
             ""
             (interactive)
             (when current-prefix-arg
               (setq package-archive-priorities
                     '(("myelpa" . 5)        ;; local is of highest priority
                       ("melpa-stable" . 20) ;; stable is preferred
                       ("melpa" . 10))))
             (paradox-list-packages nil)
             (when current-prefix-arg
               (message "don't forget to execute M-x gb/update-myelpa-packages")))
         (defun gb/update-myelpa-packages ()
           ""
           (interactive)
           (elpamr-create-mirror-for-installed)
           (magit-status "~/repo/myelpa"))
         ;; (defun gb/ensure-github-token ()
         ;;   "make sure to load github token if it is empty"
         ;;   (if (not paradox-github-token)
         ;;       (let* ((github-token-file "~/.github-token.properties.gpg"))
         ;;         (if (file-exists-p github-token-file)
         ;;             (let* ((auth-map (jde-read-properties-file "~/.github-token.properties.gpg")))
         ;;               (setq paradox-github-token (gethash "github-paradox-token" auth-map)))
         ;;           (message "WARNING: github token file not found. paradox-list-packages will have to work without github integration.")))))
         ;; (advice-add 'paradox-list-packages :before #'(lambda (orig-func &rest args) (gb/ensure-github-token)))
         )

       :config
       (report-elapsed ":config-enter paradox")

       ;; description is pastell sand like color
       (custom-set-faces '(paradox-description-face ((t (:foreground "#e0d0a0")))))
       (progn
         (setq paradox-automatically-star nil)
         (setq paradox-column-width-package 30)
         (setq paradox-column-width-version 17)
         (when (package-installed-p 'hydra)
           (defhydra hydra-paradox-list-packages ()
             "
          [_v_] view homepage           [_x_] execute commands
          [_l_] show latest commits     [_i_] install
           ^ ^                          [_d_] delete
           ^ ^                          [_U_] update all
       %s(hydra-combine-functions-w-key-bindings
         '((\"    view homepage      \" . paradox-menu-visit-homepage)
           (\"    show latest commit \" . paradox-menu-view-commit-list)
           (\"    execute commands   \" . paradox-menu-execute)
           (\"    install            \" . package-menu-mark-install)
           (\"    delete             \" . package-menu-mark-delete)
           (\"    mark upgrades      \" . package-menu-mark-upgrades)))
       "
             ("v" paradox-menu-visit-homepage)
             ("l" paradox-menu-view-commit-list)
             ("x" paradox-menu-execute :exit t)
             ("i" package-menu-mark-install )
             ("d" package-menu-mark-delete)
             ("U" package-menu-mark-upgrades)
             ("q" (message "Abort") :exit t))
           ))
       (report-elapsed ":config-exit paradox")
       )
   #+END_SRC
** use package hydra (use-package extension)
   #+begin_src emacs-lisp
     (use-package use-package-hydra
       :ensure t)
   #+end_src
** use package chords (use-package extension), disabled
   #+begin_src emacs-lisp :tangle no
     (use-package use-package-chords
       :ensure t)
   #+end_src
* play startup sound (check again 1)
  #+begin_src emacs-lisp
    ;; if not playing test again and play 1
    (gb/play-startup-sound-when-ctrlkey-down)
  #+end_src
* workarounds for broken packages
  #+BEGIN_SRC emacs-lisp
  ;; since perspective is using make-variable-frame-local and this function/macro is removed in emacs 26.x
  ;; (when (not (fboundp 'make-variable-frame-local))
  ;;   (defun make-variable-frame-local (variable) variable))
  #+END_SRC
* ui initialisation
** show menu bar (only in case of macos)
   - part of early-init.el
   #+BEGIN_SRC emacs-lisp :tangle no
     (if (is-macos-p)
         (menu-bar-mode 1)
       (menu-bar-mode -1))
   #+END_SRC
** remove scroll bars
   - part of early-init.el
   #+BEGIN_SRC emacs-lisp :tangle no
   (when (fboundp 'scroll-bar-mode)
     (scroll-bar-mode -1))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp
     ;; use echo error for tool tip output
     (tooltip-mode -1)
     (setq tooltip-use-echo-area t)

     (custom-set-variables
      ;; '(canlock-password "0e8b34f24c62bdf6cc5585ec93c62be865aee099")
      '(custom-safe-themes
        '("06f0b439b62164c6f8f84fdda32b62fb50b6d00e8b01c2208e55543a6337433a" "84d2f9eeb3f82d619ca4bfffe5f157282f4779732f48a5ac1484d94d5ff5b279" "4848f52f443b88525a4e2fe4f620a20c40fad90a66a953613be90556b9eb7880" "db790b6031dbc390c8b9318b077f5825302dad9d82925f4c70eaddd22825aafa" "141bdb2503f744acaa2bd8defb015f3c8e9e581ff40ec9ae4f3a27917256edaa" "516ef72a7861d71b39bdd8ae3d2c19628abb916a1456ea93a400cc222f87442a" "05b3ea2f5a8d1913eda3a209bb4bd0091c2aa15e4de64e0580f45d2534428568" "e93f05b3616b9e19a79c3ebd107252684bc88ecb77798617e72443b70aae86d5" "c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223" "a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e" "26614652a4b3515b4bbbb9828d71e206cc249b67c9142c06239ed3418eff95e2" "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default))
      ;; '(tool-bar-mode nil) ;; part of early-init.el
      )

   #+END_SRC
** add theme
   - changed the value for the background from #1d1f21 -> #141618 in file color-theme-sanityinc-tomorrow.el
   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-sanityinc-tomorrow
       :ensure t
       :config
       (progn
         (setq gb/theme-mode 'night)
         (color-theme-sanityinc-tomorrow gb/theme-mode)
         ;; (toggle-frame-fullscreen)
         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (--each '((link-face ((t (:foreground "#81a2be" :underline (:style line :color "#41526e")))))
                         (link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
                 (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))
   #+END_SRC
* splash and initial buffer config
  #+BEGIN_SRC emacs-lisp
    ;; set scratch window content
    (defun gb/system-info () ""
    (let* ((nix-flake '(        "          ::::.    ':::::     ::::'\n"
                                "          ':::::    ':::::.  ::::'\n"
                                "            :::::     '::::.:::::\n"
                                "      .......:::::..... ::::::::\n"
                                "     ::::::::::::::::::. ::::::    ::::.\n"
                                "    ::::::::::::::::::::: :::::.  .::::'\n"
                                "           .....           ::::' :::::'\n"
                                "          :::::            '::' :::::'\n"
                                " ........:::::               ' :::::::::::.\n"
                                ":::::::::::::                 :::::::::::::\n"
                                " ::::::::::: ..              :::::\n"
                                "     .::::: .:::            :::::\n"
                                "    .:::::  :::::          '''''    .....\n"
                                "    :::::   ':::::.  ......:::::::::::::'\n"
                                "     :::     ::::::. ':::::::::::::::::'\n"
                                "            .:::::::: '::::::::::\n"
                                "           .::::''::::.     '::::.\n"
                                "          .::::'   ::::.     '::::.\n"
                                "         .::::      ::::      '::::.\n"))
           (mixto-nix (s-split "\n" (concat (s-trim (shell-command-to-string "neofetch --stdout")) (s-repeat (length nix-flake) "\n"))))
           (max-line-len (-max (-map 'length mixto-nix)))
           (max-line-spaces (s-repeat max-line-len " "))
           (mixto-nix-padded (--map (s-left max-line-len (s-concat it max-line-spaces)) mixto-nix))

           (comments (-repeat (length nix-flake) ";; "))
           (mixed (-interleave comments mixto-nix-padded nix-flake))
           (pairs (-partition 3 mixed))
           (result (--map (s-join "" it) pairs))
           (nix-total (s-join "" result))
           )
           nix-total
         ))
    (let* ((total-ram (if (is-macos-p)
                          (/ (string-to-int (shell-command-to-string "sysctl hw.memsize | sed 's/.*:\s*//'")) (* 1024 1024 1024) )
                        (/ (nth 0 (memory-info)) (* 1024.0 1024))))
           (free-ram (if (is-macos-p) 0 (/ (nth 1 (memory-info)) (* 1024.0 1024))))
           (total-ram-str (concat (format "%.1f" total-ram) "GB" ))
           (free-ram-str (if (= 0 free-ram) "LOTS OF" (concat (format "%.1f" free-ram) "GB" )))
           (len-avail-for-memory (+ (length emacs-version) 1))
           (len-needed-for-memory (+ (length free-ram-str) (length total-ram-str)))
           (nix-total (gb/system-info))
           )

      (setq initial-scratch-message
            (propertize (concat ";; ***** FREE SOFTWARE FOUNDATION  EMACS "
                                emacs-version
                                " *****\n;;   "
                                total-ram-str
                                " RAM SYSTEM"
                                (make-string (max 2 (- len-avail-for-memory len-needed-for-memory)) ? )
                                free-ram-str
                                " EMACS LISP BYTES FREE\n;; READY\n"
                                ;; ";;\n" nix-total
                                )
                        ;; properties do not work here, since they are overwritten/not used
                        )))

    ;; make sure no *Messages* buffer is open on startup
    (add-hook 'window-setup-hook 'delete-other-windows)

    ;; Go strait to scratch buffer on startup
    (setq inhibit-startup-message t)
  #+END_SRC
* own utility functions
** misc
   #+BEGIN_SRC emacs-lisp
     (defmacro with-ignored-messages (&rest body)
       "ignore all messages during execution of body"
       `(progn
          (setq inhibit-message t)
          (unwind-protect
              (progn ,@body)
            (setq inhibit-message nil))))

     (defun gb/disable-all-minor-modes ()
       (interactive)
       (mapc
        (lambda (mode-symbol)
          (when (functionp mode-symbol)
            ;; some symbols are functions which aren't normal mode functions
            (ignore-errors
              (funcall mode-symbol -1))))
        minor-mode-list))

     (setq async-shell-command-display-buffer nil) ;; make sure that the async command does not open a result buffer

     (defun available-keys ()
       "return a list of ids for which the private key is known"
       (remove-if 'string-empty-p (s-split "\n" (shell-command-to-string "gpg -Kq 2> /dev/null | grep -e \"^uid\" | awk '{ print $5; }'"))))

     (defun gb/cache-gpg (prompt)
       "cache gpg password for the standard key or the selected key if the universal argument was provided"
       (interactive "P")
       (if prompt
           (progn
             (let ((keyId (completing-read "email: " (--map (string-trim it "<" ">") (available-keys)))))
               (gb/cache-gpg-key keyId)))
         (gb/cache-gpg-key)))

     (defun gb/cache-gpg-key (&optional keyId)
       ""
       (if keyId
           (async-shell-command (concat "echo \"ok\" | gpg -s -u \"" keyId "\" &> /dev/null" nil nil))
         (async-shell-command "echo \"ok\" | gpg -s &> /dev/null" nil nil)))

     (defun re-seq (regexp string &optional matchpos)
       "Get a list of all regexp matches in a string, use matchpos as group index if groups are used!"
       (save-match-data
         (let ((pos-to-match (or matchpos 0))
               (pos 0)
               matches)
           (while (string-match regexp string pos)
             (push (match-string pos-to-match string) matches)
             (setq pos (match-end 0)))
           matches)))
     (rx-to-string `(: bos "prefix"))
     (ert-deftest re-seq-test ()
       "test re-seq (only)"
       (should (let* ((result (re-seq  "\\([0-9]+\\)" "some31and4other")))
                 (and (member "4" result)
                      (member "31" result)
                      (= 2 (length result)))))
       (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother")))
                 (and (member "31and" result)
                      (= 1 (length result)))))
       (should (let* ((result (re-seq  "\\([0-9]+\\)and" "some31and4aother" 1)))
                 (and (member "31" result)
                      (= 1 (length result))))))

     (defun file-name-from-current-dir (file-name)
       "get given file in the directory of the file currently active"
       (concat (file-name-directory (file-truename (or (concat  "./" file-name) (buffer-file-name (current-buffer))))) file-name))


     (defun get-buffer-file-matching-extension (extension-regex)
       "get all buffers that are associated with a file matching the given extension"
       (--filter (string-match extension-regex (or (file-name-extension it) ""))
                 (remove-if 'null (mapcar 'buffer-file-name (buffer-list)))))

     (defun get-visible-buffer-file-matching-extension (extension-regex)
       "get all buffers visible that are associated with a file matching the given extension"
       (--filter (string-match extension-regex (or (file-name-extension it) ""))
                 (remove-if 'null  (mapcar 'buffer-file-name (mapcar 'window-buffer (window-list))))))

     (defun spit (contents file-name)
       "Write the given contents into the given file"
       (with-temp-buffer
         (insert contents)
         (write-file file-name)))


   #+END_SRC
** transparency
   #+BEGIN_SRC emacs-lisp
   (defun disable-transparency ()
     "make emacs solid again"
     (interactive)
     (setq frame-transparency-value 100)
     (set-frame-parameter (selected-frame) 'alpha '(100 100)))

   (defun increase-transparency ()
     "increase current frame transparency"
     (interactive)
     (setq frame-transparency-value (max 35 (- frame-transparency-value 7)))
     (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

   (defun decrease-transparency ()
     "decrease current frame transparency"
     (interactive)
     (setq frame-transparency-value (min 100 (+ frame-transparency-value 7)))
     (set-frame-parameter (selected-frame) 'alpha `(,frame-transparency-value ,frame-transparency-value)))

   (setq frame-transparency-value 100)
   (add-to-list 'default-frame-alist '(alpha 90 90))
   #+END_SRC
** editing
*** space to control (with the help of xcape)
    #+begin_src sh :tangle no
    #!/usr/bin/env bash
    XCAPEPID=$(pgrep xcape)
    if [[ $XCAPEPID =~ ^[0-9]+$ ]]; then
      echo "Killing existing xcape process with id=$XCAPEPID"
      xmodmap -e "keycode  65 = space NoSymbol space"
      kill $XCAPEPID
    fi
    if [ "$1" != "-k" ]; then
      xmodmap -e "keycode 65 = Hyper_L"
      xmodmap -e "remove mod4 = Hyper_L"
      xmodmap -e "add Control = Hyper_L"
      xmodmap -e "keycode any = space"
      xcape -e "Hyper_L=space" &
      echo "Installed space to control mapping"
    fi
    #+end_src
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun gb/-kmonad-running-pid (keyboard)
        "kmonad is running the given keyboard configuration file"
        (s-trim (shell-command-to-string (s-concat "pgrep -a kmonad | grep " keyboard " | awk '{print $1 }'"))))

      (defvar kmonad-filco-device-name "FILCO Bluetooth Keyboard" "device name for filco keyboard")
      (setq kmonad-event-input-connected nil)
      (defvar kmonad-executable "kmonad-0.3.0-linux" "executable for kmonad keyboard driver")
      (defvar kmonad-config-location "~/.kmonad" "folder for configuration file for kmonad keyboard driver")
      (defun gb/-kmonad-start (keyboard)
        "start kmonad with filco configuration (stopping any instance already running)"
        (let ((pid (gb/-kmonad-running-pid keyboard)))
          (unless (string-empty-p pid)
            (gb/-kill-pid pid)
            (sleep-for 0 500) ;; wait for the kill to settle
            (message (format "killed running kmonad with pid %s" pid)))
          (async-shell-command (s-concat kmonad-executable " " kmonad-config-location "/" keyboard ".kbd"))))

      (setq async-shell-command-buffer 'rename-buffer)
      ;; TODO: make sure async buffer is put into the background

      (defun gb/-get-event-device (full-device-name)
       "provide a string of the event device (or nil if not found)"
       (let* ((input-device (s-trim (shell-command-to-string (s-concat "cat /proc/bus/input/devices | grep -B 1 -A 10 'Name=\"" full-device-name ".*\"' | grep \"H: Handlers\" | awk '{ print$5; }'" )))))
         (unless (string-empty-p input-device)
           (s-concat "/dev/input/" input-device))))

      (defun gb/-kmonad-generate-config-from-template (template device-name config-name)
        (shell-command-to-string (s-concat "cat " kmonad-config-location "/" template ".kbd | sed \"s|DEV_INPUT_DEVICE|" device-name "|g\" > " kmonad-config-location "/" config-name ".kbd")))

      (defun gb/-kill-pid (pid)
        "kill process given by PID string"
        (shell-command (s-concat "kill " pid)))

      ;; (defun gb/-reconnect-filco-on-change ()
      ;;   "(re)connect (if event input changed)"
      ;;   (let ((input-device (gb/-get-event-device kmonad-filco-device-name)))
      ;;     (when (and input-device (not (string= input-device kmonad-event-input-connected)))
      ;;       (gb/kmonad-start-filco)
      ;;       (message "reconnected filco"))))

      (defun gb/filco-udev-event (action)
        (message (format "filco-udev-event, action: %s" action))
        (let ((pid (gb/-kmonad-running-pid "filco"))
              (input-device (gb/-get-event-device kmonad-filco-device-name)))
          (unless (string-empty-p pid)
            (gb/-kill-pid pid)
            (sleep-for 0 500) ;; wait for the kill to settle
            (message (format "killed running kmonad with pid %s" pid)))
          (when input-device
            ; (gb/-kmonad-generate-config-from-template "template" input-device "filco")
            (gb/-kmonad-start "filco")
            (setq kmonad-event-input-connected input-device)
            (message (format "started kmonad on %s" input-device)))))

      (defun gb/kmonad-start-filco ()
        "start bluetooth filco kmonad definition"
        (interactive)
        (gb/filco-udev-event "UNKNOWN"))
    #+END_SRC
*** comment toggle
    #+BEGIN_SRC emacs-lisp
    (defun toggle-comment-on-line ()
      "comment or uncomment current line"
      (interactive)
      (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
    #+END_SRC
*** dos/windows-eol
    #+BEGIN_SRC emacs-lisp
    (defun gb/remove-dos-eol ()
      "Do not show ^M in files containing mixed UNIX and DOS line endings.
              This is especially useful when viewing diffs in magit!"
      (interactive)
      (setq buffer-display-table (make-display-table))
      (aset buffer-display-table ?\^M []))
    #+END_SRC
*** query for a word
    #+BEGIN_SRC emacs-lisp
    ;; aktivate through M-s M-w
    (defun gb/eww-search (orig-fun &rest args)
      "query for string if no active region is present"
      (if (region-active-p)
          (apply orig-fun args)
        (eww (read-string "Query: "))))

    (advice-add 'eww-search-words :around #'gb/eww-search)
    #+END_SRC
*** buffer utils
    #+BEGIN_SRC emacs-lisp
    (defun gb/buffer-contains-string(str)
      "does the current buffer contain the given string?"
      (save-excursion
        (goto-char (point-min))
        (let ((search-result (re-search-forward str nil t)))
          (if search-result (point) nil))))
    #+END_SRC
** scrolling
   #+BEGIN_SRC emacs-lisp
     (defun scroll-up-line-7 ()
       (interactive)
       (scroll-up-line 7))
     (defun scroll-down-line-7 ()
       (interactive)
       (scroll-down-line 7))

     ;; scroll and move cursor
     (defun scroll-up-line-and-move-cursor ()
       (interactive)
       (scroll-up 1)
       (next-line))

     (defun scroll-down-line-and-move-cursor ()
       (interactive)
       (scroll-down 1)
       (previous-line))

     (defun scroll-up-line-and-move-cursor-7 ()
       (interactive)
       (scroll-up-line 7)
       (next-line 7))

     (defun scroll-down-line-and-move-cursor-7 ()
       (interactive)
       (scroll-down-line 7)
       (previous-line 7))
   #+END_SRC
** hydra utils
   #+BEGIN_SRC emacs-lisp
   (defun keys-for-function (fun-symbol)
     "find a key binding for the given function
     always returns a string (can be empty)"
     ;; (or (car (car (car (--filter (eq (car (cdr it)) fun-symbol) personal-keybindings)))) "")
     (let ((result (substitute-command-keys (concat "\\[" (symbol-name fun-symbol) "]"))))  ;;\] closing bracket in comment to satisfy font locking
       (if (equal (substring result 0 (min (length result) 3)) "M-x")
           ""
         result)))

   (defun hydra-combine-functions-w-key-bindings (pairs)
     "return a string that can be put into hydra menu
     pairs must be a list of tuple of the form ( string . function )
     if a personal keybinding exists the string is concatenated with the
     keybinding of the respective function. if no keybining exists that
     pair is ignored for the rest of the function. all pairs found relevant
     are combined with line breaks in between.

     example call: (hydra-combine-functions-w-key-bindings
                      '(( \"some \" . function )
                        ( \"other\" . mc/mark-previous-like-this )))"
     (--reduce
      (if (eq it nil) "" (format "%s
     %s" acc it))
      (-non-nil
       (--map
        (let ((kb (keys-for-function (cdr it))))
          (if (string-empty-p kb) nil (concat (car it) " <" kb ">")))
        pairs))))
   #+END_SRC
** org utils
   #+BEGIN_SRC emacs-lisp
   (defun gb/execute-startup-block ()
     "execute within this org file the source code block that's named 'startup'"
     (interactive)
     (org-babel-goto-named-src-block "startup")
     (org-babel-execute-src-block))
   #+END_SRC
** ui
   #+BEGIN_SRC emacs-lisp
     (setq gb/posframe-offset 0)
     (defun gb/posframe-poshandler-frame-center (info)
       "Posframe's position handler.

          Get a position which let posframe stay onto its
          parent-frame's center.  The structure of INFO can
          be found in docstring of `posframe-show'."
       (cons (+ gb/posframe-offset (/ (- (plist-get info :parent-frame-width)
                                         (plist-get info :posframe-width))
                                      2))
             (/ (- (plist-get info :parent-frame-height)
                   (plist-get info :posframe-height))
                2)))

     (defun gb/posframe-poshandler-frame-center-top (info)
       "Posframe's position handler.

          Get a position which let posframe stay onto its
          parent-frame's center top.  The structure of INFO can
          be found in docstring of `posframe-show'."
       (cons (+ gb/posframe-offset (/ (- (plist-get info :parent-frame-width)
                                         (plist-get info :posframe-width))
                                      2))
             20))

     (defun gb/kill-a-buffer-and-delete-window (askp)
       "kill the current buffer and remove the window"
       (interactive "P")
       (gb/kill-a-buffer askp)
       ;; only called without prefix argument and not the root window of the frame
       (unless (or askp (frame-root-window-p (get-buffer-window)))
         (ignore-errors
           (delete-window))))

     (defun gb/kill-a-buffer (askp)
       "kill the current buffer (ask if prefix argument is given)"
       (interactive "P")
       (if askp
           (kill-buffer (completing-read "Kill buffer: " (mapcar #'buffer-name (buffer-list))))
         (if (string= (buffer-name) "*scratch*")
             (message "scratch buffer must be killed explicitly (with prefix argument, then selecting the buffer)")
           (kill-buffer (current-buffer)))))

     (global-set-key (kbd "C-x k") 'gb/kill-a-buffer)
     (global-set-key (kbd "C-x C-k") 'gb/kill-a-buffer-and-delete-window)
   #+END_SRC
** printer
   extensions
   - add options to print black&white, 2sided, on a4, more than 1 pager per paper
   - printing from pdf-tools view uses the following options for printing
     - (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge"))
   - these could be set via function to allow duplex/non-duplex printing
   #+BEGIN_SRC emacs-lisp
     (setq ps-font-size (quote (7 . 6.5)))
     (setq ps-paper-type (quote a4))
     (setq ps-print-header-frame nil)
     (setq ps-print-header nil)
     (defun gb/get-known-printers ()
       "get all printers currently known to the system"
       (let* ((result (shell-command-to-string "lpstat -a | cut -f1 -d ' '"))
              (result-list (split-string result)))
         result-list))

     (defun gb/get-standard-printer ()
       "get the current standard printer"
       (string-trim (shell-command-to-string "lpq | grep -v 'no entries' | awk '{ print $1; }'")))

     (defun gb/set-default-printer (printer-str)
       "set the given printer to the standard printer"
       (shell-command (concat "lpoptions -d " printer-str " -o media=A4"))
       (setq printer-name printer-str)
       (setq ps-printer-name printer-str))

     (defun gb/query-default-printer ()
       "interactively query for the printer that is then set to be the default printer"
       (interactive)
       (let ((printer-name (completing-read "printer:" (gb/get-known-printers) nil t (gb/get-standard-printer))))
         (gb/set-default-printer printer-name)))

     (defun gb/print-buffer (x)
       "Output a postscript file using the defaults.

     When called with universal argument, use font lock.
     Ligatures are disabled for printing."
       (interactive "P")
       (let* (reenable-ligatures ligatures-enabled)
         (gb/disable-ligatures)
         (redisplay t)
         (setq ps-top-margin 80)
         (if x
             (ps-print-buffer-with-faces "~/temp.ps")
           (ps-print-buffer "~/temp.ps"))
         (cond
          ((is-macos-p) (shell-command "open /Applications/Preview.app ~/temp.ps"))
          ((executable-find "evince") (start-process "evince" nil "evince" (file-truename "~/temp.ps")))
          (t (message "No viewer for postscript files known to display ~/temp.ps")))
         (gb/enable-ligatures)))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp

   ;; source: https://stackoverflow.com/questions/5580562/formatting-an-integer-using-iso-prefixes-for-kb-mb-gb-and-kib-mib-gib
   (defconst number-to-string-approx-suffixes
     '("k" "M" "G" "T" "P" "E" "Z" "Y"))

   (defun number-to-string-approx-suffix (n &optional binary)
     "Return an approximate decimal representation of NUMBER as a string,
   followed by a multiplier suffix (k, M, G, T, P, E, Z, Y). The representation
   is at most 5 characters long for numbers between 0 and 10^19-5*10^16.
   Uses a minus sign if negative.
   NUMBER may be an integer or a floating point number.
   If the optional argument BINARY is non-nil, use 1024 instead of 1000 as
   the base multiplier."
     (if (zerop n)
         "0"
       (let ((sign "")
             (b (if binary 1024 1000))
             (suffix "")
             (bigger-suffixes number-to-string-approx-suffixes))
         (if (< n 0)
             (setq n (- n)
                   sign "-"))
         (while (and (>= n 9999.5) (consp bigger-suffixes))
           (setq n (/ n b) ; TODO: this is rounding down; nearest would be better
                 suffix (car bigger-suffixes)
                 bigger-suffixes (cdr bigger-suffixes)))
         (concat sign
                 (if (integerp n)
                     (int-to-string n)
                   (number-to-string (floor n)))
                 suffix))))

   (defun sudo-shell-command (command)
     (interactive "MShell command (root): ")
     (with-temp-buffer
       (cd "/sudo::/")
       (async-shell-command command)))

   (defun dont-kill-emacs()
     "Disable C-x C-c binding execute kill-emacs."
     (interactive)
     (error (substitute-command-keys "To exit emacs: \\[kill-emacs]"))) ;;\] closing bracket in comment to satisfy font locking
   (bind-key "C-x C-c" 'dont-kill-emacs)

   (defun ibuffer-list-buffers-and-switch ()
     "Shows a list of buffers"
     (interactive)
     (ibuffer-list-buffers)
     (other-window 1))

   (require 'subr-x)
   (defun _nix-program-exists-in-path-p (program-string)
     "Does the given exist as file and is on the path?
        PROGRAM is the name of the program without path, given as string.

        (fn PROGRAM)

        This program won't work in non unix environments.

        the return value is either t or nil."
     (let* ((which-result (shell-command-to-string (concat "command -v " program-string))))
       (not (or (string-empty-p which-result)
                (string-match (concat "no " program-string " in") which-result)
                (string-match "not found"  which-result)))))

   (defun all-files-exist (full-file-string-list)
     "does the given file (list of files, all) exist?
   pass either list of strings or a string."
     (if (stringp full-file-string-list)
         (file-regular-p full-file-string-list)
       (-none-p 'null (-map 'file-regular-p full-file-string-list))))

   (defun all-files-excutable (full-file-string-list)
     "is the given file (list of files, all) executable?
   pass either list of strings or a string."
     (if (stringp full-file-string-list)
         (file-executable-p full-file-string-list)
       (-none-p 'null (-map 'file-executable-p full-file-string-list))))

   (defun all-_nix-program-exists-in-path-p (program-string)
     "make sure that the PROGRAM-STRING exists as executable reachable for unix.
   If PROGRAM-STRING is a list, make sure this is true for all elements of the list"
     (if (stringp program-string)
         (executable-find program-string)
       (-none? 'null (-map 'executable-find program-string))))

   (defun report-string-or-list (string-or-list)
     "return STRING-OR-LIST if it is a string, else join the list of strings with comma"
     (if (stringp string-or-list)
         string-or-list
       (string-join string-or-list ", ")))

   (defmacro check-file-existence-status (var-name full-file-string file-name warning)
     "set VAR-NAME to t iff all files in FULL-FILE-STRING exist. additionall
   report existing files (with ok) and non existing files (with warning)."
     `(progn
        (setq ,var-name (all-files-exist ,full-file-string))
        (if (not ,var-name)
            (message (concat "WARNING: " ,file-name " missing, " ,warning))
          (message (concat "OK: " ,file-name " exists.")))))

   (defmacro check-windows-program-status (var-name full-program-string program-name warning)
     "Will check that FULL-PROGRAM-STRING is a full path to an executable and setq's VAR-NAME to installation status
        A WARNING will be logged if no installation is found.

        (macro VAR-NAME FULL-PROGRAM-STRING PROGRAM-NAME WARNING)
        "
     `(if (is-ms-windows-p)
          (progn
            (setq ,var-name (all-files-executable ,full-program-string))
            (if (not ,var-name)
                (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
              (message (concat "OK: " ,program-name " installed."))))
        (progn
          (setq ,var-name nil)
          (message (concat "UNCHECKED (win): " ,program-name)))))

   (defmacro check-_nix-program-status (var-name program-string program-name warning)
     "Will check that PROGRAM-STRING is an executable on the path and setq's VAR-NAME to installation status
        A WARNING will be logged if no installation is found.

        (macro VAR-NAME PROGRAM-STRING PROGRAM-NAME WARNING)
        "
     `(if (is-_nix-p)
          (progn
            (setq ,var-name (all-_nix-program-exists-in-path-p ,program-string))
            (if (not ,var-name)
                (message (concat "WARNING: " ,program-name " installation missing, " ,warning))
              (message (concat "OK: " ,program-name " installed."))))
        (progn
          (setq ,var-name nil)
          (message (concat "UNCHECKED (*nix) : " ,program-name)))))

   #+END_SRC
* delete old backup files
  #+begin_src emacs-lisp
  ;; delete backup files that are older than 20 weeks
  ;; or that are elisp files within .emacs.d/elpa/*
  (if (not (file-exists-p "~/file-backups"))
      (make-directory "~/file-backups"))
  (message "Deleting old backup files...")
  (let ((weeks (* 60 60 24 7 20)) ;; twenty weeks
        (current (float-time (current-time))))
    (dolist (file (directory-files (expand-file-name "~/file-backups") t))
      (when (and (backup-file-name-p file)
                 (or (> (- current (float-time (nth 5 (file-attributes file))))
                        weeks)
                     (string-match "!.emacs.d!elpa!.*elc?~$" file))) ;; remove old elpa files (which are not edited by me anyway)
        (message "about to delete file: %s" file)
        (delete-file file))))
  #+end_src
* ms windows specific stuff
  #+BEGIN_SRC emacs-lisp
    (when (is-ms-windows-p)
      (progn

        (setq gnutls-cli-installed nil)

        ;; make sure that git asks for the credentials via gui
        (setenv "GIT_ASKPASS" "git-gui--askpass")

        (setq graphviz-installation-path "C:/dev/tools/Graphviz 2.28/")

        (check-windows-program-status graphviz-installed (concat graphviz-installation-path "bin/dot.exe") "Graphviz" "org babel will not be able to prodcess dot files.")

        (if graphviz-installed
            (add-to-list 'exec-path graphviz-installation-path))

        (setq org-plantuml-jar-path "c:/dev/tools/plantuml.jar")

        (check-file-existence-status plantuml-installed org-plantuml-jar-path "plantuml.jar" "org babel won't be able to produce uml diagrams via plantuml.")

        (setq everthing-installation-path "C:/dev/tools/es/")
        (check-windows-program-status everything-installed (concat everthing-installation-path "es.exe") "Everything" "Helm locate will not work without 'Everthing' installed")

        (if everything-installed
            (progn
              (setq everything-cmd "C:/dev/tools/es/es.exe")
              (when (eq gb/completion-framework 'helm)
                (setq helm-locate-command "es.exe %s -r %s"))))

        (setq magithub-installation-path "c:/dev/tools/hub/bin/")
        (check-windows-program-status hub-installed (concat magithub-installation-path "hub.exe") "Hub" "cannot use magithub within magit.")

        (if hub-installed
            (magithub-hub-executable (concat magithub-installation-path "hub.exe")))

        ;; windows specific settings
        ;; 1. install AutoHotkey
        ;; 2. remap windows and alt keys (left windows key will be meta, alt key will be super)
        ;;      LWin::LAlt
        ;;      LAlt::LWin
        ;;      Capslock::Ctrl
        ;; 3. disable windows hot key binding in windows (LWin + f won't open the windows find dialog anymore!)
        ;;      - start 'regedit'
        ;;      - got to the key 'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer'
        ;;      - create a new DWORD 'NoWinKeys' entry  and set its value to 1
        ;;      - reboot

        ;; make sure that autohotkey is run beforehand to map the left windows key to alt!
        (setq w32-lwindow-modifier 'super)

        (setq w3m-installed nil)

        (setq aspell-installation-path "C:/dev/tools/Aspell/")
        (check-windows-program-status aspell-installed (concat aspell-installation-path "bin/aspell.exe") "Aspell" "no spell checking will be possible")

        (if aspell-installed
            (progn
              (add-to-list 'exec-path (concat aspell-installation-path "bin/"))
              (setq ispell-program-name "aspell")))))
  #+END_SRC
* mac os x specific stuff
** misc
   #+BEGIN_SRC emacs-lisp
   ;; mac specific adjustments (keyboard etc)
   (when (is-macos-p)
     (progn

       (setq browse-url-browser-function 'browse-url-chromium)
       (setq browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
       (setq browse-url-firefox-program "/Applications/Firefox.app/Contents/MacOS/firefox")

       ;;     ns-alternate-modifier
       ;;     ns-command-modifier
       ;;     ns-control-modifier
       ;;     ns-function-modifier
       ;;     ns-option-modifier (just a different name for ns-alternate-modifier)
       ;;     ns-right-alternate-modifier
       ;;     ns-right-command-modifier
       ;;     ns-right-control-modifier
       ;;     ns-right-option-modifier

       ;; Each variable can be set to 'control, 'meta, 'alt, 'super, or 'hyper.
       ;; control = C-
       ;; meta = M-
       ;; alt = A-
       ;; super = s-
       ;; hyper = H-


       ;; make sure native fullscreen is off (multi monitor support is shitty then)
       (setq ns-use-native-fullscreen nil)

       ;; make sure that using powerline, the arrows are not somewhat color garbled
       ;; Non-nil means to use sRGB colorspace on OSX >= 10.7.
       (setq ns-use-srgb-colorspace nil)

       ;; fonts anti-aliasing einschalten
       (setq mac-allow-anti-aliasing t)

       ;; Some mac-bindings interfere with Emacs bindings.
       (when (boundp 'mac-pass-command-to-system)
         (setq mac-pass-command-to-system nil))
       ;; Some mac-bindings interfere with Emacs bindings.
       (when (boundp 'mac-pass-control-to-system)
         (setq mac-pass-control-to-system nil))

       ;; Make sure the right alt key is not bound to meta (such that the right alt key can be used on a mac to create []{}...)
       (setq ns-command-modifier 'super)
       (setq ns-function-modifier 'hyper)
       (setq ns-alternate-modifier 'meta)
       (setq ns-control-modifier 'control)
       (setq ns-right-command-modifier 'super)

       ;; on macos x the right alt key is used to get e.g. the pipe '|' (alt-7)
       (setq ns-right-alternate-modifier nil) ;; 'meta

       (defun gb/keyboard-off-macbook-internal () "switch the internal keyboard of the macbook pro off"
              (interactive)
              (sudo-shell-command "kextunload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))

       (defun gb/keyboard-on-macbook-internal () "switch the internal keyboard of the macbook pro on"
              (interactive)
              (sudo-shell-command "kextload /System/Library/Extensions/AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext/"))
       ))
   #+END_SRC
** correct shell path behaviour
   #+BEGIN_SRC emacs-lisp
   ;; make sure this is run before anything else, since all shell program starts need the correct path
   ;; exec-path-from-shell alread required (w/i initial package setup)
   (when (is-macos-p)
     (exec-path-from-shell-initialize)
     (exec-path-from-shell-copy-envs
      '("PATH")))
   #+END_SRC
* check installation status of programs (*nix)
  - make sure this is done, after path is properly setup (mac os problem)
  #+BEGIN_SRC emacs-lisp
    (setq running-nixos (getenv "NIX_PATH"))
    (setq gb/use-exwm (or (string= "ok" (s-trim (shell-command-to-string "cat ~/.xinitrc | grep -q -e '^ *exec .*emacs' && echo 'ok'")))
                          running-nixos))
    ;; (if (is-linux-p)
    ;;     (let* ((tracepathResult (shell-command-to-string "tracepath -b -m 4 github.com"))
    ;;            (gb/behind-comp (s-contains? "compal" tracepathResult))
    ;;            (gb/behind-kabeld (s-contains? "kabel-deutschland" tracepathResult)))
    ;;       (setq gb/network-home (and gb/behind-comp gb/behind-kabeld)))
    ;;   (setq gb/network-home nil))
    (setq gb/dual-monitor-setup (string= "2" (s-trim (shell-command-to-string "xrandr --listmonitors | grep \"Monitors\" | awk '{ print $2; }'"))))

    ;; (setq gb/use-smart-mode-line (and gb/use-exwm gb/dual-monitor-setup (not gb/network-home) (not running-nixos))) ;;
    ;; (setq gb/use-space-line (not gb/use-smart-mode-line))


    (when (is-_nix-p)
      (progn

        ;; is imagemagick installed (program for command line image manipulation)
        ;; install via "brew install imagemagick" or "pacman -S imagemagick"
        (check-_nix-program-status imagemagick-installed "animate" "ImageMagick" "pdf-tools not installed!")
        (check-_nix-program-status poppler-installed "pdfinfo" "poppler" "pdf-tools not installed!")
        (check-_nix-program-status gnutls-cli-installed "gnutls-cli" "gnutls-cli" "gnutls-cli not installed!")

        (check-_nix-program-status xmllint-installed "xmllint" "xmllint" "xmllint not installed, some xml functions will not be accessible (e.g. formatting)")


        ;; graphviz brings dot (and other) cl tools which are needed for plantuml to work
        (check-_nix-program-status graphviz-installed "dot" "GraphViz" "dot is not available, thus plantuml cannot be used!")

        ;; make useful for pdf tools
        (check-_nix-program-status make-installed '("make" "automake" "autoconf" "g++" "gcc") "make-tools" "make-tools are not (completely) available, thus pdf-tools cannot be compiled!")

        ;; check basic tooling
        (check-_nix-program-status locate-installed "locate" "locate" "locate is not available, thus helm find file will not work properly!")

        ;; lein (for clojure)
        (check-_nix-program-status lein-installed "lein" "leinigen" "lein is not available, thus clojure/cider will not work properly!")

        ;; hub (for magithub)
        (check-_nix-program-status hub-installed "hub" "hub" "hub command line tool not available, magithub will not be installed")

        ;; gpg (for file encryption)
        (check-_nix-program-status gpg-installed "gpg" "gpg" "gpg is necessary for file encryption.")
        (when gpg-installed
            (setq epg-gpg-program "gpg"))

        (check-_nix-program-status w3m-installed '("w3m") "w3m" "html messages in gnus will not be displayed, helm dash browsing will not use w3m.")

        (check-_nix-program-status git-lfs-installed "git-lfs" "git-lfs" "magit-lfs will not be available")

        (check-_nix-program-status ledger-installed "ledger" "ledger" "ledger-mode will not be available")

        (check-_nix-program-status chromium-installed "chromium" "chromium" "chromium not found, flymd will not work")

        (check-_nix-program-status firefox-installed "firefox" "firefox" "firefox not found")

        (check-_nix-program-status icecat-installed "icecat" "icecat" "icecat not found")

        (check-_nix-program-status git-imerge-installed "git-imerge" "git-imerge" "git-imerge not found")

        (check-_nix-program-status languagetool-installed "languagetool" "languagetool" "languagetool not found")

        (check-_nix-program-status proselint-installed "proselint" "proselint" "proselint not found") ;; proselint is a linter for english prose

        (when chromium-installed
          (setq browse-url-browser-function 'browse-url-chromium)
          (setq browse-url-chromium-program (s-trim (shell-command-to-string "command -v chromium"))))

        ;; firefox takes precedence (over chromium)
        (when firefox-installed
          (setq browse-url-browser-function 'browse-url-firefox)
          (setq browse-url-firefox-program (s-trim (shell-command-to-string "command -v firefox"))))

        (when (and chromium-installed firefox-installed)
          (if (version< emacs-version "28")
              ;; use (old) browser-url-browser-function for custom url behavior
              (setq browse-url-browser-function
                    '((".*\\(/meet\\.jit\\.si/\\|/teams\\.microsoft\\|/meet\\.google\\.com/\\).*" . browse-url-chromium) ;; use chromium for jitsi and teams
                      ( ".*" . browse-url-firefox)))
            ;; use (new) browser-url-handlers for custom url behavior
            (setq browse-url-handlers
                  '((".*\\(/meet\\.jit\\.si/\\|/teams\\.microsoft\\|/meet\\.google\\.com/\\).*" . browse-url-chromium) ;; use chromium for jitsi and teams
                    ( ".*" . browse-url-firefox)))
            (setq browse-url-browser-function 'browse-url-firefox)))

        ;; icecat takes precedence (over firefox)
        ;; (if icecat-installed
        ;;   (progn
        ;;     (setq browse-url-browser-function 'browse-url-default-browser)
        ;;     (setq browse-url-chromium-program (s-trim (shell-command-to-string "command -v icecat")))))

        (setq gnu-ls-installed (not (is-ms-windows-p)))
        (if gnu-ls-installed
            (setq gnu-ls-bin-path (car (split-string (shell-command-to-string "command -v ls")))))
        ))
  #+END_SRC
* project specific settings
** allowed dir locals
   - look into [[file:~/.emacs.d/init.el]] search for 'safe-local-variable-values' and set these here accordingly
   #+begin_src emacs-lisp
     (put 'org-image-actual-width 'safe-local-variable #'integerp)
     (put 'org-tree-slide-presentation-length 'safe-local-variable #'integerp)
     (put 'typescript-indent-level 'safe-local-variable #'integerp)
     (put 'js-indent-level 'safe-local-variable #'integerp)
     (put 'json-reformat:indent-width 'safe-local-variable #'integerp)
     (custom-set-variables
      '(safe-local-variable-values
        '((org-tree-slide-content--pos)
          (org-confirm-babel-evaluate)
          (eval toggle-serif)
          (eval gb/set-dictionary "en")
          (eval org-show-all)
          (eval org-hide-block-all)
          (eval org-overview)
          (eval org-babel-result-hide-all)
          (eval gb/org-roam-open-entry-visibility)
          (eval gb/set-org-pretty-entities nil)
          (eval gb/set-org-pretty-entities t)
          (eval add-fira-code-symbol-keywords)
          (eval save-excursion (goto-char (point-min)) (org-next-visible-heading 1) (org-cycle))
          (eval add-hook 'after-save-hook
                '(lambda nil
                   (org-babel-tangle)
                   (yas-reload-all))
                nil 'make-it-local)
          (eval progn
                (setq current-prefix-arg
                      '(16))
                (call-interactively 'org-latex-preview))
          (eval setq org-format-latex-options
                (plist-put org-format-latex-options :scale 2.6))
          (gb/slides-started)
          (eval org-tree-slide-content)
          (eval goto-char
                (point-min))
          (eval org-toggle-inline-images)
          (org-tree-slide-modeline-display quote lighter)
          (org-tree-slide-heading-emphasis . t)
          (org-tree-slide-header)
          (eval org-display-inline-images)
          (eval gb/set-dictionary "de")
          (tide-format-options quote
                               (:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil)))))
   #+end_src
* check emacs capabilities
  #+BEGIN_SRC emacs-lisp
  ;; check on png support
  (if (image-type-available-p 'png)
      (message "OK: Image type png is supported.")
    (message "WARNING: image type png is NOT supported."))
  #+END_SRC
* play startup sound (check again 2)
  #+begin_src emacs-lisp
    ;; if not playing test again and play 2
    (gb/play-startup-sound-when-ctrlkey-down)
  #+end_src
* own utility functions (based on installed utils)
** xml
   #+BEGIN_SRC emacs-lisp
     ;; make sure flyspell works with nxml mode
     ;; (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)
     ;; make sure to use flyspell-prog-mode, though

     (require 'nxml-mode)
     (add-hook 'nxml-mode-hook #'yafolding-mode)

     ;; if interactively used, print the current path to the mini buffer
     ;; if used non interactively, return the same
     (defun nxml-where ()
       "Display the hierarchy of XML elements the point is on as a path."
       (interactive)
       (let ((path nil))
         (save-excursion
           (save-restriction
             (widen)
             (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                         (condition-case nil
                             (progn
                               (nxml-backward-up-element) ; always returns nil
                               t)
                           (error nil)))
               (setq path (cons (xmltok-start-tag-qname) path)))
             (let ((result (format "/%s" (mapconcat 'identity path "/"))))
               (if (called-interactively-p t)
                   (message result)
                 result))))))

     (defun nxml-where-to-clipboard ()
       "paste xpath of the current location into clipboard and message buffer"
       (interactive)
       (let ((result (nxml-where)))
         (kill-new result)
         (message result)))

     (when xmllint-installed
       (defun nxml-pretty-format ()
         "use command line tool xmllint to format (large) xml files"
         (interactive)
         (save-excursion
           (shell-command-on-region (point-min) (point-max) "xmllint -nowarning --format -" (buffer-name) t)
           (nxml-mode)
           (indent-region begin end))))

     (when xmllint-installed
       (defun nxml-xpath (xpath)
         "run an xpath (may NOT include namespaces) on the currently selected buffed.
     output is pasted into buffer *xpath-output*"
         (interactive (list (read-string "xpath:" nil 'xpath-history)))
         (let* ((out-buffer "*xpath-output*")
                (new-buffer (get-buffer-create out-buffer))
                (cmd (concat "xmllint --nowarning --xpath " (shell-quote-argument xpath) " -")))
           (if (fboundp 'persp-add-buffer)
               (persp-add-buffer out-buffer))
           (shell-command-on-region (point-min) (point-max) cmd out-buffer)
           (with-current-buffer out-buffer
             (condition-case nil
                 (if (string= "<" (buffer-substring-no-properties 1 2))
                     (nxml-mode)
                   (text-mode))
               (error (text-mode))))
           (if (not (get-buffer-window out-buffer))
               (message (concat "output is on buffer " out-buffer))))))

     (when xmllint-installed
       (defun nxml-xpath-on-file (xpath)
         "run an xpath (may include namespaces) on the FILE of the currently selected buffed.
     output is pasted into buffer *xpath-output*"
         (interactive (list (read-string "xpath:" nil 'xpath-history)))
         (let ((cmd (concat "echo -e \"setrootns\ncat " xpath "\" | xmllint --nowarning --shell "
                            (buffer-file-name (window-buffer (minibuffer-selected-window)))
                            "| grep -v -e \"^/ >\""))
               (out-buffer "*xpath-output*"))
           (if (fboundp 'persp-add-buffer)
               (persp-add-buffer out-buffer))
           (shell-command cmd out-buffer)
           (with-current-buffer out-buffer
             (condition-case nil
                 (if (string= "<" (buffer-substring-no-properties 1 2))
                     (nxml-mode)
                   (text-mode))
               (error (text-mode))))
           (if (not (get-buffer-window out-buffer))
               (message (concat "output is on buffer " out-buffer))))))

     (when xmllint-installed
       (defun nxml-run-xmllint-shell ()
         "run an interactive xmllint shell on the FILE of the currently selected buffer"
         (interactive)
         (compile (concat "xmllint --shell " (buffer-file-name (window-buffer (minibuffer-selected-window)))) t)))
   #+END_SRC

* encryption
** set auth-sources so that only gpg is used
   #+BEGIN_SRC emacs-lisp
   ;; (custom-set-variables  '(auth-sources ("~/.authinfo.gpg")))
   (setq auth-sources '("~/.authinfo.gpg"))
   #+END_SRC
** epa (see 'check-installation-status *nix)
** configure pinentry
   - see ~/.gnupg/gpg-agent.conf
   - need to add the line `allow-emacs-pinentry` to gpg-agent.conf
   - killing gpg agent by `gpgconf --kill gpg-agent`, restart is automatic, as soon as it is needed
   - see [[https://help.ubuntu.com/community/GnuPrivacyGuardHowto][here]] too
   #+begin_src emacs-lisp
     (defun pinentry-emacs (desc prompt ok error)
       (let ((str (read-passwd (concat (replace-regexp-in-string "%22" "\"" (replace-regexp-in-string "%0A" "\n" desc)) prompt ": "))))
         str))
   #+end_src
   #+BEGIN_SRC emacs-lisp
   (use-package epa
     :config
     (setq epa-pinentry-mode 'loopback))
   ;; (global-visible-mark-mode -1)
   #+END_SRC
* networking
** tls
   - --tofu                 Enable trust on first use authentication
   - --strict-tofu          Fail to connect if a known certificate has changed
   - %p inserts port
   - %h inserts host
   - keys are saved in ~/.gnutls/known_hosts
   #+BEGIN_SRC emacs-lisp
     (when (version< emacs-version "27.0")
       (use-package tls
         :ensure t
         :config
         (when gnutls-cli-installed
           (add-to-list 'tls-program "gnutls-cli -p %p %h")
           (setq gnutls-log-level 1) ;; (0 = none, 1 = important, 2 = debug)
           (custom-set-variables '(gnutls-verify-error t)))))
   #+END_SRC
   - fetch a certificate and put it into known_hosts
   #+BEGIN_SRC sh :tangle no
   gnutls-cli --tofu -p 443 imap.gmail.com
   #+END_SRC
** security
   #+begin_src emacs-lisp
     (setq network-security-level 'high)
   #+end_src
* browser
** w3m
   #+BEGIN_SRC emacs-lisp
   (if w3m-installed
       (use-package w3m
         :commands w3m w3m-search w3m-browse-url
         :ensure t
         :config
         (progn
           (setq w3m-default-display-inline-images t)
           (setq w3m-toggle-inline-images t))))
   #+END_SRC
* ui related stuff
** read only => viewer mode
   - switch viewer mode on in read only modes
   - page wise scrolling with space, back space
   #+begin_src emacs-lisp
     (setq view-read-only t)
   #+end_src
** clear windows in frame
   #+begin_src emacs-lisp
     (defun gb/clear-frame ()
       "switch to scratch window and maximize"
       (interactive)
       (switch-to-buffer "*scratch*")
       (delete-other-windows))
     (bind-key "s-c" #'gb/clear-frame)
   #+end_src
** command logging
   - 'M-x command-log-mode' opens a buffer that logs all commands used
   - other functions use prefix 'clm/'
   #+BEGIN_SRC emacs-lisp
   (use-package command-log-mode
     :commands clm/toggle-command-log-buffer
     :config
     (setq command-log-mode-auto-show t))
   #+END_SRC
** inline docs
   - enable e.g. through: (setq eldoc-message-function #'inline-docs)
   - shows help inline, above the current line (scrolling down, which is a bit annoying)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package inline-docs
     :config
     (progn
       ;; corrects version inline-docs-20170522.2150
       ;; redefinition of internal function to allow readable typescript inline display of flycheck errors (otherwise they are rendered in dimgray which is not helpful)
       (defun inline-docs--string-display (string apply-face)
         "Show STRING contents below point line until next command with APPLY-FACE."
         (let* ((border-line (make-string (window-body-width) inline-docs-border-symbol))
                (offset (make-string
                         (if (= (current-indentation) 0) ; fix (wrong-type-argument wholenump -1) when current indentation is 0 minus 1 will caused wholenump exception.
                             (current-indentation)
                           (- (current-indentation) 1))
                         inline-docs-prefix-symbol))
                (str (concat (propertize border-line
                                         'face 'inline-docs-border-face)
                             "\n"
                             offset
                             (propertize (concat inline-docs-indicator-symbol " ")
                                         'face 'inline-docs-indicator-face)
                             ;; GBA CHANGE { propertize text if no text properties are present
                             (if (next-property-change 0 string)
                                 (copy-sequence string) ; original eldoc string with format.
                               (propertize string 'face 'inline-docs-face))
                             ;; GBA CHANGE }
                             "\n"
                             (propertize border-line
                                         'face 'inline-docs-border-face)
                             "\n"))
                start-pos end-pos)
           (unwind-protect
               (save-excursion
                 ;; clear overlay
                 (inline-docs--clear-overlay)
                 ;; decide overlay positions
                 (cl-case inline-docs-position
                   ('above (forward-line 0))
                   ('below (forward-line)))
                 (setq start-pos (point))
                 (end-of-line)
                 (setq end-pos (point))
                 ;; create overlay
                 (setq inline-docs-overlay (make-overlay start-pos end-pos (current-buffer)))
                 ;; change the face
                 ;; (if apply-face
                 ;;     (overlay-put inline-docs-overlay 'face 'inline-docs-face))
                 ;; hide full line
                 ;; (overlay-put inline-docs-overlay 'display "")
                 ;; (overlay-put inline-docs-overlay 'display :height 20)
                 ;; pre-pend indentation spaces
                 ;; (overlay-put inline-docs-overlay 'line-prefix prefix)
                 ;; auto delete overlay
                 (overlay-put inline-docs-overlay 'evaporate t)
                 ;; display message
                 (overlay-put inline-docs-overlay 'before-string str))
             (add-hook 'post-command-hook 'inline-docs--clear-overlay))))

       ))
   #+END_SRC
** interaction log
   - start via ilog-log-buffer-mode, creates a buffer called *Emacs log*, just open it
   #+BEGIN_SRC emacs-lisp
     (use-package interaction-log
       :ensure
       :commands ilog-log-buffer-mode)
   #+END_SRC
** copy of window init from spacemacs
   #+BEGIN_SRC emacs-lisp
   (defvar gb--after-display-system-init-list '()
     "List of functions to be run after the display system is initialized.")

   (defadvice server-create-window-system-frame
       (after gb-init-display activate)
     "After Emacs server creates a frame, run functions queued in
   `GB--AFTER-DISPLAY-SYSTEM-INIT-LIST' to do any setup that needs to have
   the display system initialized."
     (progn
       (dolist (fn (reverse gb--after-display-system-init-list))
         (funcall fn))
       (ad-disable-advice 'server-create-window-system-frame
                          'after
                          'gb-init-display)
       (ad-activate 'server-create-window-system-frame)))

   (defmacro gb/do-after-display-system-init (&rest body)
     "If the display-system is initialized, run `BODY', otherwise,
   add it to a queue of actions to perform after the first graphical frame is
   created."
     `(let ((init (cond ((boundp 'ns-initialized) ns-initialized)
                        ;; w32-initialized gets set too early, so
                        ;; if we're on Windows, check the list of fonts
                        ;; instead (this is nil until the graphics system
                        ;; is initialized)
                        ((boundp 'w32-initialized) (font-family-list))
                        ((boundp 'x-initialized) x-initialized)
                        ;; fallback to normal loading behavior only if in a GUI
                        (t (display-graphic-p)))))
        (if init
            (progn
              ,@body)
          (push (lambda () ,@body) gb--after-display-system-init-list))))
   #+END_SRC
** winner mode
   - undo/redo window configuration with C-c <left> and C-c <right>
   #+BEGIN_SRC emacs-lisp
   (winner-mode 1)
   #+END_SRC
** minibuffer
   #+BEGIN_SRC emacs-lisp
   (setq enable-recursive-minibuffers nil) ;; recursive minibuffers may interfere with mini-frame, so it is switched off for now
   (minibuffer-depth-indicate-mode 1)
   #+END_SRC
** jumpy scrolling
   - some settings that makes scrolling a bit more what is actually wanted
   #+BEGIN_SRC emacs-lisp
     (progn

       ;; make sure to surround cursor movement with messages, preventing jumpy scrolling if on first or last line
       ;; (defadvice previous-line (before previous-line-before activate) (message "+"))
       ;; (defadvice previous-line (after previous-line-after activate) (message "-"))
       ;; (defadvice next-line (before previous-line-before activate) (message "-"))
       ;; (defadvice next-line (after previous-line-after activate) (message "+"))

       (setq-default scroll-up-aggressively 1e-12
                     scroll-down-aggressively 1e-12)
       (setq scroll-up-aggressively 1e-12
             scroll-down-aggressively 1e-12)
       (when (version<= "27.0" emacs-version)
         (setq fast-but-imprecise-scrolling t)
         ;; (pixel-scroll-mode 1)
         )
       (setq scroll-margin 0)
       (setq scroll-step 1)
       (setq scroll-conservatively 10000)
       (setq scroll-preserve-screen-position t)
       (setq maximum-scroll-margin nil)
       (setq auto-window-vscroll nil)
       ;; (setq auto-window-vscroll t) ;; seem not to exist, remove if irrelevant
       ;; (setq auto-window-hscroll t) ;; seem not to exist, remove if irrelevant
       )
     ;; (setq smooth-scroll/vscroll-step-size 3)
   #+END_SRC
** graphics
   #+begin_src emacs-lisp
     (set-default 'image-use-external-converter t) ;; use external converter for exotic graphics formats
   #+end_src
** COMMENT display symbols (pretty-mode, prettify-greek)
   #+BEGIN_SRC emacs-lisp
     (use-package pretty-mode
       :ensure t
       :config
       (progn
         ;; (global-pretty-mode 1)
         ;; (global-prettify-symbols-mode 1)
         (setq prettify-symbols-unprettify-at-point t)

         (--each '(racket-mode-hook
                   emacs-lisp-mode-hook
                   latex-mode-hook
                   kotlin-mode-hook
                   scala-mode-hook
                   html-mode-hook
                   maxima-mode-hook
                   clojure-mode-hook
                   python-mode-hook)
           (when (boundp it)
             (add-hook it 'turn-on-pretty-mode)))

         ;; make sure this does not collide with symbols from fira code symbol replacement (ligatures)
         (pretty-deactivate-groups
          '(:equality :ordering :ordering-double :ordering-triple
                      :arrows :arrows-twoheaded :punctuation :arithmetic :arithmetic-double))
         (pretty-activate-groups
          '(:sub-and-superscripts :greek :arithmetic-nary))
         ))

     (use-package prettify-greek
       :ensure t
       :config
       (defun gb/uglify-greek-symbols ()
         ""
        (setq prettify-symbols-alist (cl-set-difference prettify-symbols-alist
                        prettify-greek-lower))
        (prettify-symbols-mode t))

       (defun gb/prettify-greek-symbols ()
         ""
         (setq prettify-symbols-alist (append prettify-symbols-alist prettify-greek-lower))
         (prettify-symbols-mode t))

       (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  (gb/prettify-greek-symbols)
                  (prettify-symbols-mode t))))
   #+END_SRC
** font related stuff
   #+BEGIN_SRC emacs-lisp
     (setq gb/dual-screen-mode 'regular)
     (require 'jit-lock)

     (setq jit-lock-contextually nil       ;; 'syntax-driven
           jit-lock-defer-contextually nil  ;; is an alias for 'jit-lock-contextualy
           jit-lock-context-time 0.5      ;; 0.2
           jit-lock-defer-time 0          ;; 0.2
           jit-lock-stealth-load 200      ;; 200
           jit-lock-stealth-nice 1      ;; 0.2
           jit-lock-stealth-time 1      ;; 0.2
           jit-lock-chunk-size 500)       ;; default is 500
     (setq-default font-lock-multiline nil) ;; NEVER EVER SET THIS TO TRUE!!!!, makes opening this file a multi minute thing

     ;; exclude all buffers > 10k from being stealth fontified!
     (require 'dash) ;; just to make sure, is installed as minimum package on startup
     (setq gb/jit-lock-stealth-fontify-ignore-buffer-threshold 10000)
     (defun gb/jit-lock-stealth-fontify-ignore-buffers (&rest args)
       (when jit-lock-stealth-buffers
         (when-let ((buffers-to-ignore (--filter (> (buffer-size it) gb/jit-lock-stealth-fontify-ignore-buffer-threshold) jit-lock-stealth-buffers)))
           (--each buffers-to-ignore
             (setq jit-lock-stealth-buffers (remove it jit-lock-stealth-buffers))))))

     (advice-add 'jit-lock-stealth-fontify :after #'gb/jit-lock-stealth-fontify-ignore-buffers)
     ;; (advice-remove 'jit-lock-stealth-fontify #'gb/jit-lock-stealth-fontify-ignore-buffers)

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (setq font-lock-support-mode 'jit-lock-mode)
     (global-font-lock-mode 1)

     (setq fast-but-imprecise-scrolling t)
     (setq inhibit-compacting-font-caches t)
     (setq-default line-spacing (if (< (frame-width) 250) 0.1 4)) ;; depends a bit on the type of font selected

     (setq gb/default-font "Hack")
     ;; (setq gb/default-font "Source Code Pro")
     ;; (setq gb/default-font "Fira Code")
     ;; (setq gb/default-font "Cousine")
     ;; (setq gb/default-font "Lucida")
     ;; (setq gb/default-font "Liberation Mono")
     ;; (setq gb/default-font "Noto Mono for Powerline")
     ;; (setq gb/default-font "DejaVu Sans Mono")

     (when (member gb/default-font (font-family-list))
       ;; (set-frame-font (s-concat gb/default-font "-12") t t)
       ;; (add-to-list 'initial-frame-alist `(font . ,gb/default-font))
       ;; (add-to-list 'default-frame-alist `(font . ,gb/default-font))
       ;; (add-to-list 'frame-initial-frame-alist `(font . ,gb/default-font))
       )

     (when (not (member gb/default-font (font-family-list)))
       (message (concat "WARNING: expected font '" gb/default-font "' not found in available font list.")))

     (require 'ht)
     (defun gb/get-font-heights (display-width win-system)
       "Get font heights depending on display width"
       (if (memq win-system '(mac ns))
           (cond ((> display-width 3400)
                  (ht ('default-height 150) ('variable-pitch-height 140)))
                 ((ht ('default-height 130) ('variable-pitch-height 120))))
         (cond ((eq gb/dual-screen-mode 'presentation)
                (ht ('default-height 250) ('variable-pitch-height 250)))
               ((> display-width 5000)
                (ht ('default-height 140) ('variable-pitch-height 140)))
               ((> display-width 3400)
                (ht ('default-height 130) ('variable-pitch-height 130)))
               ((> display-width 1400)
                (ht ('default-height 110) ('variable-pitch-height 110)))
               ((ht ('default-height 85) ('variable-pitch-height 85))))))

     (defun gb/get-font-weights (win-system)
       "Get font weights depending on windowing system"
       (if (memq win-system '(mac ns))
           (ht ('default-weight 'light) ('variable-pitch-weight 'regular))
         (ht ('default-weight 'regular) ('variable-pitch-weight 'regular))))

     (setq gb/setup-main-fonts-needs-execution t)
     (defun gb/setup-main-fonts (&optional frame)
       "Set up default fonts.

       Use DEFAULT-HEIGHT for default face and VARIABLE-PITCH-HEIGHT
       for variable-pitch face."
       (when gb/setup-main-fonts-needs-execution
         (let* ((attr-map (ht-merge (gb/get-font-heights (x-display-pixel-width) window-system)
                                    (gb/get-font-weights window-system))))
           (message "setting up default fonts")
           (message (format "display pixel width %d" (x-display-pixel-width)))
           ;; (set-default-font gb/default-font)

           (apply 'custom-set-faces gb/list-of-faces-to-set)
           ;; (set-frame-font gb/default-font t nil)
           ;; (set-face-font 'default gb/default-font nil)
           (set-face-attribute 'default nil
                               ;; :family gb/default-font
                               :font gb/default-font
                               :height (ht-get attr-map 'default-height)
                               :weight (ht-get attr-map 'default-weight))
           (set-face-attribute 'variable-pitch nil
                               ;; :family "Fira Sans"
                               :height (ht-get attr-map 'variable-pitch-height)
                               :weight (ht-get attr-map 'variable-pitch-weight))
           (setq gb/setup-main-fonts-needs-execution nil))))

     (defun gb/reset-main-fonts ()
       "reinitialize fonts e.g. if resolution changed etc."
       (interactive)
       (setq gb/setup-main-fonts-needs-execution t)
       (gb/setup-main-fonts))

     ;; (gb/setup-main-fonts)
     (gb/do-after-display-system-init (gb/setup-main-fonts))
     ;;(add-hook 'after-make-frame-functions #'gb/setup-main-fonts)
     ;;(add-hook 'focus-in-hook #'gb/setup-main-fonts)
     ;;(when (display-graphic-p)
     ;;  (gb/setup-main-fonts))

     ;; (if after-init-time
     ;;     (gb/setup-main-fonts)
     ;;   (add-hook 'after-init-hook 'gb/setup-main-fonts))

   #+END_SRC
   - install ligatures via fira code symbol (had to install [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][fira code symbol]] for the following to work)
     #+BEGIN_SRC emacs-lisp
       (setq gb/setup-ligatures-needs-execution t)
       (setq fira-code-symbol-installed (member "Fira Code Symbol" (font-family-list)))
       (setq ligatures-enabled nil)

       (defun add-fira-code-symbol-keywords ()
         (when (boundp 'fira-code-font-lock-keywords-alist)
           (font-lock-add-keywords nil fira-code-font-lock-keywords-alist)))

       (defun remove-fira-code-symbol-keywords ()
         (when (boundp 'fira-code-font-lock-keywords-alist)
           (font-lock-remove-keywords nil fira-code-font-lock-keywords-alist)))

       (defun gb/-disable-ligatures (do-run-hooks)
         "disable ligatures"
         (remove-fira-code-symbol-keywords)
         (remove-hook 'prog-mode-hook
                      #'add-fira-code-symbol-keywords)
         (font-lock-flush)
         (when do-run-hooks (run-mode-hooks))
         (setq ligatures-enabled nil))

       (defun gb/disable-ligatures ()
         "disable ligatures (interactive)"
         (interactive)
         (gb/-disable-ligatures t))

       (defun gb/-enable-ligatures (do-run-hooks)
         "enable ligatures"
         (add-fira-code-symbol-keywords)
         (add-hook 'prog-mode-hook
                   #'add-fira-code-symbol-keywords)
         (font-lock-flush)
         (when do-run-hooks (run-mode-hooks))
         (setq ligatures-enabled t))

       (defun gb/enable-ligatures ()
         "enable ligatures"
         (interactive)
         (gb/-enable-ligatures t))

       (defun gb/toggle-ligatures ()
         "toggle display of ligatures in progmode"
         (interactive)
         (if ligatures-enabled
             (progn
               (gb/disable-ligatures)
               (message "disabled ligatures."))
           (progn
             (gb/enable-ligatures)
             (message "enabled ligatures."))))

       (defun gb/setup-ligatures (&optional frame)
         "setup ligatures"
         (when gb/setup-ligatures-needs-execution
           (progn
             (unless fira-code-symbol-installed
               (message "WARNING: Fira code symbol not installed. Ligatures will not be available."))

             (when fira-code-symbol-installed
               (message "setting up ligatures")
               ;; Fira code
               ;; This works when using emacs --daemon + emacsclient
               ;; (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
               ;; This works when using emacs without server/client
               (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
               ;; I haven't found one statement that makes both of the above situations work, so I use both for now

               (defconst fira-code-font-lock-keywords-alist
                 (mapcar (lambda (regex-char-pair)
                           `(,(car regex-char-pair)
                             (0 (prog1 ()
                                  (compose-region (match-beginning 1)
                                                  (match-end 1)
                                                  ;; The first argument to concat is a string containing a literal tab
                                                  ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
                         '(("\\(www\\)"                   #Xe100)
                           ("[^/\\*]\\(\\*\\*\\)[^\\*/]"        #Xe101) ;; double **
                           ("\\(\\*\\*\\*\\)"             #Xe102) ;; triple stars ***
                           ("\\(\\*\\*/\\)"               #Xe103) ;; double comment end **/
                           ("\\(\\*>\\)"                  #Xe104)
                           ("[^*]\\(\\*/\\)"              #Xe105) ;; single comment end */
                           ("\\(*\\)" #Xe16f) ;; single *
                           ("\\(\\\\\\\\\\)"              #Xe106)
                           ("\\(\\\\\\\\\\\\\\)"          #Xe107)
                           ("\\({-\\)"                    #Xe108)
                           ;; ("\\(\\[\\]\\)"                #Xe109) ;; []
                           ("\\(::\\)"                    #Xe10a)
                           ("\\(:::\\)"                   #Xe10b)
                           ("[^=]\\(:=\\)"                #Xe10c)
                           ("\\(!!\\)"                    #Xe10d)
                           ("\\(!=\\)"                    #Xe10e)
                           ("\\(!==\\)"                   #Xe10f)
                           ("\\(-}\\)"                    #Xe110)
                           ;; ("\\(--\\)"                    #Xe111) ;; double - (--)
                           ;; ("\\(---\\)"                   #Xe112) ;; triple - (---)
                           ("\\(-->\\)"                   #Xe113)
                           ("[^-]\\(->\\)"                #Xe114)
                           ("\\(->>\\)"                   #Xe115)
                           ("[^<-]\\(-<\\)[^<>]"                    #Xe116)
                           ("\\(-<<\\)"                   #Xe117)
                           ("\\(-~\\)"                    #Xe118)
                           ("\\(#{\\)"                    #Xe119)
                           ("\\(#\\[\\)"                  #Xe11a)
                           ("\\(##\\)"                    #Xe11b)
                           ("\\(###\\)"                   #Xe11c)
                           ("\\(####\\)"                  #Xe11d)
                           ("\\(#(\\)"                    #Xe11e)
                           ("\\(#\\?\\)"                  #Xe11f)
                           ("\\(#_\\)"                    #Xe120)
                           ("\\(#_(\\)"                   #Xe121)
                           ("\\(\\.-\\)"                  #Xe122)
                           ("\\(\\.=\\)"                  #Xe123)
                           ("\\(\\.\\.\\)"                #Xe124)
                           ("\\(\\.\\.<\\)"               #Xe125)
                           ("\\(\\.\\.\\.\\)"             #Xe126)
                           ("\\(\\?=\\)"                  #Xe127)
                           ("\\(\\?\\?\\)"                #Xe128)
                           ("\\(;;\\)"                    #Xe129)
                           ("\\(/\\*\\)"                  #Xe12a)
                           ("\\(/\\*\\*\\)"               #Xe12b)
                           ("\\(/=\\)[^=]"                    #Xe12c)
                           ("\\(/==\\)"                   #Xe12d)
                           ("[^<]\\(/>\\)"                    #Xe12e)
                           ("[^/]\\(//\\)[^/]"                    #Xe12f)
                           ("\\(///\\)"                   #Xe130)
                           ("\\(&&\\)"                    #Xe131)
                           ("\\(||\\)[^=]"                    #Xe132)
                           ("\\(||=\\)"                   #Xe133)
                           ("[^|]\\(|=\\)"                #Xe134)
                           ("\\(|>\\)"                    #Xe135)
                           ("\\(\\^=\\)"                  #Xe136)
                           ("\\(\\$>\\)"                  #Xe137)
                           ("\\(\\+\\+\\)"                #Xe138)
                           ("\\(\\+\\+\\+\\)"             #Xe139)
                           ("\\(\\+>\\)"                  #Xe13a)
                           ("\\(=:=\\)"                   #Xe13b)
                           ("[^!/]\\(==\\)[^>=]"           #Xe13c)
                           ("\\(===\\)"                   #Xe13d)
                           ("\\(==>\\)"                   #Xe13e)
                           ("[^=<>]\\(=>\\)[^>]"                #Xe13f)
                           ("\\(=>>\\)"                   #Xe140)
                           ("[^<>]\\(<=\\)[^=<>]"                    #Xe141)
                           ("\\(=<<\\)"                   #Xe142)
                           ("\\(=/=\\)"                   #Xe143)
                           ("\\(>-\\)"                    #Xe144)
                           ("\\(>=\\)[^>]"                    #Xe145)
                           ("\\(>=>\\)"                   #Xe146)
                           ("[^-=]\\(>>\\)"               #Xe147)
                           ("\\(>>-\\)"                   #Xe148)
                           ("\\(>>=\\)"                   #Xe149)
                           ("\\(>>>\\)"                   #Xe14a)
                           ("\\(<\\*\\)[^>]"                  #Xe14b)
                           ("\\(<\\*>\\)"                 #Xe14c)
                           ("\\(<|\\)[^>]"                    #Xe14d)
                           ("\\(<|>\\)"                   #Xe14e)
                           ("\\(<\\$\\)[^>]"                  #Xe14f)
                           ("\\(<\\$>\\)"                 #Xe150)
                           ("\\(<!--\\)"                  #Xe151)
                           ("\\(<-\\)[^-<>]"                    #Xe152)
                           ("\\(<--\\)"                   #Xe153)
                           ("\\(<->\\)"                   #Xe154)
                           ("\\(<\\+\\)[^>]"                  #Xe155)
                           ("\\(<\\+>\\)"                 #Xe156)
                           ("\\(<=\\)[^=<>]"                    #Xe157)
                           ("\\(<==\\)"                   #Xe158)
                           ("\\(<=>\\)"                   #Xe159)
                           ("\\(<=<\\)"                   #Xe15a)
                           ("[^-]\\(<>\\)[^-]"                    #Xe15b)
                           ("[^-=]\\(<<\\)"               #Xe15c)
                           ("\\(<<-\\)"                   #Xe15d)
                           ("\\(<<=\\)"                   #Xe15e)
                           ("\\(<<<\\)"                   #Xe15f)
                           ("\\(<~\\)[^~]"                    #Xe160)
                           ("\\(<~~\\)"                   #Xe161)
                           ("\\(</\\)[^>]"                    #Xe162)
                           ("\\(</>\\)"                   #Xe163)
                           ("\\(~@\\)"                    #Xe164)
                           ("\\(~-\\)"                    #Xe165)
                           ("\\(~=\\)"                    #Xe166)
                           ("[^<~]\\(~>\\)"                    #Xe167)
                           ("[^<]\\(~~\\)[^>]"                #Xe168)
                           ("\\(~~>\\)"                   #Xe169)
                           ("\\(%%\\)"                    #Xe16a)
                           ;;("\\(x\\)"                     #Xe16b) ;; single x
                           ;; ("[^:=]\\(:\\)[^:=]"           #Xe16c) ;; single :
                           ;; ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d) ;; single +
                           ;; ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f) ;; single *
                           )))



               (gb/enable-ligatures)
               (message "enabled ligatures.")
               (setq gb/setup-ligatures-needs-execution nil)))))

       (gb/do-after-display-system-init (gb/setup-ligatures))
       ;; (add-hook 'focus-in-hook #'gb/setup-ligatures)
       ;; (add-hook 'after-make-frame-functions #'gb/setup-ligatures)
       ;; (when (display-graphic-p)
       ;;   (gb/setup-ligatures))

     #+END_SRC

   - speedup frame creation by caching font list during setup
     #+begin_src emacs-lisp
       (setq gb/face-list (mapcar #'car face-new-frame-defaults))

       (defun gb/face-list-func (orig-func &rest args)
         "Return a list of all defined faces. cached version using cached list."
         gb/face-list)

       (defun gb/facep (orig-func &rest args)
         "is FACE a face name. cached version working on cached list."
         (memq (car args) gb/face-list))

       (defun gb/around-make-frame (orig-func &rest args)
         "advice make frame to make use of cached font information (which would otherwise slow the creation of the frame down)"
         (setq gb/face-list (mapcar #'car face-new-frame-defaults))
         (advice-add 'face-list :around #'gb/face-list-func)
         (advice-add 'facep :around #'gb/facep)
         (let ((result (apply orig-func args)))
           (advice-remove 'facep #'gb/facep)
           (advice-remove 'face-list #'gb/face-list-func)
           result))

       (defun gb/install-frame-creation-speedup ()
         "makes frame creation much faster by reusing font lists. this may however disrupt some programs, see gb/disable-frame-speedup-for"
         (advice-add 'make-frame :around
                     #'gb/around-make-frame))

       (defun gb/remove-frame-creation-speedup ()
         "restore the old frame creation method, which is quite slow"
         (advice-remove 'make-frame #'gb/around-make-frame))

       ;; default is: speedup frame creation
       (gb/install-frame-creation-speedup)

       (defun gb/disable-frame-speedup-for (orig-func &rest params)
         "disable frame creation speedup for functions (e.g. gnus) that show font problems"
         (gb/remove-frame-creation-speedup)
         (apply orig-func params)
         (gb/install-frame-creation-speedup))
     #+end_src
** sublimity (smooth scrolling)
   - patched ~sublimity--post-command~ commented out ~(recenter)~ after vscroll detection
   - patched sublimity-scroll--vscroll-effect and  sublimity-scroll--hscroll-effect to ~NOT~ execute ~(force-window-update)~
   #+BEGIN_SRC emacs-lisp
     (use-package sublimity
       :ensure t
       :config
       (progn
         ;; enable smooth scrolling
         (require 'sublimity-scroll)

         ;; make sure not to use sublimity in the following modes
         ;; all terminal modes (does reposition to the bottom)
         ;; pdf view mode (does mix up left and right scrolling if active, since repositioning does not work here)
         (add-to-list 'sublimity-handle-scroll-criteria '(not (memq major-mode (list 'ansi-term-mode 'term-mode 'shell-mode 'pdf-view-mode 'image-mode))))

         (setq sublimity-auto-hscroll-mode t)
         (setq sublimity-scroll-drift-length 3)
         (setq sublimity-scroll-weight 3)
         (setq auto-hscroll-mode t) ;; does not work in sublimity scroll mode
         ;; minimap is explicitly not enabled, since another minimap-mode is used for that
         ;; enable minimap
         ;; (require 'sublimity-map)
         ;; show minimap after x seconds of inactivity
         ;; (sublimity-map-set-delay 3)

         (sublimity-mode 1)))
   #+END_SRC
** other
   #+BEGIN_SRC emacs-lisp
   ;; Changes all yes/no questions to y/n type
   (defalias 'yes-or-no-p 'y-or-n-p)

   ;; These settings relate to how emacs interacts with your operating system
   (setq ;; makes killing/yanking interact with the clipboard
    select-enable-clipboard t

    ;; use primary selection for cut/paste
    select-enable-primary t

    ;; Save clipboard strings into kill ring before replacing them.
    ;; When one selects something in another program to paste it into Emacs,
    ;; but kills something in Emacs before actually pasting it,
    ;; this selection is gone unless this variable is non-nil
    save-interprogram-paste-before-kill t

    ;; Shows all options when running apropos. For more info,
    ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html
    apropos-do-all t

    ;; Mouse yank commands yank at point instead of at click.
    mouse-yank-at-point t)

   ;; No cursor blinking, it's distracting
   (blink-cursor-mode 0)

   ;; make cursor the width of the character it is under
   ;; i.e. full width of a TAB
   (setq x-stretch-cursor t)

   ;; full path in title bar
   (setq-default frame-title-format "%b (%f)")

   (setq visible-bell 1)
   #+END_SRC
** window/frame
   #+BEGIN_SRC emacs-lisp
     (defvar gb/time-of-last-redisplay-s nil
       "time as float, redisplay took the last time (in s)")

     (defun gb/speeds-based-on-last-redisplay (val repetition)
       (let* ((actual-repetition (min repetition (max 1 (floor (/ repetition (/ (max 0.0001 (or gb/time-of-last-redisplay-s 0.1)) 0.1))))))
              (actual-val (floor (* val (/ repetition (float actual-repetition)))))
             result)
         (dotimes (i actual-repetition)
           (push actual-val result))
         result))

     ;; do window enlarge and shrink
     (defun shrink-window-horizontally-effect (&optional divider)
       "shrink window within a frame with visual effect"
       (interactive)
       (let ((cols (/ (frame-width) (or divider 25))))
         (save-excursion
           (let ((speeds (gb/speeds-based-on-last-redisplay cols 3)))
             (dolist (speed speeds)
               (shrink-window-horizontally speed)
               (force-window-update (selected-window))
               (setq gb/time-of-last-redisplay-s
                     (measure-time
                      (redisplay))))))))

     (defun enlarge-window-horizontally-effect (&optional divider)
       "enlarge window within frame with visual effect"
       (interactive)
       (let ((cols (/ (frame-width) (or divider 25))))
         (save-excursion
           (let ((speeds (gb/speeds-based-on-last-redisplay cols 3)))
             (dolist (speed speeds)
               (enlarge-window-horizontally speed)
               (force-window-update (selected-window))
               (setq gb/time-of-last-redisplay-s
                     (measure-time
                      (redisplay))))))))

     (defun enlarge-window-effect (&optional divider)
       "enlarge window vertically with visual effect"
       (interactive)
       (let ((lines (/ (frame-height) (or divider 25))))
         (save-excursion
           (let ((speeds (gb/speeds-based-on-last-redisplay lines 3)))
             (dolist (speed speeds)
               (enlarge-window speed)
               (force-window-update (selected-window))
               (setq gb/time-of-last-redisplay-s
                     (measure-time
                      (redisplay))))))))

     (defun shrink-window-effect (&optional divider)
       "shrink window vertically with visual effect"
       (interactive)
       (let ((lines (/ (frame-height) (or divider 25))))
         (save-excursion
           (let ((speeds (gb/speeds-based-on-last-redisplay lines 3)))
             (dolist (speed speeds)
               (shrink-window speed)
               (force-window-update (selected-window))
               (setq gb/time-of-last-redisplay-s
                     (measure-time
                      (redisplay))))))))

     ;; (defun balance-windows-respecting-speedbar ()
     ;;   "balance all windows but make sure that speedbar is sized to 50 width"
     ;;   (interactive)
     ;;   (balance-windows)
     ;;   (with-selected-window (get-buffer-window "*SPEEDBAR*")
     ;;     (let ((delta (- 50 (window-width (selected-window)))))
     ;;       (if (< 0 delta)
     ;;           (shrink-window-horizontally (- delta))
     ;;         (enlarge-window-horizontally delta)))))

     ;; make sure that macos mouse scrolling is not too jerky
     (setq mouse-wheel-scroll-amount '(0.01))
   #+END_SRC
** maxframe
   #+BEGIN_SRC emacs-lisp
   (use-package maxframe
     :config
     (progn
       ;; remove defined alias
       (defalias 'mf nil)))
   #+END_SRC
** transpose frame
   #+BEGIN_SRC emacs-lisp
   (use-package transpose-frame
     :bind (
            ("C-s-+" . flip-frame) ;; exchange top with bottom windows (german layout)
            ("C-s-]" . flip-frame) ;; us layout
            ("C-s-#" . flop-frame) ;; exchange right with left windows
            ("C-s-'" . flop-frame) ;; us layout
            ("C-s--" . transpose-frame) ;; exchange splitted vertically with splitted horizontally window
            ("C-s-/" . transpose-frame) ;; us layout
            )
     :ensure t)
   #+END_SRC
** bind-key
   #+BEGIN_SRC emacs-lisp
     ;; set global keys for window management
     (use-package bind-key
       :after ( ibuffer windmove)
       :config
       (progn

         ;; select window (left,right,up or down) relative to current window
         (bind-key "s-<left>" 'windmove-left)
         (bind-key "s-<right>" 'windmove-right)
         (bind-key "s-<up>" 'windmove-up)
         (bind-key "s-<down>" 'windmove-down)
         ;; shrink selected window horizontally
         (bind-key "C-s-<left>" 'shrink-window-horizontally-effect)
         (bind-key "C-S-s-<left>" '(lambda () (interactive) (shrink-window-horizontally-effect 50)))
         ;; enlarge selected window horizontally
         (bind-key "C-s-<right>" 'enlarge-window-horizontally-effect)
         (bind-key "C-S-s-<right>" '(lambda () (interactive) (enlarge-window-horizontally-effect 50)))
         ;; shrink selected window vertically
         (bind-key "C-s-<down>" 'shrink-window-effect)
         (bind-key "C-S-s-<down>" '(lambda () (interactive) (shrink-window-effect 50)))
         ;; enlarge slected window vertically
         (bind-key "C-s-<up>" 'enlarge-window-effect)
         (bind-key "C-S-s-<up>" '(lambda () (interactive) (enlarge-window-effect 50)))

         ;; ;; maximize selected window
         (bind-key "C-s-<return>" 'maximize-window)
         ;; ;; balance all windows and the set speedbar to 50 width
         (bind-key "C-s-<backspace>" 'balance-windows)

         ;; Key binding to use "hippie expand" for text autocompletion
         ;; http://www.emacswiki.org/emacs/HippieExpand
         (bind-key "s-7" 'hippie-expand)
         ;; Interactive search key bindings. By default, C-s runs
         ;; isearch-forward, so this swaps the bindings.
         (bind-key "C-s" 'isearch-forward-regexp) ;; currently shadowed by visual-regexp (in test)
         (bind-key "C-r" 'isearch-backward-regexp) ;; currently shadowed by visual-regexp (in test)
         ;; (bind-key "C-M-s" 'isearch-forward)
         ;; (bind-key "C-M-r" 'isearch-backward)

         ;; indent relative to the stuff on the previous line
         ;; overwrite (hide) original binding M-i tab-to-tab-stop
         ;; (global-set-key (kbd "M-i") 'indent-relative)
         (bind-key "M-i" 'indent-relative)


         (bind-key "C-c RET" 'gb/remove-dos-eol)
         (bind-key "C-c <C-return>" 'gb/remove-dos-eol)

         (bind-key "C-x C-c" 'dont-kill-emacs)

         ;; (bind-key "s-+" 'decrease-transparency)
         ;; (bind-key "s--" 'increase-transparency)
         ;; (bind-key "s-#" 'disable-transparency)
         ;; (bind-key "s-]" 'decrease-transparency)

         (bind-key "C-;" 'toggle-comment-on-line)

         (bind-key "C-x b" 'ibuffer-list-buffers-and-switch)

         ;; make sure that C-g behaves just as helm-buffer, aborting the buffer switch
         ;; TODO ibuffer mode map not known yet
         ;; (bind-key "C-g" 'quit-window ibuffer-mode-map)

         ;; (bind-key "<s-up>" 'scroll-up-line)
         ;; (bind-key "<s-down>" 'scroll-down-line)
         ;; (bind-key "<M-s-up>" 'scroll-up-line-7)
         ;; (bind-key "<M-s-down>" 'scroll-down-line-7)

         ;; (bind-key "<s-C-up>" 'scroll-up-line-and-move-cursor)
         ;; (bind-key "<s-C-down>" 'scroll-down-line-and-move-cursor)

         ;; (bind-key "<s-C-M-up>" 'scroll-up-line-and-move-cursor-7)
         ;; (bind-key "<s-C-M-down>" 'scroll-down-line-and-move-cursor-7)

         (bind-key "C-h C-m" 'discover-my-major)))
   #+END_SRC
** symon sytem stats (for minibuffer), disabled
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package symon
     :commands symon-mode
     :config
     (progn
       ;; make sure to load it
       (require 'symon)

       (setq symon-sparkline-width 20)
       (setq symon-history-size 20)
       (setq symon-sparkline-use-xpm t)
       (setq symon-network-rx-upper-bound 1100)))

   #+END_SRC
** modeline
*** all the icons
    #+BEGIN_SRC emacs-lisp
    (use-package memoize
      :ensure t)

    (use-package all-the-icons
      :ensure t
      ;; :after ( memoize) ;; font-lock+
      :config
      ;; extend list of all-the-icons-mode-icon-alist
      ;; by
      ;; (typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
      ;; (tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow)
      (with-eval-after-load 'all-the-icons
        (progn
          (add-to-list 'all-the-icons-mode-icon-alist '(typescript-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
          (add-to-list 'all-the-icons-mode-icon-alist '(tide-mode all-the-icons-fileicon "typescript" :v-adjust -0.1 :face all-the-icons-yellow) t)
          )))
    #+END_SRC
*** doom modeline
    - adjusted file doom-modeline-segments.el:288, changed "save" to "change_history" (icon)
    - adjusted file doom-modeline-segments.el:697, changed "block" to "sim_card_alert"
    - OBSOLETE: adjusted file doom-modeline-core.el doom-modeline--font-height, change heigth to 120 (instead of calculating font height)
    - OBSOLETE: adjusted file doom-modeline-core.el doom-modeline-def-modeline, change (if (number-or-marker-p 120)...) (instead of calculation font
      stuff here)
    - patched some functions, see below
    #+begin_src emacs-lisp :tangle no
        ;; patched doom-modeline-update-buffer-file-state-icon to use once created icons
        (defvar doom-modeline--lock-icon
          (doom-modeline-buffer-file-state-icon
           "lock" "" "%1*" `(:inherit doom-modeline-warning
                                        :weight ,(if doom-modeline-icon
                                                     'normal
                                                   'bold)))
          "icon for showing lock")

        (defvar doom-modeline--changed-icon
          (doom-modeline-buffer-file-state-icon
           "change_history" "" "%1*" `(:inherit doom-modeline-buffer-modified
                                                  :weight ,(if doom-modeline-icon
                                                               'normal
                                                             'bold)))
          "icon for changed source")

        (defvar doom-modeline--missing-file-icon
          (doom-modeline-buffer-file-state-icon
           "do_not_disturb_alt" "" "!" 'doom-modeline-urgent)
          "icon for non existing file")

        (defun doom-modeline-update-buffer-file-state-icon (&rest _)
          "Update the buffer or file state in mode-line."
          (setq doom-modeline--buffer-file-state-icon
                (when doom-modeline-buffer-state-icon
                  (ignore-errors
                    (concat
                     (cond (buffer-read-only
                            doom-modeline--lock-icon)
                           ((and buffer-file-name (buffer-modified-p)
                               doom-modeline-buffer-modification-icon)
                            doom-modeline--changed-icon)
                           ((and buffer-file-name
                               (not (file-exists-p buffer-file-name)))
                            doom-modeline--missing-file-icon)
                           (t ""))
                     (when (or (buffer-narrowed-p)
                              (and (bound-and-true-p fancy-narrow-mode)
                                 (fancy-narrow-active-p)))
                       (doom-modeline-buffer-file-state-icon
                        "vertical_align_center" "" "><" 'doom-modeline-warning)))))))
    #+end_src
    #+BEGIN_SRC emacs-lisp
      (use-package doom-modeline
        :ensure t
        ;; :after (all-the-icons)
        :config
        (setq gb/cached-file-remote-p-hash (make-hash-table :test 'equal))
        (setq gb/original-file-remote-p #'file-remote-p)
        (setq doom-modeline-icon nil)
        (setq doom-modeline-enable-word-count nil)
        (setq doom-modeline-unicode-fallback nil)
        (setq doom-modeline-modal-icon nil)
        (setq doom-modeline-irc nil) ;; check
        (setq doom-modeline-persp-icon nil)
        (setq doom-modeline-persp-name nil)
        (setq doom-modeline-gnus-timer nil)
        (setq doom-modeline-workspace-name nil)
        (setq doom-modeline-env-version nil)
        (setq doom-modeline-checker-simple-format t)
        (setq doom-modeline-buffer-file-name-style 'truncate-with-project)
        ;; TODO: transform redefinition into surrounding advice!
        ;; TODO: drop some / clear hash once in a while / e.g. if size > 1000
        ;; overwrite this function
        ;; (defun file-remote-p (file &optional identification connected)
        ;;   "cached version"
        ;;   (let ((result (gethash file gb/cached-file-remote-p-hash 'not-found)))
        ;;     (if (equal result 'not-found)
        ;;         (let ((o-result (let ((handler (find-file-name-handler file 'file-remote-p)))
        ;;                           (if handler
        ;;                               (funcall handler 'file-remote-p file identification connected)
        ;;                             nil))))
        ;;           (puthash file o-result gb/cached-file-remote-p-hash)
        ;;           o-result)
        ;;       result)))
        (setq doom-modeline--font-width-cache nil)
        (defun doom-modeline--font-width ()
          "Cache the font width."
          (or doom-modeline--font-width-cache
              (let ((width (window-font-width nil 'mode-line)))
                (setq doom-modeline--font-width-cache width)
                width)))

        (setq doom-modeline-vcs-max-length 40)
        (setq inhibit-compacting-font-caches t)
        (setq doom-modeline-height 1)
        (setq doom-modeline-project-detection 'ffip)
        ;; (set-face-attribute 'mode-line nil :height 120)
        ;; (set-face-attribute 'mode-line-inactive nil :height 110)
        ;; (custom-set-faces '(mode-line ((t (:background "#403040" :foreground "#d5d8d6" :weight normal :height 110)))))

        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '((doom-modeline-bar ((t (:background "#600060"))))
                        (doom-modeline-bar-inactive ((t (:background "#500050"))))
                        (mode-line ((t (:background "#251422" :foreground "#808080" :overline "#504050" :weight normal))))
                        (mode-line-inactive ((t (:inherit mode-line :background "#251422" :foreground "#969896" :weight normal)))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
        (doom-modeline-mode 1))
    #+END_SRC
*** spinner (busy indicator for modeline)
    - (spinner-start 'vertical-breathing 10)
    - (spinner-start 'minibox)
    - (spinner-start 'moon)
    - (spinner-start 'triangle)
    #+BEGIN_SRC emacs-lisp
      (use-package spinner
        :ensure t
        :custom (spinner-frames-per-second 2))
    #+END_SRC
*** spaceline (mode line of spacemacs) (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      (when gb/use-space-line
        (use-package powerline)
        (use-package spaceline
          :ensure t
          :after ( powerline) ;; symon
          :config
          ;; Valid Values: alternate, arrow, arrow-fade, bar, box, brace,
          ;; butt, chamfer, contour, curve, rounded, roundstub, wave, zigzag,
          ;; utf-8
          (setq powerline-default-separator nil) ;;'utf-8

          (require 'spaceline-config)
          (spaceline-spacemacs-theme)
          (spaceline-helm-mode)
          (custom-set-faces
           '(spaceline-highlight-face ((t (:background "DarkGoldenrod3" :foreground "#000000" :inherit (quote mode-line))))))

          (gb/do-after-display-system-init

           (setq gb/mode-line-buffer-read-only-symbol (if fira-code-symbol-installed "\ue0a2" "o"))  ;; ""
           (setq gb/mode-line-buffer-modified-ro-symbol (if fira-code-symbol-installed "\ue16b" "x"))  ;; ""
           (setq gb/mode-line-buffer-modified-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
           (setq gb/mode-line-branch-up-to-date-symbol "\u2713")  ;; ""
           (setq gb/mode-line-branch-edited-symbol (if fira-code-symbol-installed "\ue16f" "*"))  ;; ""
           (setq gb/mode-line-cutted-path-prefix-symbol "\u2025") ;; ""

           (defun gb/symon-display-str ()
             "update symon display"
             (let ((message-log-max nil)  ; do not insert to *Messages* buffer
                   (display-string nil)
                   (page 0)
                   (displaystr ""))
               (dolist (lst symon--display-fns)
                 (if (= page symon--active-page)
                     (setq displaystr (apply 'concat (mapcar 'funcall lst)))
                   (mapc 'funcall lst))
                 (setq page (1+ page)))
               displaystr)
             )

           (spaceline-define-segment gb/symon
             ""
             "" ;;(gb/symon-display-str)
             )

           (spaceline-define-segment gb/buffer-status
             "Buffer status (read-only, modified), with color"
             (cond ((and buffer-read-only (buffer-modified-p)) gb/mode-line-buffer-modified-ro-symbol)
                   (buffer-read-only gb/mode-line-buffer-read-only-symbol)
                   ((buffer-modified-p) gb/mode-line-buffer-modified-symbol)
                   (t " ")))

           (spaceline-define-segment gb/date-and-cw
             "display date and calendar week of window is broad enough"
             (if (> (window-width) 150)
                 (propertize (format-time-string "%m-%d/%V")
                             'help-echo "month-day/calendarweek")
               ""))

           (spaceline-define-segment gb/buffer-id
             (propertize (buffer-name) 'help-echo (format "%s, size: %s" (buffer-name) (number-to-string (buffer-size)))))

           (spaceline-define-segment gb/buffer-file-name
             "provide fullpath to buffer file name, shortened to 35 characters if too long"
             ;; limit path length to a certain number of characters (currently 35)
             ;; TODO: allow replacing certain paths with some shorthands (e.g. :doc: for ~/Documents/)
             (let* ((path (replace-regexp-in-string (concat "^" (regexp-quote (expand-file-name "~"))) "~" (or (file-name-directory (or buffer-file-name "")) "")))
                    (maxlen (max 0 (- (window-width) 57 (length (buffer-name)))))
                    (spath (cond ((>= 0 maxlen) "")
                                 ((> (length path) maxlen)
                                  (concat gb/mode-line-cutted-path-prefix-symbol (substring path (- maxlen) nil)))
                                 (t path))))
               (propertize spath 'help-echo path))
             ;;     (or spath "")
             )

           (defun parent-dir-of (directory)
             "parrent directory of the given"
             (s-join "/" (-drop-last 1 (s-split "/" directory))))

           (defun file-exists-up-the-tree (directory filename)
             "does the given file exist in this directory or anywhere up to the root?"
             (or (file-exists-p (concat directory "/" filename))
                 (and (not (or (string= "/" directory)
                               (string-empty-p directory)))
                      (file-exists-up-the-tree (parent-dir-of directory) filename))))

           (defun gb/in-git-dir-p ()
             (or
              (and (buffer-file-name) (file-exists-up-the-tree (file-name-directory (buffer-file-name)) ".git"))
              (not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir")))))

           (defun gb/vc-status ()
             (if vc-mode
                 vc-mode
               (concat "\ue0a0 " (car (split-string (shell-command-to-string "git rev-parse --abbrev-ref HEAD"))))))

           (setq gb/vc-status-cache-delay "10 sec")
           (setq gb/vc-status-cache-buffer-id nil)
           (setq gb/vc-status-cache nil)
           (setq gb/vc-status-cache-timer nil)

           (defun gb/get-cached-git-state ()
             "if cache filled and within same buffer (name) refresh in five seconds and return cached value, else refresh cache and return new values"
             (if (and gb/vc-status-cache (string= (buffer-name) gb/vc-status-cache-buffer-id))
                 ;; only if no timer is running!
                 (unless gb/vc-status-cache-timer
                   (setq gb/vc-status-cache-timer (run-at-time gb/vc-status-cache-delay nil 'gb/refresh-vc-status-cache)))
               (gb/refresh-vc-status-cache))
             gb/vc-status-cache)

           (defun gb/refresh-vc-status-cache ()
             "refresh values with actual git call and clear timer (maybe cancel?)"
             (setq gb/vc-status-cache-buffer-id (buffer-name))
             (setq gb/vc-status-cache (gb/git-state))
             (setq gb/vc-status-cache-timer nil))

           (defun gb/git-state ()
             "query git status for the currently active buffer, refresh on buffer switches"
             (let* ((git-output (shell-command-to-string "git status -s")))
               ;; (message (concat  "git querried " (current-time-string))) ;; just for debugging, please remove when done
               (if (string-empty-p git-output)
                   'up-to-date
                 'dirty)))

           (defun gb/vc-state ()
             (if (buffer-file-name)
                 (vc-state (buffer-file-name))
               (gb/get-cached-git-state)))

           (defun gb/buffer-on-remote ()
             "return whether current buffer is on remote (via tramp)"
             (file-remote-p (or default-directory buffer-file-name dired-directory "")))

           (spaceline-define-segment gb/projectile-id
             (cond ((gb/buffer-on-remote) "")
                   ((and (fboundp 'projectile-project-p) (projectile-project-p))
                    (projectile-project-name))
                   (t "")))

           (spaceline-define-segment gb/version-control
             "Version control information."
             (when (and (not (gb/buffer-on-remote)) (gb/in-git-dir-p))
               (powerline-raw
                (s-trim (concat (replace-regexp-in-string "^ *Git[:-]" "\ue0a0 " (gb/vc-status)) ;; "  "
                                (pcase (gb/vc-state)
                                  (`up-to-date (concat " " gb/mode-line-branch-up-to-date-symbol))
                                  (`edited (concat " " gb/mode-line-branch-edited-symbol))
                                  (`added " +")
                                  (`unregistered " ?")
                                  (`removed " -")
                                  (`needs-merge " m")
                                  (`needs-update " u")
                                  (`ignored " i")
                                  (_ " x")))))))

           (spaceline-define-segment gb/time
             "A segment to to display the time"
             (propertize (format-time-string "%H:%M")
                         'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit)
                         'display '(raise 0.1)
                         'help-echo (format-time-string "%A, %Y.%m.%d %H:%M")))

           (when (package-installed-p 'indent-info)
             (spaceline-define-segment gb/indent-info-mode-line
               ""
               (indent-info-mode-line)))

           )))
    #+END_SRC
*** spaceline all the icons (disabled)
    - important: install fonts located [[https://github.com/domtronn/all-the-icons.el/tree/master/fonts][here]]
    #+begin_SRC emacs-lisp :tangle no
    ;; (use-package font-lock+)
    (when gb/use-space-line
      (use-package spaceline-all-the-icons
        :ensure t
        :after ( spaceline all-the-icons memoize) ;; indent-info
        ;; :defer 1
        :config
        ;; (spaceline-all-the-icons-theme)
        (custom-set-variables  '(spaceline-all-the-icons-highlight-file-name t)
                               '(spaceline-all-the-icons-separator-type (quote slant)) ;; cup, slant, wave, arrow
                               '(spaceline-all-the-icons-slim-render nil)
                               '(spaceline-all-the-icons-file-name-highlight t)
                               )

        (gb/do-after-display-system-init
         (progn
           (defun gb/warn-missing-font (font-name)
             "warn of font missing, if not found"
             (if (member font-name (font-family-list))
                 (message (concat "OK: font '" font-name "' is installed."))
               (message (concat "WARNING: make sure font '" font-name  "' is installed."))))

           (gb/warn-missing-font "all-the-icons")
           (gb/warn-missing-font "file-icons")
           (gb/warn-missing-font "FontAwesome")
           (gb/warn-missing-font "Material Icons")
           (gb/warn-missing-font "github-octicons")
           (gb/warn-missing-font "Weather Icons")

           (spaceline-install '((gb/buffer-status :face highlight-face)
                                ;; auto-compile
                                ;; buffer-size
                                gb/buffer-file-name
                                (gb/buffer-id :face highlight-face) ;; popup-menu-selection-face
                                ;; remote-host
                                (paradox-menu :when active)
                                ;; persp-name
                                ;; major-mode
                                ((flycheck-error flycheck-warning flycheck-info)
                                 :when active)
                                ((major-mode
                                  ;; all-the-icons-mode-icon
                                  ;; gb/projectile-id

                                  ;;  all-the-icons-projectile
                                  ;; (minor-modes :when active)
                                  (gb/version-control :when (not (string-match "magit.*" (symbol-name major-mode))))
                                  ;; all-the-icons-vc-icon
                                  ;; (all-the-icons-vc-status
                                  ;;  all-the-icons-git-ahead
                                  ;;   all-the-icons-git-status
                                  ;; :when (buffer-file-name))
                                  ;; all-the-icons-flycheck-status
                                  ;; all-the-icons-flycheck-status-info
                                  ;; all-the-icons-package-updates
                                  ))

                                ;; (erc-track :when active)
                                (process :when active)
                                (org-pomodoro :when active)
                                (org-clock :when active)
                                )

                              '(;; which-function
                                ;; (python-pyvenv :fallback python-pyenv)
                                ;; purpose



                                selection-info
                                ;; gb/indent-info-mode-line
                                ;; input-method
                                ((buffer-encoding-abbrev
                                  point-position
                                  line-column)
                                 :separator " ")
                                ;;(global :when active)
                                ((buffer-position
                                  hud))
                                (gb/date-and-cw :tight t :when active :face default-face)
                                ((all-the-icons-battery-status :tight t)
                                 ;; (all-the-icons-time :when active :tight t)
                                 (gb/time :when active :tight t)
                                 ;; (gb/symon :when active :tight t)
                                 ;; :separator (spaceline-all-the-icons--separator "|" " ") :face default-face
                                 )
                                ))

           (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
           (spaceline-all-the-icons--setup-anzu)
           ;; (symon--initialize)
           ))

        ;; (spaceline-all-the-icons--setup-paradox)
        ))
    #+END_SRC
*** rich minority mode (hide minor modes from smart mode line) (disabled, smart mode line not in use anymore)
    #+BEGIN_SRC emacs-lisp :tangle no
    (when gb/use-smart-mode-line
      (use-package rich-minority
        :config
        (progn
          (rich-minority-mode +1)
          (setq rm-blacklist
                '(
                  " $" ;; rich minority mode
                  " ARev" ;; auto revert mode
                  " ASE" ;; auto sudo edit
                  " Abbrev" ;;
                  " AceI" ;; ace-isearch-mode
                  " Anzu" ;; mode to display number of matches during reg ex search
                  " EditorConfig" ;;
                  " ElDoc overlay" ;; eldoc-overlay-mode
                  " ElDocOver" ;;
                  " ElDoc" ;; elisp documentation mode
                  " Fill" ;; auto-fill-mode
                  ;; " Fly" ;; flymake mode?
                  " GitGutter"
                  " Helm" ;; helm mode
                  " HidePW" ;; hide passwords in org mode files
                  " MRev"
                  " Org"
                  " OTSH" ;; org table sticky headers
                  ;; " Paredit" ;;
                  " Projectile" ;;
                  " PCRE" ;; perl like regular expressions everywhere
                  " SliNav" ;; slime navigation mode (C-, C-.)
                  " Undo-Tree"
                  " VHl" ;; volatile-highlights-mode (visual feedback to some operations related to regions)
                  " WK" ;; which key
                  " WLR" ;; whole line or region mode
                  " ^L" ;; display ^L as continuous line
                  " back" ;; back-button-mode (navigation local/global)
                  " company" ;; complete anything mode
                  " ez-esc" ;; easy-escape displays regular expressions in a more readable way
                  " h"
                  ;; " hs" ;; hide show (toggle block visibility)
                  " mate"
                  ;; " sel" ;; selected-minor-mode (provides extra keymap '' if a region is selected)
                  ;; " wb" ;; white space butler mode (removes trailing whitespaces on lines edited)
                  " wr" ;; wrap-region-mode, wraps a region with tags (e.g. '*' in org mode wraps marked region in ** )
                  " yas" ;; yasnippets
                  )))))
    #+END_SRC
*** smart mode line (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      (when gb/use-smart-mode-line

        ;; make sure the install question is not interactively placed!
        ;; (setq sml/no-confirm-load-theme t)
        ;; (setq powerline-arrow-shape 'curve)
        ;; (setq powerline-default-separator-dir '(right . left))
        ;; (setq sml/theme 'powerline)
        ;; (sml/setup)

        (use-package powerline
          :ensure t)
        (use-package smart-mode-line-powerline-theme
          :ensure t
          :after ( powerline)
          )
        (use-package smart-mode-line
          :after (powerline smart-mode-line-powerline-theme)
          :init (progn
                  (custom-set-faces
                   '(sml/read-only ((t (:inherit sml/not-modified :foreground "orange"))))
                   '(sml/folder ((t (:inherit sml/global :background "#282a2e" :foreground "dark gray" :weight normal))))
                   '(sml/git ((t (:inherit (sml/read-only sml/prefix) :background "#282a2e"))) )
                   '(sml/minor-modes ((t (:inherit sml/folder :foreground "dark gray"))))
                   '(sml/position-percentage ((t (:inherit sml/prefix :background "#373b41" :foreground "goldenrod" :weight normal))))
                   '(sml/read-only ((t (:inherit sml/not-modified :foreground "orange"))))
                   '(sml/vc ((t (:inherit sml/git :background "#373b41" :foreground "saddle brown"))))
                   '(sml/vc-edited ((t (:inherit sml/prefix :background "#373b41" :foreground "peru")))))
                  (add-hook 'after-init-hook 'sml/setup))
          :config
          (progn
            (setq sml/name-width 80) ;; max filename length

            ;; (defadvice switch-to-buffer (after switch-to-buffer-resize-mode-line-filename-space activate)
            ;;   "resize modeline to hold filenames"
            ;;   (progn
            ;;     (message (concat "switched and set " (number-to-string (max 40 (- (window-width) 90)))))
            ;;     (setq sml/name-width (max 40 (- (window-width) 90)))))

            (defun rm--mode-list-as-string-list ()
              '())
            (setq sml/mode-width 'full) ;; mode are to be displayed fully
            (setq sml/shorten-directory t)
            (setq sml/shorten-modes t)

            (setq sml/col-number-format "%3c")
            (setq sml/line-number-format "%4l")

            (setq sml/theme 'dark)

            (if after-init-time
                (progn
                  (sml/setup)
                  ))

            ;; add a hook to sml/after-setup-hook to modify mode-line-format
            ;; ("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification sml/pos-id-separator mode-line-position smartrep-mode-line-string
            ;; (vc-mode vc-mode)
            ;; sml/pre-modes-separator mode-line-modes mode-line-misc-info mode-line-end-spaces)


            ;; (require 'smart-mode-line-powerline-theme)
            ;; (sml/apply-theme 'dark)
            ;; Alternatives:
            ;; (sml/apply-theme 'powerline)
            ;; (sml/apply-theme 'dark)
            ;; (sml/apply-theme 'light)
            ;; (sml/apply-theme 'respectful)
            ;; (sml/apply-theme 'automatic)
            (setq powerline-default-separator 'arrow)
            ;; (setq powerline-default-separator-dir '(right . left))

            ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Projects/" ":iP:"))
            ;; (add-to-list 'sml/replacer-regexp-list '("^~/git/iMan3-Utilities/" ":iU:"))
            (add-to-list 'sml/replacer-regexp-list '("^~/Documents/clojure/workspace" ":clj:")))))

    #+END_SRC
*** fancy battery (for modeline) (disabled)
    Display of battery status in the emacs mode line (all the way to the left)
    See [[https://github.com/lunaryorn/fancy-battery.el][link]]
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package fancy-battery
      :ensure t
      :init (progn (add-hook 'after-init-hook #'fancy-battery-mode)))
    #+END_SRC
** rainbow mode
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-mode
     :ensure t
     :init (add-hook 'help-mode-hook #'rainbow-mode))
   #+END_SRC
** rainbow identifiers
   #+BEGIN_SRC emacs-lisp
   ;; can be switched off by M-x rainbow-identifiers-mode, which toggles the mode
   (use-package rainbow-identifiers
     :ensure t
     :init
     (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
   #+END_SRC
** cursor blinking / beacon
   - see https://github.com/Malabarba/beacon
   #+BEGIN_SRC emacs-lisp
     ;; mark cursor when switching buffers/windows/frames
     (use-package beacon
       :config
       (setq beacon-blink-when-window-scrolls nil)
       (setq beacon-blink-when-window-changes t)
       (setq beacon-blink-when-point-moves nil)
       (setq beacon-blink-when-point-moves-vertically nil)
       (setq beacon-push-mark nil)
       (beacon-mode 1)
       (bind-key "s-." #'beacon-blink)

       (defun gb/blink-if-not-shell (&rest args)
         "user for blinking on recenter, which shell mode does constantly => only in other modes"
         (unless (or (memq major-mode (list 'ansi-term-mode 'term-mode 'shell-mode 'comint-mode))
                    (string-prefix-p "slack" (symbol-name major-mode)))
           (ignore-errors
             (beacon-blink))))

       (advice-add 'recenter :after #'gb/blink-if-not-shell)
       (advice-add 'move-to-window-line-top-bottom :after #'gb/blink-if-not-shell))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package crosshairs
     :after (ace-window   ;; optional, install cursor blink after ace window switch
             helm)       ;; optional, install cursor blink after helm buffer switch
     :config
     (progn
       (defun blink-cursor-mode-off ()
         (blink-cursor-mode 0))

       (setq cursor-flash-timer nil)

       (defun cursor-flash (&optional seconds)
         "let cursor flash for three seconds"
         (interactive "P")
         (if cursor-flash-timer
             (cancel-timer cursor-flash-timer)) ; Cancel to prevent duplication.
         (blink-cursor-mode 0)
         (blink-cursor-mode 1)
         (let ((delay (or seconds 3)))
           (setq cursor-flash-timer (run-at-time
                                     delay nil
                                     #'blink-cursor-mode-off))))

       (defun cursor-ping (&optional seconds)
         (flash-crosshairs)
         (cursor-flash (or seconds 3)))

       ;; (toggle-crosshairs-when-idle t)
       (setq col-highlight-vline-face-flag  t
             col-highlight-face
             hl-line-face)

       (global-set-key (kbd "C-+") '(lambda (&optional u) (interactive) (cursor-ping 1)))

       (defadvice switch-to-buffer (after switch-to-buffer-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (when (package-installed-p 'helm)
         (defadvice helm-buffer-list (after helm-buffer-list-flash-crosshairs activate)
           "Call `flash-crosshairs' after `switch-to-buffer'"
           (cursor-ping 2)))

       (defadvice ns-next-frame (after ns-next-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after `switch-to-buffer'"
         (cursor-ping 2))

       (defadvice ns-prev-frame (after ns-prev-frame-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `ns-prev-frame'"
         (cursor-ping 2))

       (defadvice other-window (after other-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching through `other-window'"
         (cursor-ping 1))

       (defadvice delete-window (after delete-window-flash-crosshairs activate)
         "Call `flash-crosshairs' after switching because of `delete-window'"
         (cursor-ping 1))

       (when (package-installed-p 'ace-window)
         (defadvice ace-window (after ace-window-flash-crosshairs activate)
           "Call `flash-crosshairs' after switching with `ace-window'"
           (cursor-ping 1)))))
   #+END_SRC
** window arrangement
   - [[https://github.com/wasamasa/shackle][github]]
   - [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-shackle.el][example usage]]
   #+BEGIN_SRC emacs-lisp
   (use-package shackle
     :config
     (progn
       (shackle-mode 1)
       (setq shackle-rules
             '(
               ("*helm M-x*"            :align right :size 0.3)
               ("*helm imenu-anywhere*" :align right :size 0.5)
               ("*helm for files*"      :align right :size 0.5)
               ("*undo-tree*"           :align right :size 0.25)
               ))))
   #+END_SRC
** linenumbers
   #+BEGIN_SRC emacs-lisp
   (use-package nlinum
     :bind (("M-g M-g" . goto-line-with-feedback))
     :init (progn
             (defun goto-line-with-feedback ()
               "Show line numbers temporarily, while prompting for the line number input"
               (interactive)
               (unwind-protect
                   (progn
                     (setq display-line-numbers t)
                     (goto-line (read-number "Goto line: ")))
                 (setq display-line-numbers nil)))
             )
     :config
     (progn
       (setq linum-delay t)
       ;; (global-set-key [remap goto-line] 'goto-line-with-feedback)

       ;; (setq global-nlinum-mode t)
       ))
   #+END_SRC
** toggle serif font
   #+BEGIN_SRC emacs-lisp
     (defvar serif-preserve-default-list nil
       "A list holding the faces that preserve the default family and
       height when TOGGLE-SERIF is used.")

     (setq serif-preserve-default-list
           '(;; LaTeX markup
             font-latex-math-face
             font-latex-sedate-face
             font-latex-warning-face
             ;; org markup
             org-latex-and-related
             org-meta-line
             org-verbatim
             org-block-begin-line
             org-block-end-line
             org-block
             org-code
             org-hide
             org-indent
             ;;
             rainbow-identifiers-identifier-1
             rainbow-identifiers-identifier-2
             rainbow-identifiers-identifier-3
             rainbow-identifiers-identifier-4
             rainbow-identifiers-identifier-5
             rainbow-identifiers-identifier-6
             rainbow-identifiers-identifier-7
             rainbow-identifiers-identifier-8
             rainbow-identifiers-identifier-9
             rainbow-identifiers-identifier-10
             rainbow-identifiers-identifier-11
             rainbow-identifiers-identifier-12
             rainbow-identifiers-identifier-13
             rainbow-identifiers-identifier-14
             rainbow-identifiers-identifier-15

             rainbow-delimiters-depth-1-face
             rainbow-delimiters-depth-2-face
             rainbow-delimiters-depth-3-face
             rainbow-delimiters-depth-4-face
             rainbow-delimiters-depth-5-face
             rainbow-delimiters-depth-6-face
             rainbow-delimiters-depth-7-face
             rainbow-delimiters-depth-8-face
             rainbow-delimiters-depth-9-face
             ;; syntax highlighting using font-lock
             font-lock-builtin-face
             font-lock-comment-delimiter-face
             font-lock-comment-face
             font-lock-constant-face
             font-lock-doc-face
             font-lock-function-name-face
             font-lock-keyword-face
             font-lock-negation-char-face
             font-lock-preprocessor-face
             font-lock-regexp-grouping-backslash
             font-lock-regexp-grouping-construct
             font-lock-string-face
             font-lock-type-face
             font-lock-variable-name-face
             font-lock-warning-face))

     (defun toggle-serif ()
       "Change the default face of the current buffer to use a serif family."
       (interactive)
       (when (display-graphic-p)  ;; this is only for graphical emacs
         ;; the serif font familiy and height, save the default attributes
         (let ((serif-fam "Liberation Serif")
               (serif-height (if (eq gb/dual-screen-mode 'presentation)
                                 250
                               120))
               (default-fam (face-attribute 'default :family))
               (default-height (face-attribute 'default :height)))
           (if (not (bound-and-true-p default-cookie))
               (progn (make-local-variable 'default-cookie)
                      (make-local-variable 'preserve-default-cookies-list)
                      (setq preserve-default-cookies-list nil)
                      ;; remap default face to serif
                      (setq default-cookie
                            (face-remap-add-relative
                             'default :family serif-fam :height serif-height
                             :weight 'light
                             ))
                      ;; keep previously defined monospace fonts the same
                      (dolist (face serif-preserve-default-list)
                        (add-to-list 'preserve-default-cookies-list
                                     (face-remap-add-relative
                                      face :family default-fam :height default-height)))
                      (text-scale-increase 2)
                      (when (derived-mode-p 'org-mode)
                        (org-indent-mode 1))
                      (message "Turned on serif writing font."))
             ;; undo changes
             (progn (face-remap-remove-relative default-cookie)
                    (dolist (cookie preserve-default-cookies-list)
                      (face-remap-remove-relative cookie))
                    (setq default-cookie nil)
                    (setq preserve-default-cookies-list nil)
                    (text-scale-decrease 2)
                    (when (derived-mode-p 'org-mode)
                      (org-indent-mode -1))
                    (message "Restored default fonts."))))))
   #+END_SRC
** form feed
   - display ^L as h-bar
   #+BEGIN_SRC emacs-lisp
   (use-package form-feed
     :ensure t
     :init
     (progn (add-hook 'text-mode-hook #'form-feed-mode)))
   #+END_SRC
** hide show org like
   - if tab does not indent, folding is done
   #+BEGIN_SRC emacs-lisp
   (use-package hideshow-org
     :init (add-hook 'text-mode #'hs-org/minor-mode))
   #+END_SRC
** highlight indent
   - Minor mode to highlight indentation
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-indent-guides
       :ensure t
       :init ;; (add-hook 'prog-mode-hook #'highlight-indent-guides-mode)
       :config
       (progn
         (set-face-background 'highlight-indent-guides-odd-face "darkgray")
         (set-face-background 'highlight-indent-guides-even-face "dimgray")
         (setq highlight-indent-guides-character ?\|)
         (setq highlight-indent-guides-method 'character)))
   #+END_SRC
** own ui stuff
   #+BEGIN_SRC emacs-lisp
     (defun split-window-below-and-select-scratch (&optional arg)
       (interactive "P")
       (let* ((new-window (split-window-below)))
         (unless arg
           (set-window-buffer new-window "*scratch*"))
         (aw-switch-to-window new-window)
         new-window))
     (bind-key "C-x 2" 'split-window-below-and-select-scratch)

     (defun split-window-above-and-select-scratch (&optional arg)
       (interactive "P")
       (let* ((old-window (get-buffer-window))
              (new-window (split-window-below)))
         (unless arg
           (set-window-buffer old-window "*scratch*"))
         (aw-switch-to-window old-window)
         new-window))
     (bind-key "C-x C-2" 'split-window-above-and-select-scratch)

     (defun split-window-right-and-select-scratch (&optional arg)
       (interactive "P")
       (let* ((new-window (split-window-right)))
         (unless arg
           (set-window-buffer new-window "*scratch*"))
         (aw-switch-to-window new-window)
         new-window))
     (bind-key "C-x 3" 'split-window-right-and-select-scratch)

     (defun split-window-left-and-select-scratch (&optional arg)
       (interactive "P")
       (let* ((old-window (get-buffer-window))
              (new-window (split-window-right)))
         (unless arg
           (set-window-buffer old-window "*scratch*"))
         (aw-switch-to-window old-window)
         new-window))
     (bind-key "C-x C-3" 'split-window-left-and-select-scratch)
   #+END_SRC
* play startup sound (check again 3)
  #+begin_src emacs-lisp
    ;; if not playing test again and play 3
    (gb/play-startup-sound-when-ctrlkey-down)
  #+end_src
* editing related stuff
** selfinsertion on readonly modes
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; TODO: refactor macro to a normal function
     (defvar gb/selfinsert-modification-mode-ignore-list '(".*magit.*" ".*Magit.*")
       "list of mode regexes to ignore")
     (defvar gb/read-only-navigation-mode-exception-list '( "*eww*" )
       "list of buffer names that should not execute navigation commands in read only buffers!")

     (defmacro gb/selfinsertOrFunction (func)
       "execute selfinserting if buffer is r/w, else execute function passed"
       `(if (and buffer-read-only
                 (not (-first (lambda (reg) (string-match reg mode-name)) gb/selfinsert-modification-mode-ignore-list)))
            (,func)
          (self-insert-command 1)))

     (defmacro gb/selfInsertOrFunctionFiltered (func)
       "insert n if in a buffer that allows changes, else move down"
       `(if (-first (lambda (el) (string= el (buffer-name))) gb/read-only-navigation-mode-exception-list)
            (self-insert-command 1)
          (gb/selfinsertOrFunction ,func)))

     (defun gb/selfInsertOrNextLine ()
       "insert n if in a buffer that allows changes, else move down"
       (interactive)
       (gb/selfInsertOrFunctionFiltered next-line))

     (defun gb/selfInsertOrPreviousLine ()
       "insert n if in a buffer that allows changes, else move down"
       (interactive)
       (gb/selfInsertOrFunctionFiltered previous-line))

     ;; (bind-key "p" 'gb/selfInsertOrPreviousLine text-mode-map)
     ;; (bind-key "n" 'gb/selfInsertOrNextLine text-mode-map)
     (defun keymap-symbol (keymap)
       "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
       (catch 'gotit
         (mapatoms (lambda (sym)
                     (and (boundp sym)
                          (eq (symbol-value sym) keymap)
                          (not (eq sym 'keymap))
                          (throw 'gotit sym))))))
     (setq last-five-characters '(0 0 0 0 0 0))
     (setq old-ret-binding nil)
     (defun gb/filtered-insert-char (char window-class)
       (interactive)
       (if window-class
           (exwm-input--fake-key char)
         (when (not buffer-read-only)
           (self-insert-command 1)))
       (setq last-five-characters (cons char last-five-characters))
       (setq last-five-characters (-take 6 last-five-characters))
       ;; (message "lf: %s" last-five-characters)
       (when (or (equal '(110 101 104 99 117 107) last-five-characters)
                 (equal '(110 101 104 99 117 75) last-five-characters))
         (gb/lock-screen)))


     (defun gb/un-register-key-filter ()
       ;; (message "unregister filter key")
       (setq last-buffer-instrumented-key-filter nil)
       (bind-key "k" #'self-insert-command)
       (bind-key "K" #'self-insert-command)
       (bind-key "u" #'self-insert-command)
       (bind-key "c" #'self-insert-command)
       (bind-key "h" #'self-insert-command)
       (bind-key "e" #'self-insert-command)
       (bind-key "n" #'self-insert-command))

     (setq last-buffer-instrumented-key-filter nil)
     (defun gb/register-key-filter ()
       (if (and (not buffer-read-only) (not (s-contains? "magit" (buffer-name))) (not (string-prefix-p "magit" (symbol-name major-mode))))
           (when (not (string= (buffer-name) last-buffer-instrumented-key-filter))
             ;;(message "register filter key")
             (setq last-buffer-instrumented-key-filter (buffer-name))
             (bind-key "k" #'(lambda () (interactive) (gb/filtered-insert-char ?k nil)))
             (bind-key "K" #'(lambda () (interactive) (gb/filtered-insert-char ?K nil)))
             (bind-key "u" #'(lambda () (interactive) (gb/filtered-insert-char ?u nil)))
             (bind-key "c" #'(lambda () (interactive) (gb/filtered-insert-char ?c nil)))
             (bind-key "h" #'(lambda () (interactive) (gb/filtered-insert-char ?h nil)))
             (bind-key "e" #'(lambda () (interactive) (gb/filtered-insert-char ?e nil)))
             (bind-key "n" #'(lambda () (interactive) (gb/filtered-insert-char ?n nil))))
         (gb/un-register-key-filter)))


   #+END_SRC
** auto-fill-mode configuration
   - will word break / line break after column _
   #+BEGIN_SRC emacs-lisp
     (setq fill-column 140)
     (set-default 'fill-column 140)
     (set-default 'display-fill-column-indicator t)
     (set-default 'display-fill-column-indicator-character 9474)

     (cond
      ((eq gb/theme-mode 'light) nil) ;; TODO complete
      (t (progn
           (--each '((fill-column-indicator ((t (:foreground "gray13"))))
                     (fill-column-indicator-face ((t (:foreground "gray20")))))
             (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))

     (defun gb/enable-auto-fill-mode ()
       "enable auto-fill-mode regardless of current state"
       (auto-fill-mode +1))
   #+END_SRC
** keep some session stuff
   - will keep helm-M-x history after restart
   - will keep recent in file location even for org files
   #+begin_src emacs-lisp 
   (use-package session
     :init (add-hook 'after-init-hook 'session-initialize)
     :ensure t
     :config
     (progn
       (setq session-name-disable-regexp "\\(\\`/tmp\\|COMMIT_EDITMSG\\)")))
   #+end_src
** smart-region
   1. set mark, repetitive calls to M-x smart-region will call er/expand-region
   2. set mark, move up/down, stay in same column, call M-x smart-region will open mc/multiple-cursor on each line
      easier to reach via C-S-> and C-S-<
   3. set mark, move right/left/up/down, call M-x smart-region will make a rectangular selection
   #+begin_src emacs-lisp 
   (use-package smart-region
     ;; :commands smart-region
     :after (expand-region multiple-cursors)
     )
   #+end_src
** edit-indirect
   - edit region in separate buffer (and guess mode)
   #+begin_src emacs-lisp 
   (use-package edit-indirect
     ;; :commands edit-indirect-region edit-indirect-commit
     :ensure t)
   #+end_src
** autosave
   #+BEGIN_SRC emacs-lisp
   (setq auto-save-interval 500)
   #+END_SRC
** ws-butler
   - remove trailing whitespaces upon save (unobtrusively, that is only in lines actually changed)
   - [[https://github.com/lewang/ws-butler][home page]]
   #+BEGIN_SRC emacs-lisp
   (use-package ws-butler
     :ensure t
     :config
     (progn
       (ws-butler-global-mode 1)))
   #+END_SRC
** encoding
   #+BEGIN_SRC emacs-lisp
   (prefer-coding-system 'utf-8-unix)
   (set-default-coding-systems 'utf-8-unix)
   (set-terminal-coding-system 'utf-8-unix)
   (set-keyboard-coding-system 'utf-8-unix)
   (set-selection-coding-system 'utf-8-unix)
   (setq-default buffer-file-coding-system 'utf-8-unix)
   ;; (set-language-environment "UTF-8")
   #+END_SRC
** easy-escaping
   - display escaping \ (which is normaly doubled) as single red backslash
   #+BEGIN_SRC emacs-lisp
   (use-package easy-escape
     :ensure t
     :init (add-hook 'prog-mode-hook 'easy-escape-minor-mode)
     :config
     (progn
       (set-face-attribute 'easy-escape-face nil :foreground "red") ;; make a \\ stand out as red backslash
       ))
   #+END_SRC
** schrute mode (make suggestions) disabled
   #+begin_src emacs-lisp :tangle no
   (use-package schrute
     :disabled t
     :config
     (progn
       (defun msgavy ()
         (interactive)
         (message "try avy-goto-line"))
       (setf schrute-shortcuts-commands
             '((msgavy      . (next-line previous-line))))
       (schrute-mode)))
   #+end_src
** german umlaute
   - standard binding is C-x 8 " a|o|u|s
   - key-chords: hit a|u|o and e simultaneously => umlaut
   - other-key: hit C-" then a|u|o|s => umlaut,
   #+BEGIN_SRC emacs-lisp
   (progn
     (require 'bind-key)
     ;; (require 'key-chord)
     (bind-key "C-\" a" (lambda () (interactive) (insert "")))
     (bind-key "C-\' a" (lambda () (interactive) (insert "")))
     (bind-key "C-\" A" (lambda () (interactive) (insert "")))
     ;;(key-chord-define-global "AE" (lambda () (interactive) (insert "")))
     ;;(key-chord-define-global "ae" (lambda () (interactive) (insert "")))
     (bind-key "C-\" u" (lambda () (interactive) (insert "")))
     (bind-key "C-\' u" (lambda () (interactive) (insert "")))
     (bind-key "C-\" U" (lambda () (interactive) (insert "")))
     ;;(key-chord-define-global "UE" (lambda () (interactive) (insert "")))
     ;;(key-chord-define-global "ue" (lambda () (interactive) (insert "")))
     (bind-key "C-\" o" (lambda () (interactive) (insert "")))
     (bind-key "C-\' o" (lambda () (interactive) (insert "")))
     (bind-key "C-\" O" (lambda () (interactive) (insert "")))
     ;;(key-chord-define-global "OE" (lambda () (interactive) (insert "")))
     ;; (key-chord-define-global "oe" (lambda () (interactive) (insert "")))
     (bind-key "C-\" s" (lambda () (interactive) (insert "")))
     (bind-key "C-\' s" (lambda () (interactive) (insert "")))
     (bind-key "C-\" S" (lambda () (interactive) (insert ""))))
   #+END_SRC
** hungry delete (disabled, testing smart hungry delete)
   - delete all spaces before/after when using backspace/delete
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package hungry-delete
     :bind (( "C-S-d" . hungry-delete-forward)
            ( "S-<backspace>" . hungry-delete-backward)))
   #+END_SRC
** editing
   #+BEGIN_SRC emacs-lisp
     ;; No need for ~ files when editing
     (setq create-lockfiles nil)

     (bind-key "M-j" #'join-line)

     ;; Customizations relating to editing a buffer.
     ;; enable C-x C-u to do upcase on region (which is disabled by default)
     (put 'upcase-region 'disabled nil)
     (put 'downcase-region 'disabled nil)

     ;; display tabs as four spaces
     (setq default-tab-width 4)
     (setq tab-width 4)

     ;; indent all c and derived sources (java, groovy) with the basic 4 indent
     (defun gb/c-mode-hook ()
       (setq indent-tabs-mode nil
             c-basic-offset 4))
     (add-hook 'c-mode-common-hook 'gb/c-mode-hook)


     ;; make sure that C-k kills to the end of line and the whole line if cursor is at the start of the line
     (setq-default kill-whole-line t)

     ;; automatically reload open buffers if they changed on disk
     (global-auto-revert-mode 1)
     (set-default 'auto-revert-avoid-polling t) ;; avoid polling (may not work on remote filesystems)

     ;; make sure so long is used for e.g. minified files
     ;; see https://www.emacswiki.org/emacs/SoLong
     (when (version<= "27" emacs-version)
       (setq so-long-threshold 1024) ;; if line is longer than 1024, the enter so long mode
       (global-so-long-mode 1))

     ;; overwrite selected text
     (delete-selection-mode t)

     ;; Lisp-friendly hippie expand
     (setq hippie-expand-try-functions-list
           '(try-expand-dabbrev
             try-expand-dabbrev-all-buffers
             try-expand-dabbrev-from-kill
             try-complete-lisp-symbol-partially
             try-complete-lisp-symbol))

     ;; Highlights matching parenthesis
     (show-paren-mode 1)

     (cond
      ((eq gb/theme-mode 'light) nil) ;; TODO complete
      (t (progn
           (--each '((show-paren-match
                      ((t (:background "black"
                                       :foreground "yellow"
                                       :weight ultra-bold
                                       :width ultraexpanded)))))
                   (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))

     ;; Highlight current line
     (global-hl-line-mode 1)

     ;; make sure highlighting is extended to the eol even for emacs 27
     ;; within helm and magit (see https://github.com/emacs-helm/helm/issues/2213)
     (when (version< "26.3" emacs-version)
       (defun tv/extend-faces-matching (regexp)
         (cl-loop for f in (face-list)
                  for face = (symbol-name f)
                  when (and (string-match regexp face)
                            (eq (face-attribute f :extend t 'default)
                                'unspecified))
                  do (set-face-attribute f nil :extend t)))

       (when (fboundp 'set-face-extend)
         (with-eval-after-load "magit"
           (tv/extend-faces-matching "\\`magit"))
         (with-eval-after-load "helm"
           (tv/extend-faces-matching "\\`helm"))))

     ;; Don't use hard tabs
     (setq-default indent-tabs-mode nil)

     ;; after indent is ok, try to complete
     (setq tab-always-indent 'complete)
     (add-to-list 'completion-styles 'initials t)
     ;; Emacs can automatically create backup files. This tells Emacs to
     ;; put all backups in ~/.emacs.d/backups. More info:
     ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                    "backups"))))
     (setq auto-save-default nil)


     (use-package rainbow-delimiters
       :ensure t
       :init
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

     (defun die-tabs ()
       "remove all tabs within this buffer using spaces, interpreting a tab as 8 spaces"
       (interactive)
       (set-variable 'tab-width 8)
       (mark-whole-buffer)
       (untabify (region-beginning) (region-end))
       (keyboard-quit))

     ;; fix weird os x kill error
     (defun ns-get-pasteboard ()
       "Returns the value of the pasteboard, or nil for unsupported formats."
       (condition-case nil
           (ns-get-selection-internal 'CLIPBOARD)
         (quit nil)))

     (setq electric-indent-mode nil)

   #+END_SRC
** toggle commands (C-x t ...)
   #+BEGIN_SRC emacs-lisp
     (define-prefix-command 'gb/toggle-map)

     (defun gb/toggle-org-emphasis-markers ()
       "toggle org emphasis markers"
       (interactive)
       (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
       (font-lock-fontify-buffer))

     (defun gb/toggle-line-numbers ()
       ""
       (interactive)
       (setq display-line-numbers (not display-line-numbers)))
     ;; The manual recommends C-c for user keys, but C-x t is
     ;; always free, whereas C-c t is used by some modes.
     (define-key ctl-x-map "t" 'gb/toggle-map)
     (define-key gb/toggle-map "a" #'dired-du--toggle-human-readable)
     (define-key gb/toggle-map "b" #'gb/toggle-org-emphasis-markers)
     (define-key gb/toggle-map "c" #'column-number-mode)
     (define-key gb/toggle-map "d" #'toggle-debug-on-error)
     (define-key gb/toggle-map "e" #'toggle-debug-on-error)
     (define-key gb/toggle-map "f" #'auto-fill-mode)
     (when (fboundp 'gb/toggle-ligatures)
       (define-key gb/toggle-map "g" #'gb/toggle-ligatures))
     (define-key gb/toggle-map "h" #'highlight-thing-mode)
     (define-key gb/toggle-map "i" #'gb/toogle-highlight-what-thing)
     (define-key gb/toggle-map "k" #'flycheck-mode)
     (define-key gb/toggle-map "l" #'toggle-truncate-lines)
     (when (fboundp 'gb/toggle-visible-mark-mode)
       (define-key gb/toggle-map "m" #'gb/toggle-visible-mark-mode))
     (define-key gb/toggle-map "n" #'gb/toggle-line-numbers)
     (define-key gb/toggle-map "o" #'dired-omit-mode)
     (define-key gb/toggle-map "p" #'toggle-serif)
     (define-key gb/toggle-map "q" #'toggle-debug-on-quit)
     (define-key gb/toggle-map "r" #'toggle-word-wrap)
     (define-key gb/toggle-map "s" #'flyspell-mode)
     (define-key gb/toggle-map "u" #'gb/switch-dictionary)
     (define-key gb/toggle-map "v" #'eldoc-overlay-mode)
     (define-key gb/toggle-map "w" #'whitespace-mode)
     (define-key gb/toggle-map "5" #'toggle-frame-fullscreen)
   #+END_SRC
** browse kill ring
   - allow to browse kill ring via M-y and insert from arbitrary positions
   #+BEGIN_SRC emacs-lisp
   (use-package browse-kill-ring
     ;; bind M-y to interactively browsing the kill ring buffer
     :config
     (browse-kill-ring-default-keybindings))
   #+END_SRC
** save-place
   - When you visit a file, point goes to the last place where it
     was when you previously visited the same file.
   - http://www.emacswiki.org/emacs/SavePlace
   #+BEGIN_SRC emacs-lisp
   (if (not (version< emacs-version "25.0"))
       ;; for later emacs versions, save place is no separate package, but built in
       (progn (save-place-mode +1)
              (setq save-place-file (concat user-emacs-directory "places")))
     (use-package saveplace
       :config
       (progn
         (save-place-mode +1)
         ;; keep track of saved places in ~/.emacs.d/places
         (setq save-place-file (concat user-emacs-directory "places")))))
   #+END_SRC
** save on focus loss (inactive)
   - this function is run on focus out, which again is called when exwm switching buffers, which causes problems
     because the buffer switch is undone (focus jumps back to last exwm buffer)
   #+BEGIN_SRC emacs-lisp :tangle no
   (defun save-all ()
     (interactive)
     (save-some-buffers t))
   ;; (add-hook 'focus-out-hook 'save-all)
   #+END_SRC
** undo tree
   - C-x u opens the undo tree and lets you move through the tree of undo/redo
   #+BEGIN_SRC emacs-lisp 
   (use-package undo-tree
     :ensure t
     :config
     (progn
       ;; (setq undo-tree-auto-save-history t) ;; it seems that this feature regularly causes emacs to crash, if this history file cannot be read properly
       (setq undo-tree-visualizer-diff t) ;; display diff to previous
       (global-undo-tree-mode)))
   #+END_SRC
** very large files
   - edit very large files in chunks (see [[https://github.com/m00natic/vlfi][here]])
   #+BEGIN_SRC emacs-lisp
   (use-package vlf
     ;; :defer 7
     :config (require 'vlf-setup))
   #+END_SRC
** volatile hightlighting
   - highlight blocks associated with buffer commands until any key is pressed
     (e.g. highlight pasted text)
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "volatile-highlights")
      (use-package volatile-highlights
        :config
        (volatile-highlights-mode t)))
   #+END_SRC
** region related editing
*** wrap-region
    - works nicely together with expand region
    - simple mark a region and hit the key '(' e.g. to wrap marked region with parenthesis
    #+BEGIN_SRC emacs-lisp
    ;; wrap-region
    (use-package wrap-region
      :ensure t
      :config
      (progn
        (wrap-region-global-mode 1)
        (wrap-region-add-wrappers
         ;; default includes ( { [ ' ", so there is no need to define those
         '(("*" "*" nil (markdown-mode org-mode))
           ("~" "~" nil (markdown-mode org-mode))
           ("/" "/" nil (markdown-mode org-mode))
           ("=" "=" "+" (markdown-mode org-mode))
           ("_" "_" nil (markdown-mode org-mode))
           ("$" "$" nil (org-mode latex-mode))
           ("/*" "*/" "/" java-mode)))
        (add-to-list 'wrap-region-except-modes 'gnus-group-mode)
        (add-to-list 'wrap-region-except-modes 'gnus-summary-mode)  ;; don't remap / key, since it is used to limit mail list
        ;; hooks only useful if global region mode is not set (see above)
        ;; (add-hook 'org-mode-hook 'wrap-region-mode)
        ;; (add-hook 'latex-mode-hook 'wrap-region-mode)
        ;; (add-hook 'prog-mode 'wrap-region-mode)
        ))
    #+END_SRC
*** embrace region
    - embrace symbol/word ... with ", ', ( { [ ...
    - key binding is Press C-, a w ' to add '' to the current word:
    #+BEGIN_SRC emacs-lisp
    (use-package embrace
      :after ( expand-region)
      )
    #+END_SRC
*** change-inner
    #+BEGIN_SRC emacs-lisp
    (use-package change-inner
      :after ( expand-region)
      :init
      (defun gb/change-word ()
        "change word under cursor"
        (interactive)
        (er/mark-word)
        (delete-backward-char 1)
        (selected-off))
      :bind (("s-q c i" . change-inner) ;; bindung overwritten from somewhere
             ("s-q c o" . change-outer)
             ("s-q c w" . gb/change-word)))
    #+END_SRC
*** easy kill
    - see [[https://github.com/leoliu/easy-kill][here]]
    - M-w selects the following in the order of availability:
      active region, url, email and finally current line
    - M-w is also a prefix that can be followed by
      - w save word at point
      - b save buffer file name (including path) or default-directory
      - s save sexp at point
      - l save list at point (enclosing sexp)
      - d save defun at point
      - D save defun name at point
      - f save file at point
    - the following keys modify the selection (following the key above)
      - @ append selection to previous kill
      - C-w kill selection and exit
      - +, - and 1..9 expand/shrink the selection
      - 0 shrink selection to initial size
      - C-SPC turn selection into an active region
      - C-g abort
      - ? help
    #+BEGIN_SRC emacs-lisp
    (use-package easy-kill
      :ensure t
      :init (global-set-key [remap kill-ring-save] 'easy-kill))
    #+END_SRC
*** expand region
    expand / shrink region smartly
    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :bind (("C-x <up>" . er/expand-region)
               ("C-x <C-up>" . er/expand-region)
               ("C-x <down>" . er/contract-region)
               ("C-x <C-down>" . er/contract-region))
        ;; :after (key-chord) ;; optional, install key chords that do region expansion/shrink
        ;; :defer t ;; valid since init script registeres keys
        :init
        (autoload 'expand-region "er/expand-region" nil t)
        (autoload 'expand-region "er/contract-region" nil t)

        ;; (when (package-installed-p 'key-chord)
        ;;   (key-chord-define-global "+"   'er/expand-region) ;; make the current selection expand to the next outer bounds
        ;;   (key-chord-define-global "]["   'er/expand-region) ;; make the current selection expand to the next outer bounds
        ;;   (key-chord-define-global ".-"   'er/contract-region) ;; make the current selection collapse again into the inner bounds
        ;;   (key-chord-define-global "./"   'er/contract-region))
        )
    #+END_SRC
** subword (internal programming minor mode)
   #+BEGIN_SRC emacs-lisp
   (use-package subword
     )
   #+END_SRC
** multicursor
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :after ( hydra highlight-indent-guides)
       ;; bind currently does not work since some other project loads multiple cursors without req-package actually loading this!
       :bind (
              ;; When you have an active region that spans multiple lines, the following will
              ;; add a cursor to each line:
              ("C-S-c C-S-c" . mc/edit-lines)

              ;; When you want to add multiple cursors not based on continuous lines, but based on
              ;; keywords in the buffer, use:

              ("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C-c C-<" . mc/mark-all-like-this) ;; mark textually (even substrings)
              ("C-c C->" . mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
              )
       :config
       (progn
         ;; add a cursor to each line:
         ;; (bind-key "C-S-c C-S-c" 'mc/edit-lines)

         ;; When you want to add multiple cursors not based on continuous lines, but based on
         ;; keywords in the buffer, use:

         ;; (bind-key "C->" 'mc/mark-next-like-this)
         ;; (bind-key "C-<" 'mc/mark-previous-like-this)
         ;; (bind-key "C-c C-<" 'mc/mark-all-like-this) ;; mark textually (even substrings)
         ;; (bind-key "C-c C->" 'mc/mark-all-symbols-like-this) ;; mark more semantically (no substrings)
         (defhydra hydra-multiple-cursors ()
           "
                   ^Up^            ^Down^          ^Other^
                   ----------------------------------------------
                   [_p_]   Next    [_n_]   Next    [_l_] Edit lines
                   [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
                   [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
                   ^ ^             ^ ^             [_m_] Mark by avy
                   ^ ^             ^ ^             [_q_] Quit
               %s(hydra-combine-functions-w-key-bindings
                 '((\"    [p]   Up-Next       \" . mc/mark-previous-like-this)
                   (\"    [P]   Up-Skip       \" . mc/skip-to-previous-like-this)
                   (\"    [M-p] Up-Unmark     \" . mc/unmark-previous-like-this)
                   (\"    [n]   Down-Next     \" . mc/mark-next-like-this)
                   (\"    [N]   Down-Skip     \" . mc/skip-to-next-like-this)
                   (\"    [M-n] Down-Unmark   \" . mc/unmark-next-like-this)
                   (\"    [l]   Edit lines    \" . mc/edit-lines)
                   (\"    [a]   Mark all      \" . mc/mark-all-like-this)
                   (\"    [r]   Mark by regexp\" . mc/mark-all-in-region-regexp)
                   (\"    [m]   Mark by avy   \" . ace-mc-add-multiple-cursors)))
                   "
           ("l" mc/edit-lines :exit t)
           ("a" mc/mark-all-like-this :exit t)
           ("n" mc/mark-next-like-this)
           ("N" mc/skip-to-next-like-this)
           ("M-n" mc/unmark-next-like-this)
           ("p" mc/mark-previous-like-this)
           ("P" mc/skip-to-previous-like-this)
           ("M-p" mc/unmark-previous-like-this)
           ("r" mc/mark-all-in-region-regexp :exit t)
           ("m" ace-mc-add-multiple-cursors :exit t)
           ("q" (message "Abort") :exit t))))
   #+END_SRC
** IMPLEMENT ace-mc
   - mark multiple cursors using avy to jump to the places that should be multicursored!
     - available functions are: ace-mc-add-multiple-cursors
   #+BEGIN_SRC emacs-lisp
   (use-package ace-mc
     ;; :commands ace-mc-add-multiple-cursors ace-mc-add-single-cursor
     :bind (("C-|" . ace-mc-add-multiple-cursors))
     :after (avy multiple-cursors ace-jump-mode)
     :init (bind-key "C-|" #'ace-mc-add-multiple-cursors)
     )
   #+END_SRC
** key-chord (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package key-chord
       :config
       (progn
         (setq key-chord-two-keys-delay 0.07)
         (setq key-chord-one-key-delay 0.07)
         ;; (key-chord-mode 1)

         ;; (key-chord-define-global "hj"   'undo)

         ;; (key-chord-define-global "12"   'delete-other-windows) ;; key 12 is too often typed directly after each other => function is triggered unwanted
         ;; (key-chord-define-global "23"   'split-window-below)
         ;; (key-chord-define-global "34"   'split-window-right)
         ;; (key-chord-define-global "0"   'delete-window)

         ))
   #+END_SRC
** space-chord (currently disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; last time I had to install this via M-x el-get-list-packages before it actually started working
   ;; when using space as an alternative to control this will not work right
   (el-get-bundle space-chord)
   (use-package space-chord
     :loader :el-get
     :after ( key-chord)
     :config
     (progn
       (setq space-chord-delay 0.08)
       (space-chord-define-global "f" 'find-file) ;; just an example
       (space-chord-define-global "u" 'undo)
       ))
   #+END_SRC
** highlight thing
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-thing
       ;; :after ( key-chord) ;; optional, install key chord to highlight thing
       :init (progn
               ;; make sure that during marking words, the highlighting is switched (temporarily) off
               (add-hook 'activate-mark-hook 'highlight-thing-mode-temporary-off)
               (add-hook 'deactivate-mark-hook 'highlight-thing-mode-temporary-on))
       :config
       (progn
         (setq highlight-thing-delay-seconds 1)
         (setq highlight-thing-what-thing 'symbol)
         ;; customize face hi-yellow

         ;; highlight all identical 'words in view
         ;; (when (package-installed-p 'key-chord)
         ;;   (key-chord-define-global "\\'" (function highlight-thing-mode))
         ;;   (key-chord-define-global "#" (function highlight-thing-mode)))

         (setq highlight-thing-mode-temporary nil)

         (defun highlight-thing-mode-temporary-on ()
           "switch the tepmorary switched off mode on again (if it was on)"
           (interactive)
           (if highlight-thing-mode-temporary
               (progn
                 (setq highlight-thing-mode-temporary nil)
                 (highlight-thing-mode 1)
                 (highlight-thing-schedule-timer))))

         (defun highlight-thing-mode-temporary-off ()
           "switch highlight thing mode temporary off (if it was on)"
           (interactive)
           (let ((hlmode highlight-thing-mode))
             (if hlmode
                 (progn
                   (setq highlight-thing-mode-temporary t)
                   (highlight-thing-remove-last)
                   (highlight-thing-mode 0))
               )))

         ))
   #+END_SRC
** highlight symbol
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-symbol
     :bind (("C-c h" . highlight-symbol))
     :config
     (progn
       (setq  highlight-symbol-foreground-color "Gray52")))
   #+END_SRC
** bookmarking
   #+BEGIN_SRC emacs-lisp
   (use-package bm
     :ensure t
     :demand t
     :init
     ;; restore on load (even before you require bm)
     (setq bm-restore-repository-on-load t)

     :config
     ;; Allow cross-buffer 'next'
     (setq bm-cycle-all-buffers t)

     ;; where to store persistant files
     (setq bm-repository-file "~/.emacs.d/bm-repository")

     ;; save bookmarks
     (setq-default bm-buffer-persistence t)

     ;; Loading the repository from file when on start up.
     (add-hook 'after-init-hook 'bm-repository-load)

     ;; Saving bookmarks
     (add-hook 'kill-buffer-hook #'bm-buffer-save)

     ;; Saving the repository to file when on exit.
     ;; kill-buffer-hook is not called when Emacs is killed, so we
     ;; must save all bookmarks first.
     (add-hook 'kill-emacs-hook #'(lambda nil
                                    (bm-buffer-save-all)
                                    (bm-repository-save)))

     ;; The `after-save-hook' is not necessary to use to achieve persistence,
     ;; but it makes the bookmark data in repository more in sync with the file
     ;; state.
     (add-hook 'after-save-hook #'bm-buffer-save)

     ;; Restoring bookmarks
     (add-hook 'find-file-hooks   #'bm-buffer-restore)
     (add-hook 'after-revert-hook #'bm-buffer-restore)

     ;; The `after-revert-hook' is not necessary to use to achieve persistence,
     ;; but it makes the bookmark data in repository more in sync with the file
     ;; state. This hook might cause trouble when using packages
     ;; that automatically reverts the buffer (like vc after a check-in).
     ;; This can easily be avoided if the package provides a hook that is
     ;; called before the buffer is reverted (like `vc-before-checkin-hook').
     ;; Then new bookmarks can be saved before the buffer is reverted.
     ;; Make sure bookmarks is saved before check-in (and revert-buffer)
     (add-hook 'vc-before-checkin-hook #'bm-buffer-save)

     :bind
     ( "C-c b t" . bm-toggle)
     ( "C-c b n" . bm-next)
     ( "C-c b p" . bm-previous)
     ( "C-c b s" . bm-show)
     ( "C-c b S" . bm-show-all)
     ( "C-c b r" . bm-bookmark-regexp)
     ( "C-c b A" . bm-bookmark-annotate)
     ( "C-c b a" . bm-bookmark-show-annotation))
   #+END_SRC
** additional functions
   #+BEGIN_SRC emacs-lisp
   (when (functionp #'nxml-pretty-format)
     (defun gb/replace-buffer-with-yank ()
       "replace the whole buffer with the first item on the kill ring"
       (interactive)
       (erase-buffer)
       (yank)
       (if (string-prefix-p (buffer-substring 1 6) "<?xml")
           (nxml-pretty-format))))
   #+END_SRC
** aggressive indent mode (also used by parinfer)
   automatically indents all while typing 
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "aggressive-indent")
     (use-package aggressive-indent
       :config
       (progn ;; (global-aggressive-indent-mode 1) ;; enable mode for all programming modes
         (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
         ;;(add-to-list 'aggressive-indent-excluded-modes 'clojure-mode)
         ;;(add-to-list 'aggressive-indent-excluded-modes 'emacs-lisp-mode)
         ))) ;; disable mode for ...
   #+END_SRC
** with editor
   #+BEGIN_SRC emacs-lisp
   (use-package with-editor
     :after ( async))
   #+END_SRC
** selected (provide special keybindings if selections are active)
   - https://github.com/Kungsgeten/selected.el
   #+BEGIN_SRC emacs-lisp 
     (use-package selected
       :ensure t
       :hook (org-mode . selected-minor-mode) (prog-mode . selected-minor-mode)
       :config
       ;; override original, since hook is (somehow) not deregistered => selected active in all modes
       (defun selected--on ()
         "Enable `selected-region-active-mode'."
         (when (and (boundp 'selected-minor-mode)
                  selected-minor-mode) ;; additional check whether selected-minor-mode is active in this buffer!
           (selected-region-active-mode 1)))

       (bind-key "a" #'mc/mark-all-like-this selected-keymap)
       (bind-key "d" #'downcase-region selected-keymap)
       (bind-key "i" #'indent-region selected-keymap)
       (bind-key "m" #'mc/mark-more-like-this-extended selected-keymap)
       (bind-key "q" #'selected-off selected-keymap)
       (bind-key "u" #'upcase-region selected-keymap)
       (bind-key "w" #'count-words-region selected-keymap)
       (bind-key "<" #'mc/mark-previous-like-this selected-keymap)
       (bind-key ">" #'mc/mark-next-like-this selected-keymap)
       (bind-key "," #'mc/skip-to-previous-like-this selected-keymap)
       (bind-key "." #'mc/skip-to-next-like-this selected-keymap))
   #+END_SRC
** german umlaute with quail input method (switch with C-\)
   #+begin_src emacs-lisp
     (quail-define-package "gb/de-keyboard" "Deutsch (Umlaute etc.)" "DE+" t "umlaute durch *e" nil t nil nil nil nil nil nil nil nil t)
     (quail-define-rules ("AE" ?) ("ae" ?) ("AEE" ["AE"]) ("aee" ["ae"])
                         ("OE" ?) ("oe" ?) ("OEE" ["OE"]) ("oee" ["oe"])
                         ("UE" ?) ("ue" ?) ("UEE" ["UE"]) ("uee" ["ue"])
                         ("sz" ?) ("szz" ["sz"]))
   #+end_src
** common insert commands
   #+begin_src emacs-lisp
     (bind-key "C-c i t" #'org-time-stamp-inactive)
   #+end_src
* language specific stuff
** langtool (very! elaborate spellchecking)
   - instrument languagetool (see [[https://www.languagetool.org/][here]])
     installed via 'brew install languagetool'
   - description see [[https://github.com/mhayashi1120/Emacs-langtool][here]]
   - TODO: change interface to use json (thus some other details can be used for display)
     json parsing with elisp see [[http://tess.oconnor.cx/2006/03/json.el][here]]
     adjustments to (langtool--process-filter) will have to be made, in order to parse json results
   #+BEGIN_SRC emacs-lisp
   (when languagetool-installed
     (use-package langtool
       :after ( s)
       :commands (langtool-check
                  langtool-check-buffer
                  langtool-check-done
                  langtool-switch-default-language
                  langtool-show-message-at-point
                  langtool-correct-buffer)
       :init
       (progn
         (defun langtool-autoshow-detail-popup (overlays)
           (when (require 'popup nil t)
             ;; Do not interrupt current popup
             (unless (or popup-instances
                         ;; suppress popup after type `C-g` .
                         (memq last-command '(keyboard-quit)))
               (let ((msg (langtool-details-error-message overlays)))
                 (popup-tip msg)))))
         (setq langtool-autoshow-message-function
               'langtool-autoshow-detail-popup)
         )
       :config
       (when (is-_nix-p)
         (let ((jar-file (concat (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/^CP=\\(.*\\)/\\1/p'")) "/languagetool-commandline.jar")))
           (cond ((file-exists-p jar-file) (setq langtool-language-tool-jar jar-file))
                 ((file-exists-p "/usr/share/languagetool") (setq langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*"))
                 ((file-exists-p "~/bin/LanguageTool-4.3/languagetool-commandline.jar") (setq langtool-language-tool-jar "~/bin/LanguageTool-4.3/languagetool-commandline.jar"))
                 (t (message (format "ERROR: langtool jar not found at '%s' nor in any known location" jar-file))))))
       (when (is-macos-p)
         (let ((jar-file (s-trim (shell-command-to-string "cat `which languagetool` | sed -n 's/.*-jar.\\(.*\\) \".*/\\1/p'"))))
           (if (file-exists-p jar-file)
               (progn
                 (message "OK: langtool jar file found")
                 (setq langtool-language-tool-jar jar-file))
             (message (format "ERROR: langtool jar not found at '%s'" jar-file)))))

       (setq langtool-default-language "de")
       (setq langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))))
   #+END_SRC
** flyspell
   installation of ispell german dictionary:
   - arch linux:
     #+BEGIN_SRC bash :tangle no
     sudo pacman -S aspell-en aspell-de
     #+END_SRC
   - mac:
     - download from https://www.j3e.de/ispell/igerman98/
     - unpack, edit make file (remove unnecessary languages), execute make
     - copy *.hash from subdir ispell into /usr/local/Cellar/ispell/3.4.00/lib/ispell/ (e.g. de_DE.hash)
     - create link 'ln -s de_DE.hash deutsch.hash'
     - TODO: make gb/switch-dictionary use a variable for hooks that are all called when registration took place! langtool then only registers
       an additional hook. the hook should use well defined languages as parameters to let each hook what exactly to set
   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       ;; :after ( org)
       :init (progn
               (defun gb/activate-ispell-in-org-mode ()
                 "activate ispell and try to select to right language (e.g. `#+language: de')
       disable spell checking if `#+PROPERTY: spellcheck no' is set"
                 (let* ((spellCheck (gb/org-global-prop-value "spellcheck")))
                   (if (string= spellCheck "no")
                       (progn (flyspell-mode 0))
                     (require 'ox)
                     (let* ((fileLang (plist-get (org-export--get-inbuffer-options) :language)))
                       (if (string= fileLang "de")
                           (ispell-change-dictionary "deutsch8")
                         (ispell-change-dictionary "english"))
                       (turn-on-flyspell)))))

               ;; switch between german and english dicionary
               (defun  gb/switch-dictionary()
                 (interactive)
                 (let* ((oldLang ispell-current-dictionary)
                        (newLang (if (string= oldLang "deutsch8") "english" "deutsch8"))
                        (oldLangtool (if (boundp 'langtool-default-language) langtool-default-language nil))
                        (newLangtool (if (string= oldLangtool "de") "en-US" "de")))
                   (ispell-change-dictionary newLang)
                   (if (boundp 'langtool-default-language) (setq langtool-default-language newLangtool))
                   (message "Dictionary switched from `%s' to `%s'" oldLang newLang)))

               (defun gb/set-dictionary (lang)
                 "set language used for spell checking, lang = {de|en}"
                 (ispell-change-dictionary (cond ((string= lang "de") "deutsch8")
                                                 ((string= lang "en") "english")
                                                 (t "english")))
                 (if (boundp 'langtool-default-language)
                     (setq langtool-default-language
                           (cond ((string= lang "de") "de")
                                 ((string= lang "en") "en-US")
                                 (t "en-US")))))

               ;; (add-hook 'message-mode-hook 'turn-on-flyspell)
               ;; (add-hook 'org-mode-hook 'gb/activate-ispell-in-org-mode)
               )
       :bind (("C-x l" . gb/switch-dictionary))
       :config
       (progn
         (require 'ox)
         (setq ispell-dictionary "deutsch8")
         (setq ispell-local-dictionary "deutsch8")
         (setq flyspell-default-dictionary "deutsch8")

         ;; for programmiong modes, switch to english and activate flyspell-prog-mode
         ;; (dolist (hook '(prog-mode-hook))
         ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "english")(flyspell-prog-mode 1)))))

         ;; for orgmode, switch to english and activate flyspell
         ;; (dolist (hook '(org-mode-hook))
         ;;   (add-hook hook (lambda () (flyspell-mode 1))))

         ;; for mails, switch to german dictionary and activate flyspell
         ;; (dolist (hook '(message-mode-hook))
         ;;   (add-hook hook (lambda () (progn (ispell-change-dictionary "deutsch8")(flyspell-mode 1)))))

         ;; don't print error message for every mispelled word found
         (setq flyspell-issue-message-flag nil)


         ))
   #+END_SRC
** dictionary
   - description [[http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary][here]]
   - downloaded from [[https://github.com/gucong/emacs-sdcv][here]]
   - use dictionary in startdict format from ~/.stardict/dic
   #+BEGIN_SRC emacs-lisp
   (if (file-exists-p "~/.emacs.d/additionals/sdcv-mode.el")
       (use-package sdcv-mode
         :commands sdcv-search
         :load-path "~/.emacs.d/additionals"))
   #+END_SRC
** look up definition
   - 'H-d' (it's fn-d on mac) will lookup (english) definition of the word at point
   - 'H-D' will query for the word to find the definition for
   #+BEGIN_SRC emacs-lisp
   (use-package define-word
     :bind (("H-d" . define-word-at-point)
            ("H-D" . define-word)))
   #+END_SRC
* auto complete, help, man etc.
** helpful
   - allow for additional help information for functions
   #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :ensure t
       :commands (helpful-macro helpful-callable helpful-function helpful-command helpful-variable helpful-at-point)
       :bind ("s-h" . helpful-at-point)
             ("C-h f" . helpful-callable)
             ("C-h v" . helpful-variable))
   #+END_SRC
** which key
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :config
       (progn
         (bind-key "C-h y" #'which-key-show-top-level)
         (setq which-key-idle-secondary-delay 0.05)
         (which-key-mode)
         (which-key-setup-side-window-right)
         (validate-setq which-key-side-window-max-width 0.4)
         (setq which-key-max-description-length 45)
         (setq which-key-popup-type 'side-window)
         ))
     (use-package which-key-posframe
       :ensure t
       :config
       (setq which-key-posframe-poshandler 'gb/posframe-poshandler-frame-center)
       (setq which-key-posframe-min-width 60)
       (setq which-key-posframe-min-height 50)
       (setq which-key-posframe-width 60)
       (setq which-key-posframe-height 50)
       (defun gb/which-key-set-posframe-parameters ()
         "set which-key-posframe parameters. run previous to display, to ensure right display in multimonitor environments"
         (setq gb/posframe-offset (cdr (assoc 'left (frame-parameters (selected-frame)))))
         (setq which-key-posframe-parameters
               `((parent-frame)                                                          ;; (works only on single monitor)
                 (display . ,(cdr (assoc 'display (frame-parameters (selected-frame))))) ;; (hopefully holds display of current monitor)
                 (font . ,(cdr (assoc 'font (frame-parameters (selected-frame)))))
                 (alpha 90 90)
                 (left-fringe . 10)
                 (right-fringe . 10))
                 ))
       (advice-add 'which-key-posframe--show-buffer :before #'(lambda (orig-func &rest args) (gb/which-key-set-posframe-parameters)))
       ;; (which-key-posframe-mode)
       )
   #+END_SRC
** keyfreq
   #+BEGIN_SRC emacs-lisp
   (use-package keyfreq
     :config
     (progn
       (keyfreq-mode 1)
       (keyfreq-autosave-mode 1)
       ;; use M-x keyfreq-show to show the frequency of key usages
       ))
   #+END_SRC
** company
   #+BEGIN_SRC emacs-lisp
     (use-package company-try-hard
       :ensure t
       ;; :after (company)
       :config
       (progn
         (global-set-key (kbd "M-TAB") #'company-try-hard)
         (global-set-key (kbd "<C-tab>") #'company-try-hard)
         (global-set-key (kbd "M-/") #'company-try-hard)
         (define-key company-active-map (kbd "M-TAB") #'company-try-hard)
         ))

     (use-package company-box
       :ensure t
       :after (company)
       :hook (company-mode . company-box-mode)
       :config
       (progn
         (defun gb/company-box-doc--init-frame-parameter (orig-func &rest args)
           "initialize frame parameter to ensure that the frame is always recreated"
           (company-box-doc--hide (selected-frame))
           (frame-local-setq company-box-doc-frame nil)
           ;; (set-frame-parameter nil 'company-box-doc-frame nil) ;; necessary for old company-box version < company-box-20200909.714
           )
         (advice-add 'company-box-doc--show :before #'gb/company-box-doc--init-frame-parameter)
         ;; (advice-remove 'company-box-doc--show #'gb/company-box-doc--init-frame-parameter)
         (setq company-box-enable-icon t)
         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (--each '((company-box-background ((t (:foreground "grey80" :background "gray12"))))
                         (company-box-scrollbar ((t (:inherit company-tooltip-selection :background "grey30"))))
                         (company-box-candidate ((t (:foreground "gray85")))))
                 (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))

     (use-package company
       ;; :after (selected)
       :ensure t
       :init (progn
               (add-hook 'after-init-hook 'global-company-mode))
       :config
       (progn
         (setq company-idle-delay nil)
         (setq company-show-numbers nil)
         ;; use numbers 0-9 to select company completion candidates
         (let ((map company-active-map))
           (mapc (lambda (x) (define-key map (format "%d" x)
                          `(lambda () (interactive) (company-complete-number ,x))))
                 (number-sequence 0 9)))

         ;; this will make company be used tab completion (if no indenting needs to take place)
         (global-set-key (kbd "TAB") #'company-indent-or-complete-common)
         (setq company-minimum-prefix-length 4)
         (setq company-tooltip-limit 15)
         (setq company-tooltip-flip-when-above t)
         (setq company-dabbrev-downcase nil) ;; make company suggestions case sensitive (no downcase conversion)
         (setq company-backends
               (quote
                (company-capf company-shell company-bbdb company-semantic company-files
                              company-dabbrev-code company-gtags company-etags company-keywords
                              company-oddmuse company-dabbrev)))
         (setq company-dabbrev-code-modes
               (quote
                (prog-mode
                 batch-file-mode
                 css-mode
                 ;; erlang-mode
                 ;; haskell-mode
                 ;; jde-mode
                 ;; lua-mode
                 ;; python-mode
                 clojure-mode
                 ;; scala-mode
                 )))

         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (message "customize faces - company")
               (--each '((company-echo-common ((t (:inherit company-echo :foreground "gray15"))))
                         (company-preview ((t (:foreground "gray15"))))
                         (company-preview-common ((t (:foreground "tomato2"))))
                         (company-tooltip ((t (:background "gray12" :foreground "gray85"))))
                         (company-tooltip-selection ((t (:background "gray23" :foreground "white"))))
                         (company-tooltip-common ((t (:foreground "firebrick4"))))
                         (company-tooltip-annotation ((t (:foreground "gray15")))))
                 (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
         ))

     (use-package company-statistics
       :ensure t
       ;; :after (company)
       :init
       (progn
         (add-hook 'after-init-hook 'company-statistics-mode)))

   #+END_SRC
** company flx
   #+BEGIN_SRC emacs-lisp
   (use-package company-flx
     :ensure t
     :after (company)
     :config
     (with-eval-after-load 'company (add-hook 'company-mode-hook (lambda () (add-to-list 'company-backends 'company-capf))) (company-flx-mode +1)))
   #+END_SRC
** IMPLEMENT company-shell
   - provide company help for fish (or other shell) completions within modes like (fish-mode, shell-mode)
   #+BEGIN_SRC emacs-lisp
   (use-package company-shell
     :ensure t
     :after (company)
     :config (add-to-list 'company-backends 'company-shell))
   #+END_SRC
** helm-company (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (eq gb/completion-framework 'helm)
       (use-package helm-company
         :ensure t
         :after ( helm company)
         :bind (:map company-mode-map
                     ("C-:" . helm-company)
                     :map company-active-map
                     ("C-:" . helm-company))))
   #+END_SRC
** helm-descbind
   - describe current keybindings with helm interface
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-descbinds
         :ensure t
         :after (helm company)
         :bind (("\C-h b" . helm-descbinds))))
   #+END_SRC
** helm-dash
   - add new sources for helm dash via helm-dash-install-docset
   - browse doc set via helm-dash
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-dash
         :bind (("\C-z SPC d" . helm-dash-at-point))
         :after ( helm)
         :init (progn
                 (defun clojure-dash-doc ()
                   (interactive)
                   (setq-local helm-dash-docsets '("Clojure")))


                 (defun java-dash-doc ()
                   (interactive)
                   (setq-local helm-dash-docsets '("Java_SE8")))


                 (defun bash-dash-doc ()
                   (interactive)
                   (setq-local helm-dash-docset '("Bash")))


                 (add-hook 'clojure-mode-hook 'clojure-dash-doc)
                 (add-hook 'java-mode-hook 'java-dash-doc)
                 (add-hook 'shell-mode-hook 'bash-dash-doc)
                 )
         :config
         (progn
           (if w3m-installed
               (setq helm-dash-browser-func 'w3m-browse-url))
           (setq helm-dash-docsets '("Bash"
                                     "Clojure"
                                     "Docker"
                                     "Emacs Lisp"
                                     "Groovy"
                                     "Groovy JDK"
                                     "Gradle Groovy API"
                                     "Gradle DSL"
                                     "Gradle User Guide"
                                     "Java"
                                     "LaTeX"
                                     "PostgreSQL"
                                     "Vagrant"
                                     "XSLT")))))
   #+END_SRC
*** Installing docsets

    Helm-dash uses the same docsets as Dash. You can install them with
    m-x helm-dash-install-docset for the official docsets or m-x
    helm-dash-install-user-docset for user contributed docsets
    (experimental).

    To install a docset from a file in your drive you can use m-x
    helm-dash-install-docset-from-file'. That function takes as input
    atgzfile that you obtained, starting from a folder named.docset`,
    with the command:

    tar --exclude='.DS_Store' -cvzf <docset name>.tgz <docset name>.docset

    as explained here.
** dash at point
   #+BEGIN_SRC emacs-lisp
   (use-package dash-at-point
     :bind (("C-z SPC h d" . dash-at-point-with-docset)
            ("C-z SPC h D" . dash-at-point)))
   #+END_SRC
** helm-swoop
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-swoop
         :ensure t
         :bind (("C-S-s" . helm-swoop)
                ("C-M-S-s" . helm-multi-swoop-all))
         :after (helm)
         :config
         (setq helm-swoop-split-direction (quote split-window-horizontally))))
   #+END_SRC
** pos tip
   #+BEGIN_SRC emacs-lisp
   (use-package pos-tip
     :ensure t)
   #+END_SRC
** help at point
   - show help in modeline to text that is propertized as button... (e.g. in customize-.... modes)
   - the timer will make the help appear after x seconds (can be a float)
   #+BEGIN_SRC emacs-lisp
     (use-package help-at-pt
       ;; :ensure t ;; internal packages seem not load correctly if ensured
       :config
       (progn
         (custom-set-variables '(help-at-pt-display-when-idle (quote (kbd-help button local-map keymap)) nil (help-at-pt)))
         (setq help-at-pt-timer-delay 1)
         (help-at-pt-set-timer)))
   #+END_SRC
* navigation
** iy-go-to-char
   - prompts for a character and the jumps forward/backward to the next occurrance of that char
   #+BEGIN_SRC emacs-lisp
   (use-package iy-go-to-char
     :bind (
            ("C-c f" . iy-go-to-char)
            ("C-c F" . iy-go-to-char-backward)))
   #+END_SRC
** ace and avy
   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :ensure t
       :after (gnus)
       :bind (
              ;; bind within org mode
              :map org-mode-map
              ("M-o" . ace-link-org)
              ;; bind within gnus
              :map gnus-summary-mode-map
              ("M-o" . ace-link-gnus)
              :map gnus-article-mode-map
              ("M-o" . ace-link-gnus))
       :config
       (progn
         ;; bind "o" within info, help, woman, eww compilation and custom mode
         (ace-link-setup-default)))

     (use-package ace-window  ;; select open window with one key
       ;; :after ( key-chord) ;; optional, key binding
       :ensure t
       :init
       (progn
         (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
         ;; (when (package-installed-p 'key-chord)
         ;;   (key-chord-define-global "o0"   'ace-window))
         ))

     (use-package ace-flyspell
       :ensure t
       :after ( flyspell avy))
     ;; available commands 'M-x ace-flyspell-jump-word', jump to incorrect spelling via ace
     ;; 'M-x ace-flyspell-dwim', autocorrect word
     ;; 'M-x ace-flyspell-correct-word', no jump but autocorrect

   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package ace-isearch
     :ensure t
     :after ( avy ace-jump-mode)
     :disabled t
     :config
     (progn
       (setq ace-isearch-function (quote avy-goto-word-1)) ;; use thus function if only one character was searched for
       ;; (setq ace-isearch-input-length 3) ;; start helm swoop at a length of 3 characters
       ;; (setq ace-isearch-jump-delay 0.35)
       (setq ace-isearch-use-jump (quote printing-char))

       ;; Enable global ace-isearch mode:
       (global-ace-isearch-mode +1)

       ;; Enable ace-isearch minor mode:
       ;; (ace-isearch-mode +1)

       (when (package-installed-p 'bind-key)
         ;; when in search mode, hit C-' to jump to single char!
         (bind-key "C-'" 'ace-isearch-jump-during-isearch isearch-mode-map)

         (bind-key "C-S-s" 'isearch-forward)
         (bind-key "C-S-r" 'isearch-backward))))

   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :bind (("C-S-SPC" . avy-goto-char-timer)
              ("C-c SPC" . avy-goto-char-timer)
              ("C-c C-SPC" . avy-goto-char-timer)
              ("C-x SPC" . avy-pop-mark)
              ("C-x C-SPC" . avy-pop-mark))
       :config
       (progn
         (setq avy-background t)
         (setq avy-keys (number-sequence ?a ?z))
         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (--each '((avy-lead-face ((t (:foreground "red"))))
                         (avy-lead-face-0 ((t (:foreground "orange"))))
                         (avy-lead-face-1 ((t (:foreground "yellow"))))
                         (avy-lead-face-2 ((t (:foreground "white")))))
                 (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))

     (use-package avy-zap
       :ensure t
       :after ( avy)
       :bind
       (("M-Z" . avy-zap-to-char-dwim)
        ("M-z" . avy-zap-up-to-char)))
   #+END_SRC
** ace popup menu
   - display regular popup windows (like the one upon C-c $ to correct mispelled words) as a text window (in separate emacs window)
   #+BEGIN_SRC emacs-lisp
   (use-package avy-menu)
   (use-package ace-popup-menu
     :after ( avy avy-menu)
     :ensure t
     :config (ace-popup-menu-mode 1))
   #+END_SRC
** search cursor left
   - C-RET after searching via C-s will leave cursor at start of match
   - RET after searching via C-s will leave cursor at end of match
   #+BEGIN_SRC emacs-lisp
   (define-key isearch-mode-map [(control return)]
     #'isearch-exit-other-end)
   (defun isearch-exit-other-end ()
     "Exit isearch, at the opposite end of the string."
     (interactive)
     (isearch-exit)
     (goto-char isearch-other-end))
   #+END_SRC
** visible mark
   - make the last (2) marks visible (orange, yellow)
   - C-x C-x exchanges point and mark, spanning a region between the two
   - C-space sets the mark, marks are put into a ring
   - back-button allows navigation throught the mark buffer positions
   - STATUS: produces errors on post command hooks (default is disabled)
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "visible-mark")
     (use-package visible-mark
       :init
       (defface visible-mark-active ;; put this before (require 'visible-mark)
         '((((type tty) (class mono)))
           (t (:background "magenta"))) "")
       (setq visible-mark-max 2)
       (setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))
       (defun gb/toggle-visible-mark-mode ()
         "toggle visible mark mode"
         (if (bound-and-true-p visible-mark-mode)
             (visible-mark-mode -1)
           (visible-mark-mode t)))
       :config
       (global-visible-mark-mode -1) ;; disable visible mark mode globally (until explicitly toggled for a mode)
       ;; or add (visible-mark-mode) to specific hooks
       ))
   #+END_SRC
** back-button
   - currently disabled, since it depends (transitively on pcache, which takes eons during kill-emacs-hooks execution)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package back-button
     ;; :ensure back-button ;; has currently problems compiling
     :after ( hydra)
     :config
     (progn

       ;;--------------------------------------------------------------------------------
       (defhydra hydra-navigate-history ()
         "
               Navigate through location history
               ---------------------------------
               [_p_] back local    [_n_] forward local
               [_P_] back global   [_N_] forward global
               ^ ^                 [_q_] quit

           %s(hydra-combine-functions-w-key-bindings
             '((\"    back local     \" . back-button-local-backward)
               (\"    back global    \" . back-button-global-backward)
               (\"    forward local  \" . back-button-local-forward)
               (\"    forward global \" . back-button-global-forward)))
               "
         ("p" back-button-local-backward :color green)
         ("P" back-button-global-backward )
         ("n" back-button-local-forward )
         ("N" back-button-global-forward )
         ("q" (message "Abort") :exit t))

       (back-button-mode 1)))
   #+END_SRC
** jumplist
   #+BEGIN_SRC emacs-lisp
   (use-package jumplist
     :ensure t
     :bind (
            ("C-," . jumplist-previous)
            ("C-." . jumplist-next))
     :config
     (custom-set-variables
      '(jumplist-hook-commands
        '(helm-swoop helm-for-files helm-find-files
                     dired-jump
                     find-file
                     isearch-forward-regexp isearch-forward
                     end-of-buffer beginning-of-buffer
                     elisp-slime-nav-find-elisp-thing-at-point
                     find-tag
                     eclim-java-find-declaration eclim-java-find-references eclim-java-find-generic eclim-java-find-type
                     cider-find-resource cider-find-file cider-find-var cider-find-var-file))))
   #+END_SRC
** region-state
   - Show the number of chars/lines or rows/columns in the region
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "region-state")
     (use-package region-state
       :config
       (region-state-mode 1)))
   #+END_SRC
** goto last change
   #+BEGIN_SRC emacs-lisp
   (use-package goto-chg
     :ensure t
     :bind (
            ("C-c b ," . goto-last-change)
            ("C-c b ." . goto-last-change-reverse)))
   #+END_SRC
** smart scan (jump to next/prev of symbol)
   #+BEGIN_SRC emacs-lisp
   (use-package smartscan
     :ensure t
     :config
     (progn
       (global-smartscan-mode +1)
       (setq smartscan-symbol-selector "symbol")))
   ;; (smartscan-mode 1)
   ;; use M-p to jump to previous location of that symbol
   ;; use M-n to jump to net location of that symbol
   #+END_SRC
** anzu (searching regexp with hit count)
   #+BEGIN_SRC emacs-lisp
     ;; display # of matches in modeline when searching
     (use-package anzu
       :ensure t
       :config
       (global-anzu-mode +1)
       (setq anzu-search-threshold 1000)
       (setq anzu-minimum-input-length 3))
   #+END_SRC
** other (recentf, uniquify)
   #+BEGIN_SRC emacs-lisp
     ;; These customizations make it easier for you to navigate files,
     ;; switch buffers, and choose options from the minibuffer.

     ;; "When several buffers visit identically-named files,
     ;; Emacs must give the buffers distinct names. The usual method
     ;; for making buffer names unique adds <2>, <3>, etc. to the end
     ;; of the buffer names (all but one of them).
     ;; The forward naming method includes part of the file's directory
     ;; name at the beginning of the buffer name
     ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html
     (use-package uniquify
       :config
       (setq uniquify-buffer-name-style 'forward))

     ;; Turn on recent file mode so that you can more easily switch to
     ;; recently edited files when you first start emacs
     (use-package recentf
       ;; :ensure t ;; internal packages seem not load correctly if ensured
       :config
       (progn
         (setq recentf-save-file (concat user-emacs-directory ".recentf"))
         ;; since recentf file may grow large, delete it if too large
         (shell-command (s-concat "touch " recentf-save-file))
         (let ((rsf-size-str (s-trim (shell-command-to-string (s-concat "ls -la " recentf-save-file " | awk '{ print $5; }'")))))
           (if (<= 10000 (string-to-number rsf-size-str))
               (progn
                 (message (s-concat "deleting too large recentf file '" recentf-save-file "' ( size: " rsf-size-str ")"))
                 (shell-command (s-concat "rm " recentf-save-file)))))
         (setq recentf-exclude (list "^.*/\\.emacs\\.d/.*"))
         (setq recentf-max-menu-items 40)
         (recentf-mode 1)))
   #+END_SRC
** swiper and ivy
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'ivy)
       (require 'comint)
       (use-package ivy
         :ensure t
         :bind (:map ivy-mode-map
                     ("M-y" . #'counsel-yank-pop))
         :config
         (defface ivy-current-match
           '((((class color) (background light))
              :background "#1a4b77" :foreground "white")
             (((class color) (background dark))
              :background "#65a7e2" :foreground "black"))
           "Face used by Ivy for highlighting first match.")

         (setq ivy-display-style 'fancy)

         (defun gb/ivy-partial-or-done ()
           (interactive)
           (or (ivy-partial)
              (ivy-alt-done)))

         (define-key ivy-minibuffer-map (kbd "TAB") 'gb/ivy-partial-or-done)


         :init
         (defun gb/collect-external-commands (sort)
           "collect external commands"
           (cl-loop
            for dir in (split-string (getenv "PATH") path-separator)
            when (and (file-exists-p dir) (file-accessible-directory-p dir))
            for lsdir = (cl-loop for i in (directory-files dir t)
                                 for bn = (file-name-nondirectory i)
                                 when (and (not (member bn completions))
                                         (not (file-directory-p i))
                                         (file-executable-p i))
                                 collect bn)
            append lsdir into completions
            finally return
            (if sort (sort completions 'string-lessp) completions)))

         (defvar gb/external-commands nil)

         (defun gb/exwm--switch-or-run-sel (program &optional alias)
           "switch to this program if already open or start it"
           ;; (exwm-reset)
           (unless (gb/exwm--switch program alias)
             (start-process-shell-command program nil program)
             (run-at-time 1 nil `(lambda () (gb/exwm--switch ,program)))))

         (defun gb/ivy--program-select-and-run ()
           (interactive)
           (unless gb/external-commands
             (setq gb/external-commands (remove-duplicates (gb/collect-external-commands nil))))
           (gb/exwm--switch-or-run-sel
            (completing-read "RunProgram: " gb/external-commands nil t)))

         :bind (( "C-x C-b" . ivy-switch-buffer) ;; exwm-workspace-switch-to-buffer
                ( "s-1"     . gb/ivy--program-select-and-run))
         :config
         (setq ivy-height 45))
       (use-package ivy-prescient
         :ensure t
         :config
         (ivy-prescient-mode 1))
       (use-package swiper
         :ensure t
         :after ( ivy)
         :bind (( "s-s" . swiper)))
       (use-package ivy-rich
         :ensure t
         :config
         (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
         (memoize #'ivy-rich-switch-buffer-project 5)
         (memoize #'ivy-rich-switch-buffer-path 5))
       (use-package all-the-icons-ivy
         :ensure t)
       (use-package all-the-icons-ivy-rich
         :config
         (setq ivy-rich-display-transformer--buffer
               '(:columns
                  ((all-the-icons-ivy-rich-buffer-icon)
                   (ivy-rich-candidate
                    (:width 40))
                   (ivy-rich-switch-buffer-size
                    (:width 7))
                   (ivy-rich-switch-buffer-indicators
                    (:width 4 :face error :align right))
                   (ivy-rich-switch-buffer-major-mode
                    (:width 20 :face warning))
                   (ivy-rich-switch-buffer-project
                    (:width 25 :face success))
                   (ivy-rich-switch-buffer-path
                    (:width
                     (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.5))))))
                  :predicate
                  (lambda (cand) (get-buffer cand))
                  :delimiter "	"))
         (setq ivy-rich-display-transformers-list
               `(ivy-switch-buffer
                 ,ivy-rich-display-transformer--buffer
                 ivy-switch-buffer-other-window
                 ,ivy-rich-display-transformer--buffer
                 counsel-switch-buffer
                 ,ivy-rich-display-transformer--buffer
                 counsel-switch-buffer-other-window
                 ,ivy-rich-display-transformer--buffer
                 counsel-M-x
                 (:columns
                  ((all-the-icons-ivy-rich-function-icon)
                   (counsel-M-x-transformer
                    (:width 40))
                   (ivy-rich-counsel-function-docstring
                    (:face font-lock-doc-face))))
                 counsel-describe-function
                 (:columns
                  ((all-the-icons-ivy-rich-function-icon)
                   (counsel-describe-function-transformer
                    (:width 40))
                   (ivy-rich-counsel-function-docstring
                    (:face font-lock-doc-face))))
                 counsel-describe-variable
                 (:columns
                  ((all-the-icons-ivy-rich-variable-icon)
                   (counsel-describe-variable-transformer
                    (:width 40))
                   (ivy-rich-counsel-variable-docstring
                    (:face font-lock-doc-face))))
                 counsel-describe-symbol
                 (:columns
                  ((all-the-icons-ivy-rich-symbol-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-set-variable
                 (:columns
                  ((all-the-icons-ivy-rich-variable-icon)
                   (counsel-describe-variable-transformer
                    (:width 40))
                   (ivy-rich-counsel-variable-docstring
                    (:face font-lock-doc-face))))
                 counsel-apropos
                 (:columns
                  ((all-the-icons-ivy-rich-symbol-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-info-lookup-symbol
                 (:columns
                  ((all-the-icons-ivy-rich-symbol-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-descbinds
                 (:columns
                  ((all-the-icons-ivy-rich-keybinding-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-find-file
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-read-file-transformer))
                  :delimiter "	")
                 counsel-file-jump
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-dired
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-read-file-transformer))
                  :delimiter "	")
                 counsel-dired-jump
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-el
                 (:columns
                  ((all-the-icons-ivy-rich-symbol-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-fzf
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-git
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-recentf
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate
                    (:width 0.8))
                   (ivy-rich-file-last-modified-time
                    (:face font-lock-comment-face)))
                  :delimiter "	")
                 counsel-buffer-or-recentf
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (counsel-buffer-or-recentf-transformer
                    (:width 0.65))
                   (ivy-rich-file-last-modified-time
                    (:face font-lock-comment-face)))
                  :delimiter "	")
                 counsel-bookmark
                 (:columns
                  ((all-the-icons-ivy-rich-bookmark-type)
                   (all-the-icons-ivy-rich-bookmark-name
                    (:width 40))
                   (all-the-icons-ivy-rich-bookmark-info))
                  :delimiter "	")
                 counsel-bookmarked-directory
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-package
                 (:columns
                  ((all-the-icons-ivy-rich-package-icon)
                   (ivy-rich-candidate
                    (:width 30))
                   (all-the-icons-ivy-rich-package-version
                    (:width 16 :face font-lock-comment-face))
                   (all-the-icons-ivy-rich-package-archive-summary
                    (:width 7 :face font-lock-builtin-face))
                   (all-the-icons-ivy-rich-package-install-summary
                    (:face font-lock-doc-face)))
                  :delimiter "	")
                 counsel-fonts
                 (:columns
                  ((all-the-icons-ivy-rich-font-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-major
                 (:columns
                  ((all-the-icons-ivy-rich-function-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-find-library
                 (:columns
                  ((all-the-icons-ivy-rich-library-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-load-library
                 (:columns
                  ((all-the-icons-ivy-rich-library-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-load-theme
                 (:columns
                  ((all-the-icons-ivy-rich-theme-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-world-clock
                 (:columns
                  ((all-the-icons-ivy-rich-world-clock-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-tramp
                 (:columns
                  ((all-the-icons-ivy-rich-tramp-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-git-checkout
                 (:columns
                  ((all-the-icons-ivy-rich-git-branch-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-list-processes
                 (:columns
                  ((all-the-icons-ivy-rich-process-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-projectile-switch-project
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-projectile-find-file
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (counsel-projectile-find-file-transformer))
                  :delimiter "	")
                 counsel-projectile-find-dir
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (counsel-projectile-find-dir-transformer))
                  :delimiter "	")
                 counsel-minor
                 (:columns
                  ((all-the-icons-ivy-rich-mode-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-imenu
                 (:columns
                  ((all-the-icons-ivy-rich-imenu-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-cd
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 counsel-company
                 (:columns
                  ((all-the-icons-ivy-rich-company-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 package-install
                 (:columns
                  ((all-the-icons-ivy-rich-package-icon)
                   (ivy-rich-candidate
                    (:width 30))
                   (ivy-rich-package-version
                    (:width 16 :face font-lock-comment-face))
                   (ivy-rich-package-archive-summary
                    (:width 7 :face font-lock-builtin-face))
                   (ivy-rich-package-install-summary
                    (:face font-lock-doc-face)))
                  :delimiter "	")
                 package-reinstall
                 (:columns
                  ((all-the-icons-ivy-rich-package-icon)
                   (ivy-rich-candidate
                    (:width 30))
                   (ivy-rich-package-version
                    (:width 16 :face font-lock-comment-face))
                   (ivy-rich-package-archive-summary
                    (:width 7 :face font-lock-builtin-face))
                   (ivy-rich-package-install-summary
                    (:face font-lock-doc-face)))
                  :delimiter "	")
                 package-delete
                 (:columns
                  ((all-the-icons-ivy-rich-package-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-switch-to-buffer
                 ,ivy-rich-display-transformer--buffer
                 persp-switch
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-frame-switch
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-window-switch
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-kill
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-save-and-kill
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-import-buffers
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-import-win-conf
                 (:columns
                  ((all-the-icons-ivy-rich-project-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-kill-buffer
                 (:columns
                  ((all-the-icons-ivy-rich-buffer-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-remove-buffer
                 (:columns
                  ((all-the-icons-ivy-rich-buffer-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 persp-add-buffer
                 (:columns
                  ((all-the-icons-ivy-rich-buffer-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 all-the-icons-ivy-rich-kill-buffer
                 (:columns
                  ((all-the-icons-ivy-rich-buffer-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")
                 treemacs-projectile
                 (:columns
                  ((all-the-icons-ivy-rich-file-icon)
                   (ivy-rich-candidate))
                  :delimiter "	")))
         (ivy-rich-mode 1)
         :ensure t))

     (when (eq gb/completion-framework 'helm)
       (use-package swiper-helm
         :bind (("s-s" . swiper-helm))
         :ensure t))

   #+END_SRC
** counsel
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'ivy)
       (require 'comint)
       (require 'org)
       (use-package counsel
         :ensure t
         :after ( swiper ivy)
         :bind (( "M-x"     . counsel-M-x)
                ( "C-x C-f" . counsel-find-file)
                ( "s-f"     . counsel-buffer-or-recentf)
                ;; ( "s-i"     . counsel-imenu)
                ( "C-c g h" . counsel-git-grep)
                ( "C-x d"   . counsel-dired)
                ( "C-x 8 <RET>" . counsel-unicode-char)
                :map comint-mode-map
                ( "<M-up>"  . counsel-shell-history )
                :map org-mode-map
                ( "s-i"     . counsel-org-goto))
         :config
         (progn
           (bind-key "M-y" #'counsel-yank-pop ) ;; no :bind, since counsel needs to be loaded for magit
           (bind-key "M-y" #'ivy-next-line ivy-minibuffer-map )
           (when-let ((initial-ivy-input (assoc 'counsel-M-x ivy-initial-inputs-alist)))
             (setcdr initial-ivy-input "")) ;; remove ^ from input
           (setq counsel-grep-swiper-limit 3000000)))
       (use-package counsel-bbdb
         :ensure t)
       (use-package counsel-css
         :ensure t)
       (use-package counsel-jq
         :ensure t)
       (use-package counsel-org-capture-string
         :ensure t)
       (use-package counsel-projectile
         :ensure t)
       (use-package counsel-tramp
         :ensure t))
   #+END_SRC
** highlight-thing
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-thing
     :ensure t
     :init
     (progn
       (defun gb/toogle-highlight-what-thing ()
         "toggle highlight-thing-what-thing between word and symbol.
   highlight thing mode will be switched off during toggle
   and then reactivated, if it was active before."
         (interactive)
         (let (old-highlight-thing-mode highlight-thing-mode)
           (highlight-thing-mode -1)
           (if (equal 'symbol highlight-thing-what-thing)
               (setq highlight-thing-what-thing 'word)
             (setq highlight-thing-what-thing 'symbol))
           (if old-highlight-thing-mode
               (highlight-thing-mode 1))))
       (setq highlight-thing-what-thing 'symbol)))
   #+END_SRC
** minimap
   #+BEGIN_SRC emacs-lisp
     (use-package minimap
       :ensure t
       :bind (("s-m" . minimap-mode))
       :config
       (progn
         (setq minimap-major-modes (quote (prog-mode org-mode nxml-mode)))
         (setq minimap-window-location (quote right))
         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (--each '((minimap-active-region-background ((t (:extend t :background "gray23")))))
                 (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))
   #+END_SRC
* programming language related
** all
   #+begin_src emacs-lisp
     (cond
      ((eq gb/theme-mode 'light) nil) ;; TODO complete
      (t (progn
           (--each '((font-lock-comment-face ((t (:foreground "gray50" :slant italic)))))
             (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
   #+end_src
** functional-editing
*** OBSOLETE parinfer (currently disabled)
    - State "OBSOLETE"   from "TODO"       [2016-12-18 Sun 09:47]
    - M-x parinfer-toggle-mode
    - use indent to actually infer parenthesis
    - CAREFUL, THIS IS DESTRUCTIVE TO NOT CORRECTLY INDENTED LISP CODE!
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package parinfer
      :disabled t
      :init
      (progn
        (add-hook 'clojure-mode-hook #'parinfer-mode)
        (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'parinfer-mode)
        (add-hook 'ielm-mode-hook             #'parinfer-mode)
        (add-hook 'lisp-mode-hook             #'parinfer-mode)
        (add-hook 'lisp-interaction-mode-hook #'parinfer-mode)
        (add-hook 'scheme-mode-hook           #'parinfer-mode)))
    #+END_SRC
*** eros (display result of eval as overlay)
    - shows eval-last-sexp as overlay behind the expression evaluated (instead of only minibuffer)
    #+BEGIN_SRC emacs-lisp 
    (use-package eros
      :ensure t
      :config
      (progn
        (eros-mode 1)))
    #+END_SRC
*** eldoc mode
    - is automatically turned on in emacs 25.x
    #+BEGIN_SRC emacs-lisp
    ;; (global-eldoc-mode -1) ;; switch eldoc off globally 
    ;; eldoc-mode shows documentation in the minibuffer when writing code
    ;; http://www.emacswiki.org/emacs/ElDoc
    ;; (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    ;; (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    ;; (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC
    #+BEGIN_SRC emacs-lisp
    ;; function that displays eldoc message into a pos-tip
    (defun gb/eldoc-display-message (format-string &rest args)
      "Display eldoc message near point."
      (when format-string
        (pos-tip-show (apply 'format format-string args) :TIMEOUT 1)))
    ;; make sure that eldoc calls own function
    ;; (setq eldoc-message-function #'gb/eldoc-display-message)
    ;; restore original
    ;; (setq eldoc-message-function #'eldoc-minibuffer-message)

    #+END_SRC
*** eldoc overlay mode
    - displays eldoc in an overlay right before cursor
    - does this all the time, after some delay.
    - this may become anoying
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package quick-peek
        :ensure t)
      (use-package eldoc-overlay
        :ensure t
        ;; :after (inline-docs quick-peek)
        :commands eldoc-overlay-mode)
    #+END_SRC
*** paredit
    #+BEGIN_SRC emacs-lisp
    ;; Automatically load paredit when editing a lisp file
    ;; More at http://www.emacswiki.org/emacs/ParEdit
    (use-package paredit
      :ensure t
      :init
      (progn
        (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
        (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
        (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
        (add-hook 'clojure-mode-hook          #'enable-paredit-mode)))

    ;; (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)

    #+END_SRC
*** elisp slime nav
    #+BEGIN_SRC emacs-lisp
    ;; allows navigation M-. and M-, to jump to definition and return back
    (use-package elisp-slime-nav
      :ensure t
      :init
      (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook 'elisp-slime-nav-mode))
      )
    #+END_SRC
*** IMPLEMENT lispy
    when cursor is positioned on opening parenthesis or right behind closing parenthesis, special keybinding is applied
    (see also https://github.com/abo-abo/lispy)
**** general keybindings
***** [      move to first enclosing opening parenthesis
***** ]      move to first enclosing closing parenthesis
      )      
***** C-1    display function doc inline (only if connected to nrepl)
***** C-2    display function parameters of current thing at point (repl connected)
***** }      open square brackets "[]"
***** {      open curly brackets "{}"
***** (      open brackets "()"
***** "      open quotes '""'
**** special keybindings
***** >      barf in
***** <      barf out
      #+BEGIN_SRC emacs-lisp
        (use-package iedit
          :after (rainbow-identifiers))
        (use-package lispy
          :ensure t
          :bind (("C-1" . lispy-describe-inline)) ;; make C-1 available even without lispy mode!
          :after ( hydra iedit)
          :config
          (cond
           ((eq gb/theme-mode 'light) nil) ;; TODO complete
           (t (progn
                (--each '((lispy-face-hint ((t (:background "gray20" :foreground "#fff3bc")))))
                  (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))
      #+END_SRC
** clojure
*** clojure
    #+BEGIN_SRC emacs-lisp
    ;;;;
    ;; Clojure
    ;;;;


    ;; A little more syntax highlighting
    (use-package clojure-mode-extra-font-locking
      :ensure t
      :after ( clojure-mode))

    (use-package clojure-mode
      :ensure t
      :after ( subword ;; optional, when active, clojure switches to this minor mode too
               flycheck ;; optional, when active, clojure switches to this minor mode too
               paredit ;; optional, when active, clojure switches to this minor mode too
               hideshow ;; for folding namespaces (see below)
               ;; key-chord ;; for defining folding with hide show
               hydra )
      :interpreter "clojure"
      :mode "\\.clj\\'"
      :init (progn
              ;; Enable paredit for Clojure
              (when (package-installed-p 'paredit)
                (add-hook 'clojure-mode-hook 'enable-paredit-mode))

              (when (package-installed-p 'flycheck)
                (add-hook 'clojure-mode-hook 'flycheck-mode))

              ;; This is useful for working with camel-case tokens, like names of
              ;; Java classes (e.g. JavaClassName)
              (when (package-installed-p 'subword)
                (add-hook 'clojure-mode-hook 'subword-mode))

              ;; turn on eldoc for clojure mode
              (add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)

              ;; syntax hilighting for midje
              (add-hook 'clojure-mode-hook
                        (lambda ()
                          (setq inferior-lisp-program "lein repl")
                          (font-lock-add-keywords
                           nil
                           '(("(\\(facts?\\)"
                              (1 font-lock-keyword-face))
                             ("(\\(background?\\)"
                              (1 font-lock-keyword-face))))
                          (define-clojure-indent (fact 1))
                          (define-clojure-indent (facts 1))))

              (defun gb/hs-clojure-mode-hook ()
                (interactive)
                (hs-minor-mode 1)
                ;; (key-chord-define clojure-mode-map "q1" #'hs-toggle-hiding)
                (gb/hs-clojure-hide-namespace-and-folds))

              (add-hook 'clojure-mode-hook #'gb/hs-clojure-mode-hook)
              )
      :config
      (progn
        ;; define hydras

        ;;--------------------------------------------------------------------------------
        (defhydra hydra-all-clojure-refactorings ()
          "all clojure refactorings as hydra menu"
          ("c" hydra-cljr-code-menu/body "code refactorings" :exit t)
          ("n" hydra-cljr-ns-menu/body "namespace refactorings" :exit t)
          ("p" hydra-cljr-project-menu/body "project refactorings" :exit t)
          ("t" hydra-cljr-toplevel-form-menu/body "top level form refactorings" :exit t))

        (defun gb/hs-clojure-hide-namespace-and-folds ()
          "Hide the first (ns ...) expression in the file, and also all
    the (^:fold ...) expressions."
          (interactive)
          (hs-life-goes-on
           (save-excursion
             (goto-char (point-min))
             (when (ignore-errors (re-search-forward "^(ns "))
               (hs-hide-block))

             (while (ignore-errors (re-search-forward "\\^:fold"))
               (hs-hide-block)
               (next-line)))))

        ))
    #+END_SRC
*** flycheck-clojure
    #+BEGIN_SRC emacs-lisp
    (use-package flycheck-clojure
      :ensure t
      :after (flycheck clojure-mode))
    #+END_SRC
*** cider
    #+BEGIN_SRC emacs-lisp
    ;;;;
    ;; Cider
    ;;;;
    (use-package cider
      :ensure t
      :commands cider-jack-in
      :after ( clojure-mode
               company ;; optional for completion
               flycheck-clojure ;; optional for checking on the fly
               rainbow-delimiters ;; optional minor mode to switch on
               paredit ;; optional paredit minor mode to switch to
               spinner)
      :bind (:map clojure-mode-map
                  ("C-c C-v" . cider-start-http-server)
                  ("C-M-r" . cider-refresh)
                  ("C-c u" . cider-user-ns)
                  :map cider-mode-map
                  ("C-c u" . cider-user-ns))
      :init (progn
              ;; provides minibuffer documentation for the code you're typing into the repl
              (add-hook 'cider-mode-hook 'turn-on-eldoc-mode)

              ;; add company hooks
              (when (package-installed-p 'company)
                (add-hook 'cider-repl-mode-hook #'company-mode)
                (add-hook 'cider-mode-hook #'company-mode))

              ;; enable paredit in your REPL
              (when (package-installed-p 'paredit) (add-hook 'cider-repl-mode-hook 'paredit-mode))

              ;; make delimiters colorful
              (when (package-installed-p 'rainbow-delimiters)  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

              ;; Replace return key with newline-and-indent when in cider mode.
              (add-hook 'cider-mode-hook '(lambda () (local-set-key (kbd "RET") 'newline-and-indent)))

              ;; Use clojure mode for other extensions
              (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
              (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
              ;; (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode)) ;; might collide with clojure mode check of current major mode!!
              (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))

              (autoload 'cider--make-result-overlay "cider-overlays")

              (defun endless/eval-overlay (value point)
                (cider--make-result-overlay (format "%S" value)
                  :where point
                  :duration 'command)
                ;; Preserve the return value.
                value)

              (advice-add 'eval-region :around
                          (lambda (f beg end &rest r)
                            (endless/eval-overlay
                             (apply f beg end r)
                             end)))

              (advice-add 'eval-last-sexp :filter-return
                          (lambda (r)
                            (endless/eval-overlay r (point))))

              (advice-add 'eval-defun :filter-return
                          (lambda (r)
                            (endless/eval-overlay
                             r
                             (save-excursion
                               (end-of-defun)
                               (point)))))

              ;; these help me out with the way I usually develop web apps
              (defun cider-start-http-server ()
                (interactive)
                (cider-load-current-buffer)
                (let ((ns (cider-current-ns)))
                  (cider-repl-set-ns ns)
                  (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
                  (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))

              (defun cider-refresh ()
                (interactive)
                (cider-interactive-eval (format "(user/reset)")))

              (defun cider-user-ns ()
                (interactive)
                (cider-repl-set-ns "user"))

              )
      :config
      (progn

        ;; try to display some context information additionally to regular eldoc
        (setq cider-eldoc-display-context-dependent-info t)

        ;; don't autoinject, because refactor-nrepl is injected, too, which fails to load
        ;; for (java 1.8, clojure 1.9, cider 0.17.0, lein 2.8.1)
        (setq cider-inject-dependencies-at-jack-in t)

        ;; use 1.9.0 if autoinjecting during cider startup
        (setq cider-jack-in-auto-inject-clojure "1.9.0")

        ;; make sure that nrepl does not automatically scroll down!
        (setq cider-repl-scroll-on-output nil)
        ;; use pretty print output in repl
        (setq cider-repl-use-pretty-printing t)

        ;; go right to the REPL buffer when it's finished connecting
        (setq cider-repl-pop-to-buffer-on-connect t)

        ;; When there's a cider error, show its buffer and switch to it
        (setq cider-show-error-buffer t)
        (setq cider-auto-select-error-buffer t)

        ;; Where to store the cider history.
        (setq cider-repl-history-file (concat user-emacs-directory "cider-history"))
        ;; keep that much history
        (setq cider-repl-history-size 1000)
        ;; Wrap when navigating history.
        (setq cider-repl-wrap-history t)

        ;; do flycheck setup for clojure
        (when (package-installed-p 'flycheck-clojure)  (flycheck-clojure-setup))

        ))
    #+END_SRC
*** helm-cider
    #+BEGIN_SRC emacs-lisp
      (when (eq gb/completion-framework 'helm)
        (use-package helm-cider
          :ensure t
          :after ( helm cider)
          :config
          (helm-cider-mode 1)))
    #+END_SRC
*** litable
    #+BEGIN_SRC emacs-lisp
    ;; To start this up, simply enable the litable minor mode in the buffer by calling
    ;; M-x litable-mode.
    (use-package litable
      :after ( clojure-mode))

    ;; Litable keeps a list of pure functions as a safeguard for unwanted evaluations.
    ;; A function must first be accepted into this list (using M-x litable-accept-as-pure)
    ;; before it can be evaluated on-the-fly. You should take care of what function you accept
    ;; as pure to avoid any unfortunate accidents. Also, note that the pure functions list
    ;; persists across sessions.

    #+END_SRC
*** clojars
    - search clojars for libraries (M-x clojars)
    #+BEGIN_SRC emacs-lisp
    (use-package clojars
      :after ( clojure-mode))
    #+END_SRC
*** expectations
    #+BEGIN_SRC emacs-lisp :tangle no
    ;;================================================== clojure
    ;; clojure expectations mode
    ;;   (use-package expectations-mode
    ;;     :after ( clojure-mode)
    ;;     :config
    ;;     (setenv "EXPECTATIONS_COLORIZE" "false"))
    #+END_SRC
*** clj-refactor
    #+BEGIN_SRC emacs-lisp
    (use-package inflections
      :ensure t)
    (use-package peg
      :ensure t)
    (use-package edn
      :ensure t
      :after ( peg))
    (use-package clj-refactor
      :ensure t
      :after ( hydra s seq yasnippet paredit multiple-cursors clojure-mode cider edn inflections)
      :init
      (defun gb/clojure-mode-hook ()
        (clj-refactor-mode 1)
        (yas-minor-mode 1) ; for adding require/use/import
        (cljr-add-keybindings-with-prefix "C-c C-m"))

      (add-hook 'clojure-mode-hook #'gb/clojure-mode-hook))
    #+END_SRC
*** typed clojure
    #+BEGIN_SRC emacs-lisp
    (use-package typed-clojure-mode
      :after ( clojure-mode subword)
      :ensure t
      :init
      (add-hook 'clojure-mode-hook 'typed-clojure-mode))
    #+END_SRC
*** org babel clojure
    #+BEGIN_SRC emacs-lisp

    #+END_SRC
** cypher mode (neo4j), disabled
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package cypher-mode
     ;; :defer 5
     )
   #+END_SRC
** eclim eclipse emacs integration (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package eclim
     :disabled t
     :config
     (global-eclim-mode)
     (custom-set-variables
      '(eclim-eclipse-dirs '("/Applications/Eclipse.app/Contents/Eclipse"))
      '(eclim-executable "/Applications/Eclipse.app/Contents/Eclipse/plugins/org.eclim_2.5.0/bin/eclim")))

   (use-package company-emacs-eclim
     :after ( eclim company)
     :disabled t
     :config
     (company-emacs-eclim-setup)
     (global-company-mode t))

   (use-package eclimd
     :after ( eclim)
     :disabled t)
   #+END_SRC
** elixir
   #+BEGIN_SRC emacs-lisp
   (use-package elixir-mode
     :ensure t)
   #+END_SRC
** elm
   #+BEGIN_SRC emacs-lisp
   (use-package elm-mode
     :ensure t)
   #+END_SRC
** erlang
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package erlang
     :ensure t)
   #+END_SRC
**** erlang company
     #+BEGIN_SRC emacs-lisp :tangle no
       (when (eq gb/completion-framework 'ivy)
         (use-package ivy-erlang-complete
           :ensure t
           :after (ivy counsel erlang async)))
       (use-package company-erlang
         :ensure t
         :after ( erlang ivy-erlang-complete company))
     #+END_SRC
** groovy
   #+BEGIN_SRC emacs-lisp
   (use-package groovy-mode
     :commands groovy-mode
     :ensure t
     :init
     (progn
       ;; make sure for some labeled parameters in groovy to indent with 4
       (add-hook 'groovy-mode-hook
                 (lambda ()
                   (c-set-offset 'label 4)))))

   #+END_SRC
** kotlin
   #+BEGIN_SRC emacs-lisp
     (use-package kotlin-mode
       :ensure t
       :hook (kotlin-mode . gb/enable-ligatures)
       :config)

     (use-package flycheck-kotlin
       :ensure t
       :after (kotlin-mode))

     (use-package ob-kotlin
       :ensure t
       :after (kotlin-mode org))

     (use-package gb-kotlin
       :load-path "~/repo/gb-kotlin"
       :after (kotlin-mode magit yafolding)
       :hook (kotlin-mode . gb/kotlin-run-hooks)
       :bind (:map kotlin-mode-map
              ( "C-c M-w" .   gb/kotlin-kill-full-qualified-class-name-at-point)
              ( "C-c / t i" . gb/kotlin-toggle-fold-import-section) ;; toggle import
              ( "C-c / i i" . gb/kotlin-import-at-point) ;; import insert
              ( "C-c / i t" . gb/kotlin-import-test-insert) ;; import test
              ( "C-c / i s" . gb/kotlin-import-stdlib-insert) ;; import stdlib
              ( "C-c / i r" . gb/kotlin-rewrite-import-region) ;; import rewrite
              ( "C-c / i l" . gb/kotlin-import-search-and-insert)))
   #+END_SRC
** haskell
   #+BEGIN_SRC emacs-lisp
   (use-package haskell-mode
     :ensure t
     :bind (:map haskell-mode-map
                 ("C-c C-l" . haskell-process-load-file)
                 ("C-c C-n C-t" . haskell-process-do-type)
                 ("C-c C-n C-i" . haskell-process-do-info)
                 ("C-c h" . haskell-hoogle))
     :init
     (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
     (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
     (add-to-list 'exec-path "~/.local/bin"))
   #+END_SRC
*** company-ghci
    #+BEGIN_SRC emacs-lisp
    (use-package company-ghci
      :ensure t
      :after ( company haskell-mode)
      :init
      (push 'company-ghci company-backends)
      (add-hook 'haskell-mode-hook 'company-mode)
      (add-hook 'haskell-interactive-mode-hook 'company-mode))
    #+END_SRC
*** dante (intero fork, complete development environment for haskell)
    #+BEGIN_SRC emacs-lisp
    (use-package dante
      :ensure t
      :after ( haskell-mode company flycheck s f dash)
      :commands 'dante-mode
      :init
      (add-hook 'haskell-mode-hook 'dante-mode)
      (add-hook 'haskell-mode-hook 'flycheck-mode))
    #+END_SRC
*** intero (disabled) (complete development environment for haskell)
    - see [[https://commercialhaskell.github.io/intero/][here]]
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package intero
      :after ( haskell-mode company flycheck)
      :init
      (add-hook 'haskell-mode-hook 'intero-mode)
      (when (fboundp 'easy-escape-minor-mode) ;; make sure to disable easy escaping here (if present)
        (add-hook 'inter-mode (lambda() (easy-escape-minor-mode -1)))))
    #+END_SRC
*** flycheck-haskell (currently disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package flycheck-haskell
      :ensure t
      :after ( haskell-mode flycheck))
    #+END_SRC
** web-mode
   #+BEGIN_SRC emacs-lisp
   (use-package web-mode
     :ensure t
     :mode (("\\.phtml\\'" . web-mode)
            ("\\.tpl\\.php\\'" . web-mode)
            ("\\.[agj]sp\\'" . web-mode)
            ("\\.as[cp]x\\'" . web-mode)
            ("\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.dhtml\\'" . web-mode)
            ("\\.html?\\'" . web-mode))
     :config
     (progn
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)))
   #+END_SRC
** typescript
   #+BEGIN_SRC emacs-lisp
     ;; run ts repl in typescript-mode, allowing to send expressions to the interpreter
     ;; M-x run-ts ;; starts a comint buffer with repl
     (use-package ts-comint
       :ensure t
       :commands run-tsun run-ts
       :after ( typescript-mode)
       :init
       (setenv "NODE_NO_READLINE" "1")
       (defun run-tsun ()
         (interactive)
         (let ((buf (get-buffer "*Typescript*")))
           (if buf
               (switch-to-buffer buf)
             (progn
               (ansi-term (s-trim (shell-command-to-string "command -v bash")) "Typescript")
               (comint-send-string "*Typescript*" "tsun\n")))))
       (add-hook 'typescript-mode-hook
                 (lambda ()
                   (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
                   (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
                   (local-set-key (kbd "C-c b") 'ts-send-buffer)
                   (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
                   (local-set-key (kbd "C-c l") 'ts-load-file-and-go))))

     (use-package typescript-mode
       :ensure t
       :mode (("\\.tsx?\\'" . typescript-mode)))

     (use-package tide
       :ensure t
       :after ( typescript-mode)
       :init (progn
               (add-hook 'typescript-mode-hook #'gb/setup-tide-mode)
               (add-hook 'js-mode-hook #'gb/setup-tide-mode)
               ;; (add-hook 'tide-mode-hook #'gb/setup-tide-mode)
               (add-hook 'web-mode-hook
                         (lambda ()
                           (when (string-equal "tsx" (file-name-extension buffer-file-name))
                             (gb/setup-tide-mode))))
               )
       :config
       (progn
         (defun gb/setup-tide-mode ()
           (interactive)
           (tide-setup)
           (flycheck-mode +1)
           (setq flycheck-check-syntax-automatically '(save mode-enabled))
           (eldoc-mode +1)
           (tide-hl-identifier-mode +1)
           (company-mode +1)
           (subword-mode +1)
           (setq typescript-indent-level 4))

         ;; aligns annotation to the right hand side
         (setq company-tooltip-align-annotations t)

         ;; use 2 for indent
         (setq typescript-indent-level 4)

         (setq json-reformat:indent-width 4)
         (setq js-indent-level 4)

         (add-hook 'js-mode-hook #'gb/setup-tide-mode)
         ;; configure javascript-tide checker to run after your default javascript checker
         (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)

         ;; configure jsx-tide checker to run after your default jsx checker
         (flycheck-add-mode 'javascript-eslint 'web-mode)
         (flycheck-add-next-checker 'javascript-eslint 'jsx-tide 'append)
         ;; formats the buffer before saving
         ;; (add-hook 'before-save-hook 'tide-format-before-save)
         ))
   #+END_SRC
** prettier-js (pretty print js)
   - prettier-js-mode (when active) does formattering before save
   #+begin_src emacs-lisp
     (use-package prettier-js
       :ensure t
       :commands prettier-js
       :init
       (setq gb/execute-prettier-on-save nil)

       (when gb/execute-prettier-on-save
         (eval-after-load 'web-mode
           '(progn
              (add-hook 'web-mode-hook #'add-node-modules-path)
              (add-hook 'web-mode-hook #'prettier-js-mode)))
         (eval-after-load 'js-mode-hook
           '(progn
              (add-hook 'web-mode-hook #'add-node-modules-path)
              (add-hook 'web-mode-hook #'prettier-js-mode)))
         (eval-after-load 'typescript-mode-hook
           '(progn
              (add-hook 'web-mode-hook #'add-node-modules-path)
              (add-hook 'web-mode-hook #'prettier-js-mode)))))
   #+end_src
** java script
   #+BEGIN_SRC emacs-lisp
     ;; (use-package tagedit)
     (use-package add-node-modules-path
       :ensure t)
     ;; (use-package js2-mode
     ;;   :ensure js2-mode

     ;;   :mode (("\\.js\\'" . js2-mode)
     ;;          ("\\.jsx?\\'" . js2-jsx-mode))
     ;;   :config (setq js-indent-level 2))
     ;; (use-package js
     ;;   :after ( flycheck tagedit)
     ;;   :defer 5
     ;;   :config
     ;;   (add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
     ;;   (when (package-installed-p 'subword)
     ;;     (add-hook 'js-mode-hook 'subword-mode)
     ;;     (add-hook 'html-mode-hook 'subword-mode))
     ;;   (when (package-installed-p 'flycheck)
     ;;     (add-hook 'js-mode-hook 'flycheck-mode))
     ;;   (setq js-indent-level 2)
     ;;   (eval-after-load "sgml-mode"
     ;;     '(progn
     ;;        (require 'tagedit)
     ;;        (tagedit-add-paredit-like-keybindings)
     ;;        (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))


     ;;   ;; coffeescript
     ;;   (add-to-list 'auto-mode-alist '("\\.coffee.erb$" . coffee-mode))
     ;;   (when (package-installed-p 'subword)
     ;;     (add-hook 'coffee-mode-hook 'subword-mode))
     ;;   (add-hook 'coffee-mode-hook 'highlight-indentation-current-column-mode)
     ;;   (add-hook 'coffee-mode-hook
     ;;             (defun coffee-mode-newline-and-indent ()
     ;;               (define-key coffee-mode-map "\C-j" 'coffee-newline-and-indent)
     ;;               (setq coffee-cleanup-whitespace nil)))
     ;;   (custom-set-variables
     ;;    '(coffee-tab-width 4)))
   #+END_SRC
** java
*** other
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.xtend\\'" . java-mode))
      (add-hook 'java-mode #'gb/enable-ligatures)
    #+END_SRC
*** jde (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
     ;; Add java development extension to loadpath
     ;;  (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp")
     ;;  (load "jde")

     ;; (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp/")
     ;; (use-package jde
     ;;   :disabled t
     ;;   :loader :path
     ;;   :config
     ;;   (defadvice custom-buffer-create  (after jde-set-default-dir-to-project-dir (options &optional name description) activate)
     ;;     "When customizing jde path variables set the default directory to the jde project file directory. This makes file completion work for relative paths."
     ;;     (when (and (listp options) ;; we want options to look like (list (list symbol 'custom-variable)), see customize-variable
     ;;                (eq (length options) 1)
     ;;                (listp (car options))
     ;;                (eq (length (car options)) 2)
     ;;                (or (eq 'custom-variable (cadar options)) (eq 'jde-custom-variable (cadar options))))
     ;;       (let ((symbol (caar options)))
     ;;         (if (memq symbol '(jde-global-classpath jde-sourcepath));; or we could use (jde-symbol-p symbol)
     ;;             ;; stolen from jde-project-file: find the project file where this symbol is saved
     ;;             (let* ((project-file-paths (nreverse (jde-find-project-files default-directory))))
     ;;               (when project-file-paths
     ;;                 (when (jde-save-needs-saving-p symbol project-file-paths)
     ;;                   ;; set the current directory to the directory the project file is in, ie the root for relative paths
     ;;                   (setq default-directory (expand-file-name ".." (caar (get symbol 'jde-project)))))))))))
     ;;   )

     ;; ;; (global-set-key (kbd "C-<tab>") 'jde-complete);; currently overshadowed by yasnippets


   #+END_SRC
*** java decompiler
    #+BEGIN_SRC emacs-lisp :tangle no
      ;; (add-to-list 'load-path "~/.emacs.d/java/")
      ;; (use-package javad
      ;;   :after ( javap-mode)
      ;;   :loader :path
      ;;   :defer 5
      ;;   :config
      ;;   ;; allows viewing decompiled version of a class file if jad is installed!
      ;;   ;;(load "~/.emacs.d/java/javad.el")

      ;;   (defun javad-find-class (&rest args)
      ;;     (interactive)
      ;;     (if (not (string= ".class" (substring (buffer-file-name) -6 nil)))
      ;;         nil
      ;;       (message "Show class as: [b]ytecode, [d]ecompiled or [i]dentity?")
      ;;       (let ((resp (read-char)))
      ;;         (cond
      ;;          ((= resp 98) (progn (javap-buffer) nil))
      ;;          ((= resp 100) (progn (javad-buffer) nil))
      ;;          (t nil))
      ;;         (let ((buff (current-buffer)))
      ;;           (switch-to-buffer buff)))))

      ;;   (add-hook 'find-file-hook 'javad-find-class)
      ;;   )
    #+END_SRC
*** java programming mode
    #+BEGIN_SRC emacs-lisp
     (use-package javap-mode
       :ensure t)
    #+END_SRC
** php (disabled)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package php-mode
     
     :init
     ;; make sure that indentation of arrays is more readable
     (add-hook 'php-mode-hook (lambda ()
                                (defun ywb-php-lineup-arglist-intro (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (+ (current-column) c-basic-offset))))
                                (defun ywb-php-lineup-arglist-close (langelem)
                                  (save-excursion
                                    (goto-char (cdr langelem))
                                    (vector (current-column))))
                                (c-set-offset 'arglist-intro 'ywb-php-lineup-arglist-intro)
                                (c-set-offset 'arglist-close 'ywb-php-lineup-arglist-close))))


 #+END_SRC
** python
 #+BEGIN_SRC emacs-lisp
   (use-package python)
   (when (eq gb/completion-framework 'ivy)
     (use-package find-file-in-project
       :after ( ivy)))
   (use-package elpy
     :after ( org flycheck find-file-in-project python)
     :mode (("\\.py\\'" . python-mode))
     :init
     (add-hook 'python-mode-hook #'elpy-enable)
     (add-hook 'python-mode-hook #'flycheck-mode))
 #+END_SRC
** scala  (ensime disabled in favor of metals, an lsp server)
 #+BEGIN_SRC emacs-lisp
   (use-package sbt-mode
     :commands sbt-start sbt-command
     :config
     ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
     ;; allows using SPACE when in the minibuffer
     (substitute-key-definition
      'minibuffer-complete-word
      'self-insert-command
      minibuffer-local-completion-map))

   (use-package scala-mode
     :mode "\\.s\\(cala\\|bt\\)$")

   (use-package scalariform)

   (use-package lsp-metals
     :ensure t
     :config (setq lsp-metals-treeview-show-when-views-received t))

   (use-package dap-mode
     :ensure t
     :hook
     (lsp-mode . dap-mode)
     (lsp-mode . dap-ui-mode))

   ;; (use-package ensime
   ;;   :ensure t
   ;;   ;; :after ( sbt-mode)
   ;;   :commands ensime
   ;;   :init
   ;;   (add-hook 'scala-mode-hook 'ensime-mode)
   ;;   :config
   ;;   (custom-set-faces '(ensime-implicit-highlight ((t (:underline "#404040"))))
   ;;                     '(ensime-breakpoint-face ((t (:overline "light gray" :underline "light gray")))))
   ;;   (setq ensime-sbt-perform-on-save "compile")
   ;;   (setq ensime-search-interface 'helm)
   ;;   (setq ensime-eldoc-hints 'all))
   ;; (use-package flycheck-ensime)

   ;; ammonite no longer installed in nix
   ;; (use-package ammonite-term-repl
   ;;   :config (add-hook 'scala-mode-hook
   ;;                     (lambda ()
   ;;                       (ammonite-term-repl-minor-mode t))))
   ;; (use-package ob-ammonite)
 #+END_SRC
** xml
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package nxml-mode
       :mode (("\\.xslt\\'" . nxml-mode)
              ("\\.xml\\'" . nxml-mode)))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (use-package xml+
       :after ( dash))
   #+END_SRC
* programming related
** editorconfig
   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure t
       :config (editorconfig-mode 1))
   #+END_SRC
** yafolding
   #+begin_src emacs-lisp
     (use-package yafolding
       :hook (prog-mode . yafolding-mode)
       :config
       (advice-add 'yafolding-hide-region :after #'(lambda (&rest args) (when (and (fboundp 'minimap-mode) minimap-mode) (minimap-sync-overlays))))
       (advice-add 'yafolding-show-region :after #'(lambda (&rest args) (when (and (fboundp 'minimap-mode) minimap-mode) (minimap-sync-overlays)))))
   #+end_src
** flymake
   #+BEGIN_SRC emacs-lisp
     (use-package flymake
       ;; :ensure t
       )
     (use-package flymake-easy
       :ensure t
       :after ( flymake))
     (use-package flymake-yaml
       :ensure t
       :after ( flymake-easy)
       :init (add-hook 'yaml-mode-hook 'flymake-yaml-load))
     (use-package flymake-shell
       :ensure t
       :after ( flymake-easy)
       :init (add-hook 'sh-set-shell-hook 'flymake-shell-load))
     (use-package flymake-json
       :ensure t
       :after ( flymake-easy)
       :init (add-hook 'js-mode-hook 'flymake-json-maybe-load))
   #+END_SRC
** flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :init
       (setq flycheck-check-syntax-automatically '(idle-change save mode-enabled new-line))
       :config
       (progn
         (flycheck-define-checker proselint
           "A linter for prose."
           :command ("proselint" source-inplace )
           :error-patterns ((warning line-start (file-name) ":" line ":" column ": " (id (one-or-more (not (any " ")))) (message (one-or-more not-newline) (zero-or-more "\n" (any " ") (one-or-more not-newline))) line-end))
           :modes (text-mode markdown-mode gfm-mode org-mode message-mode))

         (if proselint-installed
             (add-to-list 'flycheck-checkers 'proselint))

         (if (fboundp 'flycheck-relevant-error-other-file-p) ;; error comes up especially when using proselint
             (advice-add 'flycheck-relevant-error-other-file-p :override (lambda (&rest args) nil))
           (defun flycheck-relevant-error-other-file-p (&rest args) ""))

         (define-key flycheck-mode-map flycheck-keymap-prefix nil)
         (setq flycheck-keymap-prefix (kbd "C-c k"))
         (define-key flycheck-mode-map flycheck-keymap-prefix
           flycheck-command-map)
         ;; (add-hook 'after-init-hook 'global-flycheck-mode)
         ))
   #+END_SRC
** projects
*** perspective (disabled - collision with company-box)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package perspective
     :config
     (progn
       ;; (persp-mode 1)
       (cond
        ((eq gb/theme-mode 'light) nil) ;; TODO complete
        (t (progn
             (--each '((persp-selected-face ((t (:foreground "Grey70")))))
               (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))
 #+END_SRC
*** projectile
    - see [[http://batsov.com/projectile/][here]]
 #+BEGIN_SRC emacs-lisp
 (use-package projectile
    :ensure t
    :config
   ;; projectile everywhere!
   ;; (projectile-global-mode)
   )
 #+END_SRC
*** persp-projectile (disabled - collision with company-box)
 #+BEGIN_SRC emacs-lisp :tangle no
   (when (eq gb/completion-framework 'helm)
     (use-package persp-projectile
       :after ( projectile perspective)
       :bind (
              ;; switch project on super-s
              :map  projectile-mode-map
              ("s-s" . helm-projectile-switch-project))))
 #+END_SRC
** git
*** magithub
    - disabled because ghub+ fails to load (some interface failure to git hub)
    #+BEGIN_SRC emacs-lisp :tangle no
      (when hub-installed
        (use-package magithub
          :after ( magit ghub+ apiwrap)
          :config
          (progn (magithub-feature-autoinject t))))
    #+END_SRC
*** magit (and more)
    #+BEGIN_SRC emacs-lisp
      (use-package ediff
        ;; :ensure t ;; internal packages seem not load correctly if ensured
        :config
        ;; make sure that ediff session does not open control window in separate frame, which mixes up exwm
        (setq ediff-window-setup-function (quote ediff-setup-windows-plain))
        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '( (diff-removed ((t (:background "red" :foreground "#663333"))))
                         (diff-refine-added ((t (:background "green" :foreground "#336633"))))

                         (magit-diff-added ((t (:background "#273C26" :foreground "#ddffdd"))))
                         (magit-diff-added-highlight ((t (:background "#223822" :foreground "#cceecc"))))
                         (magit-diff-removed ((t (:background "#442222" :foreground "#ffdddd"))))
                         (magit-diff-removed-highlight ((t (:background "#442222" :foreground "#eecccc"))))
                         (magit-diffstat-removed ((t (:foreground "#aa4444"))))

                         (ediff-current-diff-C ((t (:background "#444417"))))
                         (ediff-fine-diff-C ((t (:background "#555520"))))
                         (ediff-odd-diff-C ((t (:background "#555555"))))
                         (ediff-even-diff-C ((t (:background "#555555"))))
                         (ediff-fine-diff-B ((t (:background "#176517"))))
                         (ediff-fine-diff-A ((t (:background "#751717")))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))

      ;; TODO move this function to some general function pool
      (defun gb/display-buffer-fullframe (buffer alist)
        "Display BUFFER in fullscreen.

                ALIST is a `display-buffer' ALIST.

                Return the new window for BUFFER."
        (let ((window (display-buffer-pop-up-window buffer alist)))
          (when window
            (delete-other-windows window))
          window))

      (use-package magit-popup
        :ensure t
        :after ( async))
      (use-package magit
        :ensure t
        ;; :after ( helm counsel async dash with-editor git-commit magit-popup)
        :commands magit-status magit-list-repositories
        :bind (
               ("C-c v s" . magit-status)
               ("C-c v l" . magit-list-repositories)
               :map magit-mode-map
               ;; ("s-f" . helm-ls-git-ls) ;; TODO: currently get an error (recursive load by helm-ls-git-ls
               ("C-x f" . counsel-git)
               ;; :map magit-repolist-mode-map
               ;; ("s-i" . helm-imenu)
               )
        :init
        (progn

          (defun gb/magit-assume-unchanged ()
            "assume current file (or selection of files) to be unchanged"
            (interactive)
            (let* ((atpoint (magit-section-value-if 'file))
                   (files (magit-region-values 'file t)))
              (if files
                  (-each files
                    (lambda (file)
                      (magit-call-git "update-index" "--assume-unchanged" file)))
                (magit-call-git "update-index" "--assume-unchanged" atpoint)))
            (magit-refresh))

          (defun gb/magit--get-assumed-unchanged ()
            "list of files currently assumed unchanged in git index"
            (--filter (not (string-empty-p it))
                      (s-split "\n" (shell-command-to-string "git ls-files -v | grep '^h' | sed -e 's/^h //g'"))))

          (defun gb/magit-show-assumed-unchanged ()
            ""
            (interactive)
            (let* ((buffer (generate-new-buffer (generate-new-buffer-name "*magit - assumed unchanged*"))))
              (with-current-buffer buffer
                (--each (gb/magit--get-assumed-unchanged)
                  (insert it "\n")))
              (switch-to-buffer buffer)))

          (defun gb/magit-restore-assumed-unchanged ()
            "restore all assumed unchanged"
            (interactive)
            (--each (gb/magit--get-assumed-unchanged)
              (shell-command-to-string (format "git update-index --no-assume-unchanged \"%s\"" it)))
            (magit-refresh))

          (defun gb/shell-command-to-exit-code-and-string (command)
            "Run COMMAND and return the exit code (as int) and output (as string) in a pair ( exit-code . output-string )"
            (with-temp-buffer
              `(,(apply 'call-process shell-file-name nil (current-buffer) nil (list shell-command-switch command)) .
                ,(s-trim (buffer-string)))))

          (defun gb/magit-log-trace-definition ()
            "Show log for the definition marked."
            (interactive)
            (let ((fname  (or (magit-file-relative-name)
                              (user-error "Buffer isn't visiting a file")))
                  (fn (or (buffer-substring-no-properties (region-beginning) (region-end))
                          (user-error "function not marked")))
                  (rev (or magit-buffer-refname
                           (magit-get-current-branch)
                           "HEAD")))
              (magit-log-trace-definition fname fn rev)))

          (defun gb/disable-smartscan ()
            ""
            (if (fboundp #'smartscan-mode)
                (smartscan-mode -1))))

        (add-hook 'magit-mode-hook 'gb/disable-smartscan)
        :config
        (require 'magit-mode)
        ;; use magit-describe-section-briefly to find out section name (first element in square brackets [])
        (setq magit-section-initial-visibility-alist
              (quote
               ((staged . show)
                (unpushed . show)
                (stashes . show)
                (unpulled . show))))
        (setq magit-repository-directories '(( "~/repo" . 3)))

        ;; otherwiese use regular completing read function
        (when (eq gb/completion-framework 'ido)
          (setq magit-completing-read-function 'magit-ido-completing-read))
        (when (eq gb/completion-framework 'helm)
          (setq magit-completing-read-function 'helm--completing-read-default))

        (setq magit-fetch-arguments (quote ("--prune")))
        (setq magit-item-highlight-face nil)
        (setq magit-last-seen-setup-instructions "1.4.0")
        (setq magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n200")))
        (setq magit-pull-arguments (quote ("--rebase")))
        (setq magit-use-overlays nil)
        (setq magit-diff-refine-hunk t)
        (setq magit-diff-adjust-tab-width t)
        (setq magit-diff-highlight-trailing t)
        (setq magit-diff-hide-trailing-cr-characters t)
        (setq magit-display-buffer-function (quote magit-display-buffer-fullframe-status-v1))

        ;; allow (magit-status "/yadm::") to open yadm repository
        (when (executable-find "yadm")
          (bind-key "C-c v y" #'(lambda () (interactive) (magit-status "/yadm::")))
          (require 'tramp)
          (add-to-list 'tramp-methods
                       '("yadm"
                         (tramp-login-program "yadm")
                         (tramp-login-args (("enter")))
                         (tramp-login-env (("SHELL") ("/bin/sh")))
                         (tramp-remote-shell "/bin/sh")
                         (tramp-remote-shell-args ("-c")))))

        ;; make sure that magit closes all other windows on the frame
        ;; (when (fboundp 'gb/display-buffer-fullframe)
        ;;   (add-to-list 'display-buffer-alist
        ;;                `(,(rx "*magit: ")
        ;;                  (gb/display-buffer-fullframe)
        ;;                  (reusable-frames . nil))))
        )
      ;; show git relevant change info in the fringe of the frame
      ;; git-gutter-fringe works with nlinum-mode !
      (use-package git-gutter
        :ensure t
        :config
        (progn
          (cond
           ((eq gb/theme-mode 'light) nil) ;; TODO complete
           (t (progn
                (--each '((git-gutter:unchanged ((t (:background "orange4")))))
                  (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
          (setq git-gutter-added-sign".")))

      (use-package git-gutter-fringe
        :ensure t
        :after ( git-gutter)
        :config
        (global-git-gutter-mode +1)
        (fringe-helper-define 'git-gutter-fr:added nil
          "........"
          "........"
          "...X...."
          "..XXX..."
          "...X...."
          "........"
          "........"
          "........")

        (fringe-helper-define 'git-gutter-fr:deleted nil
          "........"
          "........"
          "........"
          "..XXX..."
          "........"
          "........"
          "........"
          "........")

        (fringe-helper-define 'git-gutter-fr:modified nil
          "........"
          "........"
          "....X..."
          "...X...."
          "....X..."
          "........"
          "........"
          "........"))

      (use-package magit-gh-pulls
        :after ( magit)
        :disabled t
        ;; :defer 40
        :init
        (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))

      (use-package magit-filenotify
        :after ( magit)
        :disabled t
        ;; :defer 40
        :init
        (add-hook 'after-save-hook 'magit-after-save-refresh-status)
        (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))

      ;; use automatic file notification to update magit status buffer
      ;; (add-hook 'magit-status-mode-hook 'magit-filenotify-mode )
      ;; currently no file notification package is available
      ;; Activate the mode inside the magit-status buffer by calling M-x magit-filenotify-mode [RET]. Repeat the same step to deactivate it again.
      ;; To always enable the mode when opening the magit-status buffer add magit-filenotify-mode to the magit-status-mode-hook.

      (use-package magit-gitflow
        :ensure t
        :after ( magit)
        :init
        (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
      ;; C-f in magit status buffer will invoke gitflow action selector.

      (use-package git-blamed
        :ensure t
        ) ;; enter git-blamed-mode colors background of lines according to commit (and should echo some info depending on cursor)

      (when (eq gb/completion-framework 'ivy)
        (use-package git-timemachine
          :ensure t
          :commands git-timemachine
          :config
          (defun gb/git-timemachine-show-selected-revision ()
            "Show last (current) revision of file."
            (interactive)
            (let (collection)
              (setq collection
                    (mapcar (lambda (rev)
                              ;; re-shape list for the ivy-read
                              (cons (concat (substring (nth 0 rev) 0 7) "|" (nth 5 rev) "|" (nth 6 rev)) rev))
                            (git-timemachine--revisions)))
              (ivy-read "commits:"
                        collection
                        :action (lambda (rev)
                                  (git-timemachine-show-revision rev)))))

          (defun gb/git-timemachine ()
            "Open git snapshot with the selected version.  Based on ivy-mode."
            (interactive)
            (unless (featurep 'git-timemachine)
              (require 'git-timemachine))
            (git-timemachine--start #'gb/git-timemachine-show-selected-revision))))
    #+END_SRC
*** magit todo
    - shows todos within the source code in magit overview (disable mode, explicitly enable if wanted)
     #+BEGIN_SRC emacs-lisp
       (use-package magit-todos
         :ensure t
         ;; :after (a anaphora async dash f hl-todo magit pcre2el s)
         :config ;; (magit-todos-mode)
         )
     #+END_SRC
*** magit imerge
    - will allow for incremental merges
    - adds 'i' on the merge popup itself for starting incremental merges
    - incremental merges have the benefit of having minimal conflicts during one merging session,
      whenever one merge conflict is resolved, this can be persisted in the repo (can be published, left off, picked up again ...)
    - for more information look [[https://github.com/mhagger/git-imerge][here]]
    #+BEGIN_SRC emacs-lisp
      (when git-imerge-installed
        (use-package magit-imerge
          :after ( magit)))
    #+END_SRC
*** magit lfs
    #+BEGIN_SRC emacs-lisp
    (when git-lfs-installed 
      (use-package magit-lfs
        ;; :defer 40
        :after ( magit)))
    #+END_SRC
*** forge (magit access to pull requests on github/gitlab)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package forge
      :after magit
      :ensure t)
    #+END_SRC
** gitignore (creation with helm)
   simply call helm-gitignore and select language for which to create this gitignore
 #+BEGIN_SRC emacs-lisp
   (when (eq gb/completion-framework 'helm)
     (use-package helm-gitignore
       :commands helm-gitignore
       :after ( helm)))
 #+END_SRC
** IMPLEMENT code library
   - [ ] add code mappings (java, clojure)
   - [ ] eval usefulness
 #+BEGIN_SRC emacs-lisp
 (when (locate-library "code-library")
  (use-package code-library))
 #+END_SRC
** speedbar (currently disabled, see sidebar)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package sr-speedbar
     :after ( bind-key)
     :config
     ;;================================================== sr-speedbar
     (setq sr-speedbar-right-side nil) ;; put on left side
     (setq sr-speedbar-default-width 50)
     (setq sr-speedbar-auto-refresh nil)
     (setq speedbar-use-images nil)
     (setq speedbar-update-flag nil)
     (setq speedbar-indentation-width 2)
     (setq speedbar-show-unknown-files t)

     (sr-speedbar-open) ;; gnus shows errors if speedbar was not open once (maybe because of the advice following delete other window)
     (sr-speedbar-toggle) ;; but since I dont want it to show in the beginning its toggled to hide
     ;; (other-window 1) ;; move cursor on to the scratch buffer
     ;; (enlarge-window-horizontally 32) ;; make sure that the "main" window is larger than the speed bar window (even when maximized later on)

     ;; adjustments for speedbar behaviour (speedbar is not becoming main window!)
     (defadvice delete-other-windows (after my-sr-speedbar-delete-other-window-advice activate)
       "Check whether we are in speedbar, if it is, jump to next window."
       (let ()
         (when (and (sr-speedbar-window-exist-p sr-speedbar-window)
                    (eq sr-speedbar-window (selected-window)))
           (other-window 1)
           )))
     (ad-enable-advice 'delete-other-windows 'after 'my-sr-speedbar-delete-other-window-advice)
     (ad-activate 'delete-other-windows)
     ;; (bind-key "s-a" 'sr-speedbar-toggle)
     )
 #+END_SRC
** markdown
   - see usage documentation on [[http://jblevins.org/projects/markdown-mode/][homepage]]
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :commands (markdown-mode gfm-mode)
       :bind (:map markdown-mode-map
                   ("<M-down>" . markdown-move-subtree-down)
                   ("<M-up>" . markdown-move-subtree-up))
       :mode (("\\.text\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode)
              ("README\\.md\\'" . gfm-mode)
              ("\\.md\\'" . markdown-mode)))
   #+END_SRC
** markdown code block edit (obsolete since markdown-mode includes code edit now)
   - allows C-' in a markdown code block to edit code in a separate buffer (like org mode does)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package markdown-edit-indirect
       :after ( markdown-mode edit-indirect)
       :bind (:map markdown-mode-map
                   ("C-c '" . markdown-edit-indirect)))
   #+END_SRC
** plantuml
   - https://github.com/skuro/plantuml-mode
   #+BEGIN_SRC emacs-lisp 
       (custom-set-variables
        '(org-plantuml-jar-path (concat user-emacs-directory "plantuml.jar"))
        '(plantuml-jar-path (concat user-emacs-directory "plantuml.jar")))
     (use-package plantuml-mode
       :ensure t
       :after ( org)
       :mode ("\\.\\(puml\\|plantuml\\)\\'" . plantuml-mode)
       :config
       ;; (autoload 'plantuml-mode "plantuml-mode" nil t)
       (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
       ;; (add-to-list 'auto-mode-alist '("\\.puml$" . plantuml-mode))
       ;;(add-to-list 'auto-mode-alist '("\\.plantuml$" . plantuml-mode))
       )
     (use-package flycheck-plantuml
       :ensure t
        :after ( flycheck plantuml-mode)
        ;; :defer t
        :init
        (flycheck-plantuml-setup)
          ;; (add-to-list 'puml-mode-hook #'(lambda () (message "enable flycheck")))
        )
   #+END_SRC
** dumb jump to definition
    - C-M g    jump to definition
    - C-M p    jump back
    - C-M q    like jump but shows tooltip
    #+BEGIN_SRC emacs-lisp
      (use-package dumb-jump
        :ensure t
        :config
        (dumb-jump-mode))
    #+END_SRC
** cucumber tests for emacs
   mode for editing cucumber tests (*.feature)
   see [[https://github.com/ecukes/ecukes][here]]
   example project [[file:~/devel/emacs/Cask][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package feature-mode
     ;; :defer 7
     )
   (use-package ecukes
     ;; :defer 7
     )
   (use-package espuds
     ;;:defer 7
     )
   #+END_SRC
* shell
** eshell
   #+begin_src emacs-lisp 
     ;; provide eldoc within eshell (and some more help)
     (use-package esh-help
       :after ( eshell)
       :config (setup-esh-help-eldoc))
     ;; provide z command in eshell  
     (use-package eshell-z
       :after ( eshell))
     (use-package eshell
       :config
       (progn
         (setq eshell-cmpl-autolist t)
         (setq eshell-cmpl-cycle-completions nil)
         (setq eshell-show-lisp-completions t)

         ;; (defun pcmpl-git-commands ()
         ;;   "Return the most common git commands by parsing the git output."
         ;;   (with-temp-buffer
         ;;     (call-process-shell-command "LC_ALL=en_US git" nil (current-buffer) nil "help" "--all")
         ;;     (goto-char 0)
         ;;     (search-forward "available git commands")
         ;;     (let (commands)
         ;;       (while (re-search-forward
         ;;               "^[[:blank:]]+\\([[:word:]-.]+\\)[[:blank:]]*\\([[:word:]-.]+\\)?"
         ;;               nil t)
         ;;         (push (match-string 1) commands)
         ;;         (when (match-string 2)
         ;;           (push (match-string 2) commands)))
         ;;       (sort commands #'string<))))

         ;; (defconst pcmpl-git-commands (pcmpl-git-commands)
         ;;   "List of `git' commands.")

         ;; (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
         ;;   "The `git' command to run to get a list of refs.")

         ;; (defun pcmpl-git-get-refs (type)
         ;;   "Return a list of `git' refs filtered by TYPE."
         ;;   (with-temp-buffer
         ;;     (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
         ;;     (goto-char (point-min))
         ;;     (let (refs)
         ;;       (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
         ;;         (push (match-string 1) refs))
         ;;       (nreverse refs))))

         ;; (defun pcmpl-git-remotes ()
         ;;   "Return a list of remote repositories."
         ;;   (split-string (shell-command-to-string "git remote")))

         ;; (defun pcomplete/git ()
         ;;   "Completion for `git'."
         ;;   ;; Completion for the command argument.
         ;;   (pcomplete-here* pcmpl-git-commands)
         ;;   (cond
         ;;    ((pcomplete-match "help" 1)
         ;;     (pcomplete-here* pcmpl-git-commands))
         ;;    ((pcomplete-match (regexp-opt '("pull" "push")) 1)
         ;;     (pcomplete-here (pcmpl-git-remotes)))
         ;;    ;; provide branch completion for the command `checkout'.
         ;;    ((pcomplete-match "checkout" 1)
         ;;     (pcomplete-here* (append (pcmpl-git-get-refs "heads")
         ;;                              (pcmpl-git-get-refs "tags"))))
         ;;    (t
         ;;     (while (pcomplete-here (pcomplete-entries))))))

         (defun company-eshell-history (command &optional arg &rest ignored)
           (interactive (list 'interactive))
           (cl-case command
             (interactive (company-begin-backend 'company-eshell-history))
             (prefix (and (eq major-mode 'eshell-mode)
                          (let ((word (company-grab-word)))
                            (save-excursion
                              (eshell-bol)
                              (and (looking-at-p (s-concat word "$")) word)))))
             (candidates (remove-duplicates
                          (->> (ring-elements eshell-history-ring)
                               (remove-if-not (lambda (item) (s-prefix-p arg item)))
                               (mapcar 's-trim))
                          :test 'string=))
             (sorted t)))

         ;; (add-to-list 'company-backends 'company-eshell-history)
         ))
   #+end_src
** settings
   #+BEGIN_SRC emacs-lisp
     ;; make sure M-x shell opens into currently open window (and does not open a new one)
     (add-to-list 'display-buffer-alist
                  '("^\\*shell.*\\*$" . (display-buffer-same-window)))
     (require 'comint) ;; part of emacs
     (setq comint-password-prompt-regexp
           ;; (concat comint-password-prompt-regexp
           "\\(passphrase \\|PIN: \\|password\\|Password\\).*\\'" ;; [:blank:]?:[:blank:]*
           ;; )
           )

     (setq-default sh-basic-offset 2)
     (setq-default sh-indentation 2)
     ;; (setq comint-scroll-show-maximum-output nil)
     ;; (setq term-scroll-show-maximum-output nil)
     ;; (setq eshell-scroll-show-maximum-output nil)
     ;; (setq warning-suppress-types '((undo discard-info)))
     (when (eq gb/completion-framework 'helm)
       (bind-key "<M-up>" #'helm-comint-input-ring comint-mode-map)
       (bind-key "<C-S-up>" #'helm-comint-prompts comint-mode-map))
     (bind-key "<M-S-up>" #'counsel-shell-history comint-mode-map)
     (bind-key "C-c C-k" #'comint-continue-subjob comint-mode-map)
     (bind-key "<tab>" #'company-complete comint-mode-map)
   #+END_SRC
** tmux (disabled for now)
   - enables interaction with tmux sessions
   - see https://github.com/syohex/emacs-emamux
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (eq gb/completion-framework 'helm)
       (use-package emamux
         :config
         ;; (global-set-key (kbd "C-z") emamux:keymap)
         (custom-set-variables
          '(emamux:completing-read-type 'helm))))
   #+END_SRC
** dirtrack mode
   - needs some experimentation
   - currently working local (if 'export PS1="[\$PWD]$ "' is set in shell!)
   #+begin_src emacs-lisp
     (use-package dirtrack
       ;; :ensure t  ;; internal packages seem not load correctly if ensured
       :config
       (add-hook 'shell-mode-hook
                 (lambda ()
                   (shell-dirtrack-mode 0) ;stop the usual shell-dirtrack mode
                                             ;(setq ssh-directory-tracking-mode 'ftp)
                   (setq dirtrack-list (quote ("^.*\\[\\(.*:\\)?\\(.*\\)\\]" 2)))
                   ;; (dirtrack-debug-mode) ;this shows any change in directory that dirtrack mode sees
                   (dirtrack-mode))))
   #+end_src
** shell here
   #+BEGIN_SRC emacs-lisp
   ;; open a shell at the current directory
   (use-package shell-here
     ;; :after (eldoc-overlay)
     :config
     (defun gb/install-proc-listener (&rest r)
       "install process listener to close window ofter exited or finished message"
       (message "advicing to exit buffer")
       (let ((process (get-buffer-process (current-buffer))))
         (when process
           (set-process-sentinel
            process
            (lambda (_proc change)
              (when (string-match-p "\\(?:finished\\|exited\\)" change)
                (progn
                  (kill-buffer (current-buffer)))))))))
     (advice-add 'shell-here :after #'gb/install-proc-listener)
     :bind (("C-x C-h" . shell-here)
            :map dired-mode-map
            ("C-x C-h" . shell-here)))
   ;;      (define-key (current-global-map) "\C-c!" 'shell-here) ;
   #+END_SRC
** shell ansi colors configuration (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ansi-color
       :init (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
       (add-hook 'comint-preoutput-filter-functions 'ansi-color-filter-apply)
       :ensure t
       :hook (compilation-filter . colorize-compilation-buffer)
       :preface
       (autoload 'ansi-color-apply-on-region "ansi-color")
       (defun colorize-compilation-buffer ()
         (let ((inhibit-read-only t))
           (ansi-color-apply-on-region (point-min) (point-max))))
       :config
       (setq ansi-color-names-vector
             ["black" "tomato" "PaleGreen2" "gold1"
              "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])
       (setq ansi-color-map (ansi-color-make-color-map))

       (add-to-list 'comint-output-filter-functions 'ansi-color-process-output))
   #+END_SRC
** xterm color
   #+BEGIN_SRC emacs-lisp
     (use-package xterm-color
       :ensure t
       :init
       (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter)
       ;; eterm-color-256 expects existence of this function
       ;; detected in: eterm-color-256: 0.3.12, xterm-color 1.7
       :config
       (defalias 'xterm-color--256 'xterm-color-256)
       ;; (progn (setq comint-output-filter-functions (remove 'ansi-color-process-output comint-output-filter-functions)))
       )
   #+END_SRC
** friendly iteractive shell (deactivated)
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun shell-fish ()
       "start a friendly interactive shell (fish) within ansi-term"
       (interactive)
       (ansi-term (executable-find "fish")))
   #+END_SRC
** bash completion
   - native completion
     #+begin_src emacs-lisp
       (use-package native-complete
         :load-path "~/.emacs.d/additionals"
         :bind (:map shell-mode-map
                ("M-/" . company-native-complete))
         :config (native-complete-setup-bash))
     #+end_src
   - bash completion
   #+BEGIN_SRC emacs-lisp
     (use-package bash-completion
       :ensure t
       :config
       (setq bash-completion-prog (s-trim (shell-command-to-string "command -v bash")))
       (bash-completion-setup))
   #+END_SRC
** shell (bash) checking
   - built in shell editing mode, explicitly initialized here to enable flycheck-mode
   #+BEGIN_SRC emacs-lisp
     (use-package sh-script
       :after ( flycheck)
       ;; :ensure t ;; internal packages seem not load correctly if ensured
       :init
       (add-hook 'sh-mode-hook 'flycheck-mode))
   #+END_SRC
** zshell
   #+BEGIN_SRC emacs-lisp
   (defun start-zsh ()
     "start a  z shell within ansi-term"
     (interactive)
     (ansi-term (s-trim (shell-command-to-string "command -v zsh"))))
   #+END_SRC
* ebooks
  #+BEGIN_SRC emacs-lisp
  (use-package ereader
    :after ( xml+ dash)
    :ensure t
    :mode ("\\.epub\\'" . ereader-mode))
  #+END_SRC
* pdf-tooling
  - TODO check whether all that is required tools are installed for pdf tools to function, message if not, install if ok
  #+BEGIN_SRC emacs-lisp
    ;; allow in emacs pdf view/annotate etc.
    ;; if not functional do the following: remove package and restart emacs, then allow rebuild of pdf tooling, restart again
    ;; new: use pdf-tool-install (works with nix os too, has to be a new version of pdf-tools though!)
    ;; old: to install under linux run 'sudo nix-shell -p autoconf automake libpng zlib poppler pkgconfig gcc --run make' in the build folder
    (if (and make-installed (or running-nixos poppler-installed) imagemagick-installed)
        (use-package pdf-tools
          :ensure t
          :mode ("\\.[pP][dD][fF]$" . pdf-view-mode)
          :init (progn
                  ;; (add-hook 'after-init-hook 'pdf-tools-install)
                  ;; (add-hook 'pdf-tools-mode-hook 'pdf-isearch-minor-mode)
                  (add-hook 'pdf-view-mode-hook 'pdf-misc-minor-mode) ;; misc minor mode offset C-c C-p for printing pdf documents


                  ;; copied from http://babbagefiles.blogspot.de/2017/11/more-pdf-tools-tricks.html
                  ;; automatically turns on midnight-mode for pdfs
                  (add-hook 'pdf-view-mode-hook (lambda () (pdf-view-midnight-minor-mode) (pdf-isearch-minor-mode)))

                  (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; set default profile

                  (defun gb/pdf-no-filter ()
                    "View pdf without colour filter."
                    (interactive)
                    (pdf-view-midnight-minor-mode -1)
                    )

                  ;; change midnite mode colours functions
                  (defun gb/pdf-midnite-original ()
                    "Set pdf-view-midnight-colors to original colours."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-amber ()
                    "Set pdf-view-midnight-colors to amber on dark slate blue."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; amber
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-green ()
                    "Set pdf-view-midnight-colors to green on black."
                    (interactive)
                    (setq pdf-view-midnight-colors '("#00B800" . "#000000" )) ; green
                    (pdf-view-midnight-minor-mode)
                    )

                  (defun gb/pdf-midnite-colour-schemes ()
                    "Midnight mode colour schemes bound to keys"
                    (local-set-key (kbd "!") (quote gb/pdf-no-filter))
                    (local-set-key (kbd "@") (quote gb/pdf-midnite-amber))
                    (local-set-key (kbd "#") (quote gb/pdf-midnite-green))
                    (local-set-key (kbd "$") (quote gb/pdf-midnite-original))
                    )

                  (add-hook 'pdf-view-mode-hook 'gb/pdf-midnite-colour-schemes)

                  ;; got from https://emacs.stackexchange.com/questions/24738/how-do-i-rotate-pages-in-pdf-tools/24766
                  (defun pdf-view--rotate (&optional counterclockwise-p page-p)
                    "Rotate PDF 90 degrees.  Requires pdftk to work.\n
    Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
    non-nil for the other direction.  Rotate the whole document by
    default; set PAGE-P to non-nil to rotate only the current page.
    \nWARNING: overwrites the original file, so be careful!"
                    ;; error out when pdftk is not installed
                    (if (null (executable-find "pdftk"))
                        (error "Rotation requires pdftk")
                      ;; only rotate in pdf-view-mode
                      (when (eq major-mode 'pdf-view-mode)
                        (let* ((rotate (if counterclockwise-p "left" "right"))
                               (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
                               (page   (pdf-view-current-page))
                               (pages  (cond ((not page-p)                        ; whole doc?
                                              (format "1-end%s" rotate))
                                             ((= page 1)                          ; first page?
                                              (format "%d%s %d-end"
                                                      page rotate (1+ page)))
                                             ((= page (pdf-info-number-of-pages)) ; last page?
                                              (format "1-%d %d%s"
                                                      (1- page) page rotate))
                                             (t                                   ; interior page?
                                              (format "1-%d %d%s %d-end"
                                                      (1- page) page rotate (1+ page))))))
                          ;; empty string if it worked
                          (if (string= "" (shell-command-to-string
                                           (format (concat "pdftk %s cat %s "
                                                           "output %s.NEW "
                                                           "&& mv %s.NEW %s")
                                                   file pages file file file)))
                              (pdf-view-revert-buffer nil t)
                            (error "Rotation error!"))))))

                  (defun gb/pdf-view-rotate-clockwise (&optional arg)
                    "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
    entire document."
                    (interactive "P")
                    (pdf-view--rotate nil (not arg)))

                  (defun gb/pdf-view-rotate-counterclockwise (&optional arg)
                    "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
    rotate entire document."
                    (interactive "P")
                    (pdf-view--rotate :counterclockwise (not arg)))

                  )
          :config
          (progn
            ;; (setq pdf-info-epdfinfo-program "~/.emacs.d/elpa/pdf-tools-20180428.1527/build/server/epdfinfo")
            (setq pdf-misc-print-programm (s-trim (shell-command-to-string "command -v lp")))
            (setq pdf-view-display-size (quote fit-page))
            (setq pdf-misc-print-programm-args '("-o" "media=A4" "-o" "sides=two-sided-long-edge"))


            ;; the following routines patch the misbehaviour of pdf-tools on my configuration, not (re)displaying the pdf,
            ;; if: zoom mode is NOT full page AND page change is executed while NOT being on vscroll position 0
            ;; adjustment not working with new pdf-tools
            (defun gb/pdf-view-next-page ()
              (interactive)
              ;; (image-scroll-down 100)
              (pdf-view-next-page)
              (image-bob)
              (image-bol 1))
            (defun gb/pdf-view-previous-page ()
              (interactive)
              (pdf-view-previous-page)
              (image-eob)
              (image-bol 1)
              ;; (image-scroll-down 10)
              ;; (image-scroll-up 100)
              )
            (defun gb/pdf-view-jump-to-begin ()
              (interactive)
              ;; (image-scroll-down 100)
              (pdf-view-first-page)
              (image-bob)
              (image-bol 1))
            (defun gb/pdf-view-jump-to-end ()
              (interactive)
              ;; (image-scroll-down 100)
              (pdf-view-last-page)
              (image-eob)
              (image-bol 1))

            (bind-key "n" #'gb/pdf-view-next-page pdf-view-mode-map)
            (bind-key "p" #'gb/pdf-view-previous-page pdf-view-mode-map)
            (bind-key "M-<" #'gb/pdf-view-jump-to-begin pdf-view-mode-map)
            (bind-key "M->" #'gb/pdf-view-jump-to-end pdf-view-mode-map)

            ;; since the regular routine does not detect the end of page correctly ...
            (defun gb/pdf-view-scroll-up-or-next-page (orig-func &rest args)
              (interactive)
              (let ((vscroll-before (window-vscroll))
                    (cur-page (pdf-view-current-page)))
                (apply orig-func args)
                (when (and (= cur-page (pdf-view-current-page)) (= vscroll-before (window-vscroll))) ;; if scroll position before is exactly the same as after, jump to next page
                  (gb/pdf-view-next-page))))

            ;; (advice-remove 'pdf-view-scroll-up-or-next-page #'gb/pdf-view-scroll-up-or-next-page)
            (advice-add 'pdf-view-scroll-up-or-next-page :around #'gb/pdf-view-scroll-up-or-next-page)
            )))
  #+END_SRC
* rest
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; '(canlock-password "0e8b34f24c62bdf6cc5585ec93c62be865aee099")
   '(auto-hscroll-mode t)
   '(coffee-tab-width 4)
   '(cursor-in-non-selected-windows nil)
   '(desktop-save nil)
   '(desktop-save-mode nil)
   ;; '(gnutls-verify-error nil)
   '(iedit-toggle-key-default nil) ;; disable C-; binding of iedit that is loaded via lispy
   '(ido-mode nil) ;; disable ido mode
   '(jde-jdk-doc-url "https://docs.oracle.com/javase/8/docs/api/")
   '(malabar-repl-grooysh (s-trim (shell-command-to-string "command -v groovysh")))
   '(recentf-max-saved-items 80)
   '(region ((t (:background "gray45" :inverse-video nil))))
   '(send-mail-function (quote smtpmail-multi-send-it))
   '(truncate-lines t)
   '(default-truncate-lines t)
   '(xslt-process-registered-stylesheets nil))

  (cond
   ((eq gb/theme-mode 'light) nil) ;; TODO complete
   (t (progn
        (--each '((col-highlight ((t (:background "gray63"))))
                  (hi-yellow ((t (:background "gray44"))))
                  (region ((t (:background "gray45" :inverse-video nil))))
                  (popup-isearch-match ((t (:background "RoyalBlue2"))))
                  (term-color-yellow ((t (:background "DarkGoldenrod4" :foreground "#f0c674")))))
          (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
#+END_SRC
* play startup sound (check again 4)
  #+begin_src emacs-lisp
    ;; if not playing test again and play 4
    (gb/play-startup-sound-when-ctrlkey-down)
  #+end_src
* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs
          `(,(concat user-emacs-directory "snippets"))) ;; my snippets library


    (cond
     ((eq gb/theme-mode 'light) nil) ;; TODO complete
     (t (progn
          (--each '((yas-field-highlight-face ((t (:background "gray20")))))
            (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))

    (custom-set-faces '(yas-field-highlight-face)) ;; yas-field

    (add-hook 'prog-mode-hook #'yas-minor-mode) ;; make it a submode of all programming modes
    (yas-global-mode 1) ;; make it global

    ;; Completing point by some yasnippet key
    (defun yas-ido-expand ()
      "Lets you select (and expand) a yasnippet key"
      (interactive)
      (let ((original-point (point)))
        (while (and
                (not (= (point) (point-min) ))
                (not (string-match "[[:space:]\n]" (char-to-string (char-before)))))
          (backward-word 1))
        (let* ((init-word (point))
               (word (buffer-substring init-word original-point))
               (list (yas-active-keys)))
          (goto-char original-point)
          (let ((key (remove-if-not
                      (lambda (s) (string-match (concat "^" word) s)) list)))
            (if (= (length key) 1)
                (setq key (pop key))
              (setq key (ido-completing-read "key: " list nil nil word)))
            (delete-char (- init-word original-point))
            (insert key)
            (yas-expand)))))


    (when (package-installed-p 'company)

      ;; Add yasnippet support for all company backends
      ;; https://github.com/syl20bnr/spacemacs/pull/179
      (defvar company-mode/enable-yas t
        "Enable yasnippet for all backends.")

      ;; instrument a backend ":with company-yasnippet"
      (defun company-mode/backend-with-yas (backend)
        (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      ;; instrument all existing backends with yasnippet
      (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

      ;; make sure that M-<tab> is available in yas-minor-mode
      (define-key yas-minor-mode-map (kbd "M-<tab>") #'company-try-hard)))
#+END_SRC
** yankpad
   - init (setq yankpad-file "~/yankpad.org")
   - use functions yankpad-map, yankpad-expand
   - see [[https://github.com/Kungsgeten/yankpad][homepage]]
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "yankpad")
     (use-package yankpad
       :init
       (when (package-installed-p 'company)
         ;; If you want to complete snippets using company-mode
         ;; (add-to-list 'company-backends #'company-yankpad)
         )
       :config
       (setq yankpad-file "~/yankpad.org")))
   #+END_SRC
* organizational (org, mail, news)
** elfeed
 #+BEGIN_SRC emacs-lisp
   (use-package elfeed
     :ensure t
     :commands elfeed
     :bind (:map elfeed-search-mode-map
                 ("l" . recenter-top-bottom)
                 :map elfeed-show-mode-map
                 ("l" . recenter-top-bottom))
     :config
     (progn
       (setq elfeed-use-curl t)
       (setq shr-width 80)
       (setq shr-image-animate nil)
       (cond
        ((eq gb/theme-mode 'light) nil) ;; TODO complete
        (t (progn
             (--each '((elfeed-search-feed-face ((t (:foreground "NavajoWhite2"))))
                       (elfeed-search-title-face ((t (:foreground "dark gray"))))
                       (elfeed-search-unread-title-face ((t (:inherit elfeed-search-title-face :foreground "DarkOrange2")))))
               (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))

   ;; Load elfeed-org
   (use-package elfeed-org
     :ensure t
     :after ( elfeed org dash)
     :init (progn
             ;; TOOD fix function that is not known here
             ;; only programming related books
             ;; (add-hook 'elfeed-new-entry-hook
             ;;           (elfeed-make-tagger :feed-url "pdfbooksplanet"
             ;;                               :entry-link '(not "programming")
             ;;                               :add 'junk
             ;;                              :remove 'unread))

             ;; only programming related books
             ;; (add-hook 'elfeed-new-entry-hook
             ;;          (elfeed-make-tagger :feed-url "BookDL"
             ;;                              :entry-link '(not "programming")
             ;;                             :add 'junk
             ;;                              :remove 'unread))

             ;; (add-hook 'elfeed-new-entry-hook
             ;;          (elfeed-make-tagger :feed-url "lobste\\.rs"
             ;;                              :entry-link '(not "emacs")
             ;;                              :add 'junk
             ;;                              :remove 'unread))

             )
     :config
     (progn

       ;; Initialize elfeed-org
       ;; This hooks up elfeed-org to read the configuration when elfeed
       ;; is started with =M-x elfeed=
       (elfeed-org)


       ;; Optionally specify a number of files containing elfeed
       ;; configuration. If not set then the location below is used.
       ;; Note: The customize interface is also supported.
       (setq rmh-elfeed-org-files (list "~/elfeed.org"))

       ;; show all news one week ago either unread or keep
       (setq-default elfeed-search-filter "@6-months-old +unread")

       (setf url-queue-timeout 30)


       ;; (setq elfeed-search-filter "@6-months-old +unread")
       ))

   (use-package noflet)

   (use-package elfeed-goodies
     :ensure t
     :after ( elfeed popwin noflet ace-jump-mode) ;; powerline
     :config
     (progn
       (setq elfeed-goodies/entry-pane-size 0.5)
       (setq elfeed-goodies/powerline-default-separator (quote bar))
       (setq elfeed-goodies/tag-column-width 30)
       (elfeed-goodies/setup)
       ;; overwrite default function of elfeed goodies. elfeed maps this to M-v upon mode init
       (defun elfeed-goodies/show-ace-link ()
         (interactive)
         (scroll-down-command))))
 #+END_SRC
** diary
   #+begin_src emacs-lisp
     (when (boundp 'gb/private-google-calendar-url)
       (require 'appt)

       (when (file-exists-p gb/diary-calendar-file)
         (setq diary-file gb/diary-calendar-file))

       (defun gb/sync-update-agenda-with-google-calendar ()
         "synchronous update diary with google calendar"
         (shell-command-to-string (format "wget -q -O %s-temp %s" gb/itemis-calendar-file gb/itemis-google-calendar-url))
         (shell-command-to-string (format "wget -q -O %s-temp %s" gb/private-calendar-file gb/private-google-calendar-url))
         (gb/import-diary-from-google-calendar-files))

       (defun gb/import-diary-from-google-calendar-files ()
         "import the configured ics calendar files"
         (appt-activate -1)
         (setq diary-file "~/.emacs.d/diary")
         (when (file-exists-p (format "%s-temp" gb/diary-calendar-file))
           (delete-file (format "%s-temp" gb/diary-calendar-file)))
         (--each `(,gb/diary-calendar-file ,gb/itemis-calendar-file ,gb/private-calendar-file)
           (progn
             (when-let ((buffer (get-file-buffer it)))
               (kill-buffer buffer))
             (when-let ((buffer (get-file-buffer (format "%s-temp" it))))
               (kill-buffer buffer))
             (when (file-exists-p it) ;; delete diary-calendar-file also, since it needs to be rewritten!
               (delete-file it))))
         (--each `(,gb/private-calendar-file ,gb/itemis-calendar-file)
           (let ((temp-file (format "%s-temp" it)))
             (when (file-exists-p temp-file)
               (copy-file temp-file it)
               (delete-file temp-file))))
         (with-temp-buffer
           (insert-file gb/itemis-calendar-file)
           (icalendar-import-buffer (format "%s-temp" gb/diary-calendar-file) t t))
         (with-temp-buffer
           (insert-file gb/private-calendar-file)
           (icalendar-import-buffer (format "%s-temp" gb/diary-calendar-file) t t))
         (if (executable-find "python3")
             (shell-command-to-string (format "cat %s | python3 -c \"import sys; from urllib.parse import unquote; print(unquote(sys.stdin.read()));\" > %s" (format "%s-temp" gb/diary-calendar-file) gb/diary-calendar-file))
           (warn "cannot urldecode agenda file (python3 missing)")
           (rename-file (format "%s-temp" gb/diary-calendar-file) gb/diary-calendar-file))
         (shell-command-to-string (format "sed -e \"s/<br\\s*\\/\\?>/\\n /g\" -i %s" gb/diary-calendar-file))
         (shell-command-to-string (format "sed -e \"s/\\&nbsp\\;/ /g\" -i %s" gb/diary-calendar-file))
         (when (file-exists-p (format "%s-temp" gb/diary-calendar-file))
           (delete-file (format "%s-temp" gb/diary-calendar-file)))
         (setq diary-file gb/diary-calendar-file)
         (appt-activate 1)
         (message (format "agenda refresh done (at %s)." (current-time-string))))

       (defun gb/update-agenda-with-google-calendar ()
         "async function to update cal based dictionary"
         (message (format "running agenda refresh (at %s)" (current-time-string)))
         (gb/async-execute-costly-shell-command
          (format "wget -q -O %s-temp %s" gb/itemis-calendar-file gb/itemis-google-calendar-url)
          '(lambda ()
             (gb/async-execute-costly-shell-command
              (format "wget -q -O %s-temp %s" gb/private-calendar-file gb/private-google-calendar-url)
              '(lambda () (gb/import-diary-from-google-calendar-files))))))

       (defun gb/async-execute-costly-shell-command (acommand &optional lambda-on-success lambda-on-failure timeout-s)
         "execute a costly shell function asynchronously.
     allow optional callback functions for success (LAMBDA-ON-SUCCESS) and failure (LAMBDA-ON-FAILURE)
     as well as a new TIMEOUT-S which overrides the default of 10s.

     Example usage:
       (gb/async-execute-costly-shell-command
         \"sleep 4\"
         '(lambda () (message \"success\"))
         '(lambda () (message \"failure\"))
         3)

       Execute \"sleep 4\" asynchronously on the shell, printing \"success\" when finishing
       regularly, printing \"failure\" in case of timeouts, using 3 s as timeout.
       This will run into a timeout, killing the non-finished process.


       (gb/async-execute-costly-shell-command
         \"sleep 4\"
         '(lambda () (message \"success\")))

       This will succeed, printing \"success\" after 4 s.
     "
         (funcall
          `(lambda ()
             (make-thread
              (lambda ()
                (let* ((process (start-process-shell-command "*gen*" nil ,acommand))
                       (timeoutCounter 0)
                       (timeoutAt (or ,timeout-s 10)))
                  (while (and (< timeoutCounter timeoutAt) (process-live-p process))
                    (sleep-for 1)
                    (setq timeoutCounter (1+ timeoutCounter)))
                  (let ((rc (process-exit-status process)))
                    (if (and (not (process-live-p process))
                             (= rc 0))
                        (progn
                          (when ,lambda-on-success
                            (funcall ,lambda-on-success)))
                      (delete-process process)
                      (when ,lambda-on-failure
                        (funcall ,lambda-on-failure))))))))))

       ;; running this function every 5 minutes seems to leak memory (emacs eating up ram)
       ;; (defun gb/start-update-agenda-timer ()
       ;;   "start the timer that updates diary with google calendar entries every 5 minutes"
       ;;   (interactive)
       ;;   (setq gb/update-agenda-timer (run-at-time "5 minutes" (* 5 60) #'gb/update-agenda-with-google-calendar)))

       ;; (defun gb/cancel-update-agenda-timer ()
       ;;   "cancel the timer that updates diary with google calendar entries every 5 minutes"
       ;;   (interactive)
       ;;   (cancel-timer gb/update-agenda-timer))

       (defun gb/org-agenda (&optional arg)
         "run org agenda (list on workspace 7), updating the diary with calendar, first"
         (interactive "P")
         (when arg
           (message "loading calendar files from web")
           (gb/sync-update-agenda-with-google-calendar))
         (when (file-exists-p gb/diary-calendar-file)
           (setq diary-file gb/diary-calendar-file))
         (when (fboundp 'gb/exwm-workspace-switch)
           (gb/exwm-workspace-switch 7))
         (call-interactively #'org-agenda-list))

       (defun gb/org-agenda-refresh (&optional exhaustive)
         (interactive "P")
         (when exhaustive
           (message "loading calendar files from web")
           (gb/sync-update-agenda-with-google-calendar))
         (org-agenda-redo-all exhaustive))

       ;; (bind-key "g" #'gb/org-agenda-refresh org-agenda-mode-map)

       (bind-key "H-a" #'gb/org-agenda)

       ;; run once at startup
       (run-at-time "2 minutes" nil #'gb/update-agenda-with-google-calendar)
       ;; (gb/start-update-agenda-timer)
       ;; (gb/update-agenda-with-google-calendar)
       )
   #+end_src
** gnus (mail)
*** gnu-firstentry
 #+BEGIN_SRC emacs-lisp
   ;; add support to send from different smtp accounts
   ;; do this before custom variables are set, otherwise send-mail-function won't be set correctly!
   (use-package smtpmail-multi)

   ;; closed by gnu-lastentry!
   (use-package gnus
     ;; :commands gnus
     :after ( smtpmail-multi mm-decode hydra bbdb)
     :bind (
            :map gnus-group-mode-map
            ("<f1>" . hydra-gnus-group/body)
            ("C-c b l" . gnus-bookmark-bmenu-list)
            :map gnus-summary-mode-map
            ("<f1>" . hydra-gnus-summary/body)
            ("C-c b l" . gnus-bookmark-bmenu-list)
            ("C-c b m" . gnus-bookmark-set)
            ("C-c b s" . gnus-bookmark-set)
            :map gnus-article-edit-mode-map
            ("<f1>" . hydra-gnus-article-mime-part/body)
            :map gnus-article-mode-map
            ("<f1>" . hydra-gnus-article-mime-part/body)
            ("C-c b l" . gnus-bookmark-bmenu-list)
            :map message-mode-map
            ("<f1>" . hydra-gnus-article-mime-part/body)
            ("TAB" . company-try-hard)
            )
     :init  (progn
              ;; Sign messages by default
              (add-hook 'message-setup-hook 'mml-secure-sign-pgpmime)

              (defun gb/cache-sender-key ()
                "cache the gpg key based on the from field of this message"
                (interactive)

                (save-excursion
                  (save-restriction
                    (message-narrow-to-headers)
                    (let ((from (message-fetch-field "from")))
                      (message (concat "cache password for " from))
                      (gb/cache-gpg-key from)))))

              ;; no need to cache gpg key with a working pinentry-emacs running!
              ;; (add-hook 'gnus-message-setup-hook 'gb/cache-sender-key)

              ;; make sure that truncate lines is off and word wrap is on when viewing articles
              (add-hook 'gnus-article-mode-hook
                        (lambda ()
                          (setq
                           fill-column 60
                           truncate-lines nil
                           word-wrap t))))
     :config ;; closing bracket follows way down !
 #+END_SRC
*** hydra
    #+BEGIN_SRC emacs-lisp
      ;;--------------------------------------------------------------------------------
      (require 'gnus-art)

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-summary ()
        "
              gnus summary
              ------------
              [_W_] : reply w/ original
              [_A_] : reply w/ original and all attachments
              [_v_] : save all mime parts

            %s(hydra-combine-functions-w-key-bindings 
              '((\"  [W] reply w/ original                \" . gnus-summary-wide-reply-with-original)
                (\"  [A] reply w/ original and attachments\" . gnus-summary-mail-forward)
                (\"  [v] save all mime parts              \" . gnus-summary-save-parts)))
            "
        ("W" gnus-summary-wide-reply-with-original :exit t)
        ("A" gnus-summary-mail-forward :exit t)
        ("v" gnus-summary-save-parts :exit t))

      ;;--------------------------------------------------------------------------------
      (defhydra hydra-gnus-group ()
        "
             gnus group view
             ---------------
             [_G_]: search in (marked) group(s)  [_r_]: mark by regular expression   
             [_c_]: make a new group             [_m_]: mark this group              
             [_E_]: edit group                   [_U_]: unmark all groups            
              ^ ^                                [_u_]: unmark current group         

            %s(hydra-combine-functions-w-key-bindings
              '((\" [G] search in (marked) group(s) \" . gnus-group-make-nnir-group)
                (\" [c] make new group              \" . gnus-group-make-group)
                (\" [E] edit group                  \" . gnus-group-edit-group)
                (\" [r] mark by regular expression  \" . gnus-group-mark-regexp)
                (\" [m] mark this group             \" . gnus-group-mark-group)
                (\" [U] unmark all groups           \" . gnus-group-unmark-all-groups)
                (\" [u] unmark current group        \" . gnus-group-unmark-group)))
        "
        ("G" gnus-group-make-nnir-group :exit t)
        ("c" gnus-group-make-group :exit t)
        ("E" gnus-group-edit-group :exit t)
        ("r" gnus-group-mark-regexp)
        ("m" gnus-group-mark-group)
        ("U" gnus-group-unmark-all-groups :exit t)
        ("u" gnus-group-unmark-group))

      (defhydra hydra-gnus-article-mime-part ()
        "
                gnus article mime part
                ----------------------
                _o_: save mime part
                _e_: encrypt message
                _s_: sign message

            %s(hydra-combine-functions-w-key-bindings
                '((\"    [o] save mime part \" . gnus-mime-save-part)
                  (\"    [e] encrypt message\" . mml-secure-message-encrypt-pgpmime)
                  (\"    [s] sign message   \" . mml-secure-message-sign-pgpmime)))
              "
        ("o" gnus-mime-save-part)
        ("e" mml-secure-message-encrypt-pgpmime :exit t)
        ("s" mml-secure-message-sign-pgpmime :exit t))

    #+END_SRC
*** vars
    #+BEGIN_SRC emacs-lisp
      (setq gnus-summary-save-parts-default-mime ".*/.*") ;; default to save all mime parts ('X m' in summary buffer)
      (setq gnus-cache-enter-articles nil)
      (setq gnus-cache-remove-articles (quote (dormant)))
      (setq gnus-extra-headers (quote (To Cc Keywords Gcc Newsgroups Content-Type)))
      (setq gnus-gcc-mark-as-read t)
      (setq gnus-large-newsgroup 800)
      (setq gnus-show-threads nil)
      (setq gnus-use-cache t)
      (setq gnus-visible-headers '("^From:" "^Newsgroups:" "^Subject:" "^Date:" "^Followup-To:" "^Reply-To:" "^Organization:" "^Summary:" "^Keywords:" "^To:" "^[BGF]?Cc:" "^Posted-To:" "^Mail-Copies-To:" "^Mail-Followup-To:" "^Apparently-To:" "^Gnus-Warning:" "^Resent-From:" "^X-Sent:" "^X-AnteSpam-Report:"))

      (setq message-send-mail-function (quote smtpmail-multi-send-it))

      ;; reply signed mails with signed mails
      (setq gnus-message-replysign t)
      (setq mm-decrypt-option (quote always))

      ;; nil = use default key to sign
      ;; guided = make sure that whenever signing is necessary, user is queried to select key
      (setq mm-sign-option nil)
      ;; use the sender to select default key
      (setq mml-secure-openpgp-sign-with-sender t)
      (setq mm-verify-option (quote known))
      ;; if no key is found, ask use which to use, or what to do
      (setq mml-secure-fail-when-key-problem nil)
      ;; (setq mml-secure-openpgp-signers '("0xE1ADB507AF17A860489F07080D64ED7DB693CA8B"))

      (setq mm-fill-flowed nil)
      (setq mm-inline-large-images (quote resize))
      (setq mm-html-blocked-images ".*") ;; block images
      (setq mm-enable-external nil) ;; don't allow execution of external programs for mm parts
      (setq gnus-inhibit-images t) ;; don't show any images in html messages

      (setq nnmail-extra-headers (quote (To Newsgroups Cc Content-Type)))

      ;; gnus will try to build threads from old headers
      (setq gnus-fetch-old-headers t)
    #+END_SRC
*** gravatar
    - see [[https://www.gnu.org/software/emacs//manual/html_mono/gnus.html#Gravatars][here]]
    #+BEGIN_SRC emacs-lisp
    (setq gnus-treat-from-gravatar 'head) ;; show gravatar in from line
    ;; (setq gnus-treat-mail-gravatar 'head) ;; show gravator in to and cc line
    (setq gnus-gravatar-size 75)          ;; size of gravatar (in pixel)
    #+END_SRC
*** ui
 #+BEGIN_SRC emacs-lisp
   ;; eww background coloring (to prevent light gray background in htlm mails)
   (setq shr-color-visible-luminance-min 80)
   (setq shr-use-fonts nil) ;; don't use proportional fonts

   ;; remove image from the list of inline displayed elements in mails
   (setq mm-inlined-types
         '("text/.*"
           "message/delivery-status"
           "message/rfc822"
           "message/partial"
           "message/external-body"
           "application/x-patch"
           "application/emacs-lisp"
           "application/x-emacs-lisp"
           "application/pgp-signature"
           "application/x-pkcs7-signature"
           "application/pkcs7-signature"
           "application/x-pkcs7-mime"
           "application/pkcs7-mime"
           "application/x-gtar-compressed"
           "application/x-tar"
           "application/zip"
           "application/pgp"))

   ;; Gnus formatting and colorizing

   ;; customize org link
   (cond
    ((eq gb/theme-mode 'light) nil) ;; TODO complete
    (t (progn
         (--each '( (org-link ((t (:foreground "#81a2be" :underline (:style line :color "#41526e")))))
                    (org-date ((t (:foreground "#81a2be" :underline (:style line :color "#41526e"))))))
           (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))

         (copy-face 'default 'mysubject)
         (setq gnus-face-1 'mysubject)

         (copy-face 'default 'mytime)
         (set-face-foreground 'mytime "cornflowerblue")
         (setq gnus-face-2 'mytime)

         (copy-face 'default 'mythreads)
         (set-face-foreground 'mythreads "turquoise")
         (setq gnus-face-3 'mythreads)

         (copy-face 'default 'mygrey)
         (set-face-foreground 'mygrey "blue")
         (setq gnus-face-4 'mygrey)

         (copy-face 'default 'myblack)
         (set-face-foreground 'myblack "gold")
         (setq gnus-face-5 'myblack)

         (copy-face 'default 'mybiggernumbers)
         (set-face-foreground 'mybiggernumbers "seagreen")
         (setq gnus-face-6 'mybiggernumbers))))


   (defun gnus-user-format-function-@ (header)
     "Display @ for message with attachment in summary line.
   You need to add `Content-Type' to `nnmail-extra-headers' and
   `gnus-extra-headers', see Info node `(gnus)To From Newsgroups'."
     (let ((case-fold-search t)
           (ctype (or (cdr (assq 'Content-Type (mail-header-extra header)))
                      "text/plain"))
           (indicator " ")
           (header-extra (mail-header-extra header))) ;; <-- check this
       (when  (or (string-match "^text/calendar" ctype) ;; calendar is deeply nested within, but this check works only for top level types
                  (string-match "^multipart/mixed" ctype))
         (setq indicator "@"))
       indicator))

   ;; make sure that (safe) inline images are shown in html messages
   (if w3m-installed
       (setq mm-text-html-renderer 'w3m))
   (setq gnus-inhibit-images nil)
   (setq w3m-display-inline-image t)
   (setq mm-html-inhibit-images nil) ;; allow inlining images
   ;; (setq mm-attachment-override-types '("image/.*"
   ;;                    "text/x-vcard"
   ;; 				   "application/pkcs7-mime"
   ;; 				   "application/x-pkcs7-mime"
   ;; 				   "application/pkcs7-signature"
   ;; 				   "application/x-pkcs7-signature"))
   (add-to-list 'mm-attachment-override-types "image/.*")

   ;; provide buttons to select between html message and pure text message!
   (setq gnus-buttonized-mime-types
         '("multipart/alternative" "multipart/signed")
         mm-discouraged-alternatives
         '("text/html" "image/.*"))

   (setq gnus-summary-line-format
         (concat
          "%*%5{%U%R%z%}" ;; (U)nread (R)eplied (z)??
          "%4{|%}"
          "%2{%-5N%}" ;; (N) article number
          "%4{|%}"
          "%2{%-10&user-date;%}" ;; date
          "%4{|%}"
          "%5{%u&@;%}"  ;; gnus-user-format-function-@ to print @ for messages with attachments
          "%2{ %}%(%-24,24f" ;; (f) prints from (if not ignored address, else to)!
          "%4{|%}"
          "%2{%6k %}%)" ;; (k) human readable size
          "%4{|%}"
          "%2{ %}%3{%B%}%1{%s%}\n") ;; (s)ubject
         )

   ;; (cond (window-system
   ;;        (setq custom-background-mode 'light)
   ;;        (defface my-group-face-1
   ;;          '((t (:foreground "Red" :bold t))) "First group face")
   ;;        (defface my-group-face-2
   ;;          '((t (:foreground "DarkSeaGreen4" :bold t)))
   ;;          "Second group face")
   ;;        (defface my-group-face-3
   ;;          '((t (:foreground "Green4" :bold t))) "Third group face")
   ;;        (defface my-group-face-4
   ;;          '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
   ;;        (defface my-group-face-5
   ;;          '((t (:foreground "Blue" :bold t))) "Fifth group face")))

   ;; (setq gnus-group-highlight
   ;;       '(((> unread 200) . my-group-face-1)
   ;;         ((and (< level 3) (zerop unread)) . my-group-face-2)
   ;;         ((< level 3) . my-group-face-3)
   ;;         ((zerop unread) . my-group-face-4)
   ;;         (t . my-group-face-5)))

   ;; make the default sorting of all groups to be sorted by date!
   (setq gnus-article-sort-functions '((not gnus-article-sort-by-date)))


   (setq gnus-summary-mode-line-format "Gnus: %p [%A / Sc:%4z] %Z")

   (setq-default
    gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
    gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
    gnus-thread-sort-functions '(gnus-thread-sort-by-date)
    gnus-sum-thread-tree-false-root ""
    gnus-sum-thread-tree-indent " "
    gnus-sum-thread-tree-leaf-with-other " "
    gnus-sum-thread-tree-root ""
    gnus-sum-thread-tree-single-leaf " "
    gnus-sum-thread-tree-vertical "")

   ;; make sure that summary/article are 35%/65% instead of 25%/75% (default)
   ;; (gnus-add-configuration '(article (vertical 1.0 (summary .35 point) (article 1.0))))
   (gnus-add-configuration
    '(article
      (horizontal 1.0 (vertical 50
                                (group 1.0))
                  (vertical 1.0
                            (summary 0.35 point)
                            (article 1.0)))))
   (gnus-add-configuration
    '(summary
      (horizontal 1.0 (vertical 50
                                (group 1.0))
                  (vertical 1.0
                            (summary 1.0 point)))))


   ;; turn off flowed mode
   (setq fill-flowed-display-column nil)


 #+END_SRC
*** polling new mails
 #+BEGIN_SRC emacs-lisp
     ;; make sure a timeout ends this tries if going offline
     (defadvice gnus-demon-scan-news (around gnus-demon-timeout activate)
       "Timeout for Gnus."
       (with-timeout
           (120 (message "Gnus timed out."))
         ad-do-it))

     ;; after gnus is started run timer to retrieve new mails!
     (setq gnus-startup-hook
           '(lambda ()
              (gnus-demon-add-handler 'gnus-demon-scan-news 15 nil) ; this does a call to gnus-group-get-new-news
              ))

     (defun gnus-frequent-check-new-mail ()
       "make checking mails run every 5 minutes"
       (interactive)
       (gnus-check-mail 5))

     (defun gnus-lazy-check-new-mail ()
       "make checking mails run every hour"
       (interactive)
       (gnus-check-mail 60))

     (defun gnus-normal-check-new-mail ()
       "make checking emails run ever 15 minutes"
       (interactive)
       (gnus-check-mail 15))

     (defun gnus-check-mail (minutes)  
       "make checking mails run every minutes"
       (gnus-demon-remove-handler 'gnus-demon-scan-news)
       (gnus-demon-add-handler 'gnus-demon-scan-news minutes nil)
       (message "now check every %s minutes" minutes))
 #+END_SRC
*** group line format
    #+BEGIN_SRC emacs-lisp
    ;; (M) marked articles
    ;; (S) subscribed group indicator
    ;; (G) group name
    ;; (y) # of unread
    ;; (t) estimated total number of articales
    ;; (D) group description
    (setq gnus-group-line-format "%M%S %-27uG %5y/%-10t %D\n")
    #+END_SRC
*** misc
 #+BEGIN_SRC emacs-lisp
     (defun message-toggle-gcc ()
       "Insert or remove the \"Gcc\" header."
       (interactive)
       (save-excursion
         (save-restriction
           (message-narrow-to-headers)
           (if (message-fetch-field "Gcc")
               (message-remove-header "Gcc")
             (gnus-inews-insert-gcc)))))

 #+END_SRC
*** gnu-lastentry
 #+BEGIN_SRC emacs-lisp
 ) ;; closes req-package of gnus!
 #+END_SRC
*** nnir (make mails searchable)
**** add keybindings for searching imap groups (currently 'G G' within top top level)
**** construct hydra
  #+BEGIN_SRC emacs-lisp
    ;; make imap searchable
    ;;(use-package nnir
    ;;  :after ( gnus))
  #+END_SRC
*** accounts (user specific stuff)
    #+BEGIN_SRC emacs-lisp
      (when mail-accounts-exists
            (use-package mail-accounts
              :load-path "~/.emacs.d/accounts/"
              :after (gnus)))
    #+END_SRC
** bbdb
*** bbdb itself
 #+BEGIN_SRC emacs-lisp
     ;; make sure that email addresses are stored in the bbdb (database)

   (use-package bbdb
     :init (progn
     ;; use ; on a message to invoke bbdb interactively
     (add-hook 'gnus-summary-mode-hook
               (lambda ()
                 (define-key gnus-summary-mode-map (kbd ";") 'bbdb-mua-edit-field)
                 )))
     :bind (:map bbdb-mode-map
                 ("S s" . #'bbdb-search-name)
                 ("S n" . #'bbdb-search-name)
                 ("S m" . #'bbdb-search-mail)
                 ("S p" . #'bbdb-search-phone)
                 ("S a" . #'bbdb-search-address))
     :config

     ;; initialization
     (bbdb-initialize 'gnus 'message)
     (bbdb-mua-auto-update-init 'gnus 'message)

     (setq bbdb-layout (quote full-multi-line))

     ;; size of the bbdb popup
     (setq bbdb-pop-up-window-size 5)

     ;; ask for saving bbdb (t = ask, nil = don't ask, other = always save)
     (setq bbdb-offer-save "yes")

     ;; What do we do when invoking bbdb interactively
     (setq bbdb-mua-update-interactive-p '(query . create))

     ;; make sure we look at every address in a message and not only the
     ;; first one
     (setq bbdb-message-all-addresses t)

     (setq bbdb-address-label-list (quote ("" "home" "work" "other")))
     (setq bbdb-file "~/bbdb")
     (setq bbdb-phone-label-list (quote ("" "home" "work" "cell" "other")))

     )


 #+END_SRC
*** incremental search within bbdb (and more) [[https://github.com/aki2o/bbdb-][link]]
**** to open (during writing mails): M-x bbdb-:start-completion
**** keybinding in that mode is then
      j ... Go to next record
      k ... Go to previous record
      h ... Go to previous char
      l ... Go to next char
      J ... Scroll down
      K ... Scroll up
      s ... Start incremental search
      S ... Start incremental search with the reverse configuration about using migemo
      a ... Show all record
      t ... Mark current record as To
      c ... Mark current record as Cc
      b ... Mark current record as Bcc
      u ... Unmark current record
      t ... Mark all listed record as To
      c ... Mark all listed record as Cc
      b ... Mark all listed record as Bcc
      u ... Unmark all listed record
      R ... Reload the latest record of BBDB
      q ... Finish with doing nothing
      RET ... Finish with the update of To/Cc/Bcc header (if necessary, open the mail buffer)
  #+BEGIN_SRC emacs-lisp
    (use-package bbdb-
      :ensure t
      :after ( bbdb)
      :config
      (bbdb-:setup))
  #+END_SRC
*** csv export/import
 #+BEGIN_SRC emacs-lisp
   (use-package bbdb-csv-import
     :after ( bbdb))
 #+END_SRC
*** extensive regex search in bbdb
 #+BEGIN_SRC emacs-lisp
   (use-package bbdb-ext
     :ensure t
     :after ( bbdb))
 #+END_SRC
*** DONE popup window for email selection in mail client (seems to be alternative to bbdb-) (deactivated)
    - seems no longer available
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package bbdb-handy
     :after ( bbdb)
     :config
     (bbdb-handy-enable))
 #+END_SRC
*** export entry as vcard
 #+BEGIN_SRC emacs-lisp
;;   (use-package bbdb-vcard
;;     :after ( bbdb))
 #+END_SRC
** calendar
 #+BEGIN_SRC emacs-lisp
     (setq calendar-latitude 53.55)
     (setq calendar-longitude 9.99)
     (setq calendar-location-name "Hamburg, D")
     (setq european-calendar-style t)
     (setq calendar-week-start-day 1)
     (setq display-time-24hr-format 1)

     (setq calendar-mark-diary-entries-flag t)
     (setq view-diary-entries-initially t)
     ;; the below had to be done if the given entry was not there before hand
     ;; thus all appointments are marked within the calendar now
     ;; echo "%%(org-diary)" >> ~/diary 

     (add-hook 'calendar-today-visible-hook 'calendar-mark-today) ;; mark today within the calendar view
     (custom-theme-set-faces 'user '(calendar-today ((t :foreground "orange"))))
     (custom-theme-set-faces 'user '(calendar-iso-week-face ((t :foreground "lightblue"))))

     ;; code below prints iso calendar weeks into the calendar
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute 'calendar-iso-week-face nil
                         :height 1.0)
     (setq calendar-intermonth-text
           '(propertize
             (format "%2d"
                     (car
                      (calendar-iso-from-absolute
                       (calendar-absolute-from-gregorian (list month day year)))))
             'font-lock-face 'calendar-iso-week-face))

 #+END_SRC
** org
*** org
  #+BEGIN_SRC emacs-lisp
    (use-package org
      :after (hydra)
      :bind (:map  org-mode-map
                   ("<f1>" . hydra-org-mode/body)

                   ("RET" . gb/org-return-dwim)
                   ("S-<return>" . org-return-indent)
                   ("C-<return>" . gb/org-control-return)
                   ("C-c l" . org-store-link)
                   ("C-c t i" . org-toggle-item)
                   ("H-f" . font-lock-fontify-block))
      :init
      ;; thanks to https://pank.eu/blog/pretty-babel-src-blocks.html
      (with-eval-after-load 'org
        (defvar-local rasmus/org-at-src-begin -1
          "Variable that holds whether last position was a ")

        (defvar rasmus/ob-header-symbol ?
          "Symbol used for babel headers")

        (defun rasmus/org-prettify-src--update ()
          (let ((case-fold-search t)
                (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
                found)
            (save-excursion
              (goto-char (point-min))
              (while (re-search-forward re nil t)
                (goto-char (match-end 0))
                (let ((args (org-trim
                             (buffer-substring-no-properties (point)
                                                             (line-end-position)))))
                  (when (org-string-nw-p args)
                    (let ((new-cell (cons args rasmus/ob-header-symbol)))
                      (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                      (cl-pushnew new-cell found :test #'equal)))))
              (setq prettify-symbols-alist
                    (cl-set-difference prettify-symbols-alist
                                       (cl-set-difference
                                        (cl-remove-if-not
                                         (lambda (elm)
                                           (eq (cdr elm) rasmus/ob-header-symbol))
                                         prettify-symbols-alist)
                                        found :test #'equal)))
              ;; Clean up old font-lock-keywords.
              (font-lock-remove-keywords nil prettify-symbols--keywords)
              (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
              (font-lock-add-keywords nil prettify-symbols--keywords)
              (while (re-search-forward re nil t)
                (font-lock-flush (line-beginning-position) (line-end-position))))))

        (defun rasmus/org-prettify-src ()
          "Hide src options via `prettify-symbols-mode'.

          `prettify-symbols-mode' is used because it has uncollpasing. It's
          may not be efficient."
          (let* ((case-fold-search t)
                 (at-src-block (save-excursion
                                 (beginning-of-line)
                                 (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
            ;; Test if we moved out of a block.
            (when (or (and rasmus/org-at-src-begin
                           (not at-src-block))
                      ;; File was just opened.
                      (eq rasmus/org-at-src-begin -1))
              (rasmus/org-prettify-src--update))
            ;; Remove composition if at line; doesn't work properly.
            ;; (when at-src-block
            ;;   (with-silent-modifications
            ;;     (remove-text-properties (match-end 0)
            ;;                             (1+ (line-end-position))
            ;;                             '(composition))))
            (setq rasmus/org-at-src-begin at-src-block)))

        (defun rasmus/org-prettify-symbols ()
          (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
                (cl-reduce 'append
                           (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                                   `(("#+begin_src" . ?)
                                     ("#+end_src"   . ?)
                                     ("#+header:" . ,rasmus/ob-header-symbol)
                                     ("#+begin_quote" . ?)
                                     ("#+end_quote" . ?)))))
          (turn-on-prettify-symbols-mode)
          (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
        (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))


      (progn
        ;; (add-hook 'after-change-major-mode-hook #'gb/activate-properties-in-org-mode)
        (add-hook 'org-mode-hook #'gb/enable-auto-fill-mode)
        ;; (add-hook 'org-mode-hook
        ;;           (lambda ()
        ;;             "beautify checkbox symbols"
        ;;             (push '("[ ]" . "  ") prettify-symbols-alist)
        ;;             (push '("[X]" . "  ") prettify-symbols-alist)
        ;;             (push '("[-]" . "  ") prettify-symbols-alist)
        ;;             (prettify-symbols-mode)))
        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '( (header-line ((t (:inherit org-table-face :foreground "#8abeb7")))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))) ;; set (non scrolling) header to inhiert font from org mode tables (not mode line, which is to small on multi monitor w/ current config)
        (setq org-image-actual-width nil)
        (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
        (setq org-hide-emphasis-markers t)          ;; hides ** and // surrounding text that is bold or intalics
        (setq org-src-window-setup 'current-window) ;; make edit src block open in the same window as the org file itself
        ;; (add-hook 'org-mode-hook #'org-sticky-header)
        ;; make sure source blocks are collapsed at first
        ;; and C-x t b expands and recollapses them
        ;; see [[https://emacs.stackexchange.com/questions/7211/collapse-src-blocks-in-org-mode-by-default][here]]

        (defun gb/org-babel--count-approx-src-block-lenths ()
          ""
          (interactive)
          (while t
            (let ((line (line-number-at-pos)))
              (org-babel-next-src-block)
              (message (format "line %s, length %s" (int-to-string (line-number-at-pos)) (int-to-string (- (line-number-at-pos) line)))))))

        (defvar gb/org-block-visible nil)
        (defun gb/org-toggle-block-visibility ()
          ""
          (interactive)
          (if gb/org-block-visible
              (org-hide-block-all)
            (org-show-block-all))
          (setq-local gb/org-block-visible (not gb/org-block-visible)))
        ;; (add-hook 'org-mode-hook #'gb/org-toggle-block-visibility)
        (define-key gb/toggle-map "b" #'gb/org-toggle-block-visibility)
                                            ; ensure that adjusted save hook is not executed when org edit src save is executed
        (advice-add 'org-edit-src-save :around #'gb/wrap-org-edit-src-save)
        ;; ensure that read only mode is removed when org src edit is started
        (advice-add 'org-edit-special :before #'(lambda (orig-func &rest args) (read-only-mode -1))))


      (progn
        (require 'ob-clojure) ;; not found in packages (20180510)
        (require 'org-inlinetask)
        (defun gb/org-control-return ()
          "open a new item a breaking out of the current level"
          (interactive)
          (let* ((element (org-element-at-point))
                 (start-element (car element))
                 (start (cadadr element))
                 root-line)
            (cond
             ((eq start-element 'headline)
              (progn
                (org-end-of-subtree)
                (org-insert-heading)
                (org-promote)))
             ((eq start-element 'item)
              (org-end-of-item-list)
              (org-insert-heading))
             (t
              (save-excursion
                (goto-char start)
                (setq root-line (thing-at-point 'line t)))
              (if (string-match "^ *-.*" root-line)
                  (if (not (string-match "^ *-.*" (thing-at-point 'line t)))
                      (progn
                        (org-end-of-item)
                        (org-insert-item))
                    ;; (org-end-of-item-list)
                    (org-insert-heading))
                (org-insert-heading-respect-content))))))

        (defun gb/org-return-dwim--on-checkbox-item ()
          "call only if at the beginning of the checkbox to insert below"
          (org-end-of-item)
          (if (org-in-item-p)
              (org-insert-todo-heading 1)
            (progn (move-point-visually -1)
                   (org-insert-todo-heading 1)
                   (org-end-of-item)
                   (if (not (org-in-item-p))
                       (progn
                         (move-point-visually -1)
                         (org-end-of-line))))))

        (defun gb/org-return-dwim--on-list-item ()
          "call only if at the beginning of the item to insert below"
          (org-end-of-item)
          (if (org-in-item-p)
              (org-insert-item)
            (progn (move-point-visually -1)
                   (org-insert-item)
                   (org-end-of-item)
                   (if (not (org-in-item-p))
                       (progn
                         (move-point-visually -1)
                         (org-end-of-line))))))

        (defun gb/org-return-dwim--is-list-or-item (list-type)
          "is this org element type an item or a plain-list (- or - [ ])"
          (or (eq list-type 'item)
              (eq list-type 'plain-list)))

        (defun gb/org-is-checkbox-line (line)
          (string-match "^ *- \\[.\\].*" line))

        (defun gb/org-return-dwim ()
          "execute return and continue element (lists) given by context"
          (interactive)
          ;; check if current point is over link and open that instead
          (let* ((context (org-element-context))
                 (type-at-point (org-element-type context))
                 (saved-position (point)))
            (cond ((and (< (point) (line-end-position)) (eq 'link type-at-point))
                   (org-open-at-point))
                  (t
                   (move-beginning-of-line nil) ;; to identify list as item (does not work when point is in text part of item)
                   (let* ((list-type (car (org-element-at-point)))
                          (line (thing-at-point 'line t))
                          (new-context (org-element-context))
                          (todo-keyword (org-element-property :todo-keyword new-context)))
                     (cond ((and (eq list-type 'headline) (null todo-keyword))
                            (org-insert-heading-after-current))
                           ((eq list-type 'headline)
                            (org-insert-todo-heading context)
                            (call-interactively 'org-move-subtree-down))
                           ((and (gb/org-is-checkbox-line line) (gb/org-return-dwim--is-list-or-item list-type))
                            (gb/org-return-dwim--on-checkbox-item))
                           ((and (not (gb/org-is-checkbox-line line))  (gb/org-return-dwim--is-list-or-item list-type))
                            (gb/org-return-dwim--on-list-item))
                           (t (progn (goto-char saved-position)
                                     (org-return-indent)))))))))

        (defun gb/org-smart-return (&optional ignore)
          "Add new list item, heading or table row with RET.
               A double return on an empty element deletes it.
               Use a prefix arg to get regular RET.
               reference: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/?utm_source=feedburner&utm_medium=twitter&utm_campaign=Feed:+TheKitchinResearchGroup+(The+Kitchin+Research+Group)"
          (interactive "P")
          (if ignore
              (org-return)
            (cond
             ;; Open links like usual
             ((eq 'link (car (org-element-context)))
              (org-open-at-point-global))
             ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
             ;; Johansson!
             ((org-inlinetask-in-task-p)
              (org-return))
             ;; add checkboxes
             ((org-at-item-checkbox-p)
              (org-insert-todo-heading nil))
             ;; lists end with two blank lines, so we need to make sure we are also not
             ;; at the beginning of a line to avoid a loop where a new entry gets
             ;; created with only one blank line.
             ((and (org-in-item-p) (not (bolp)))
              (if (org-element-property :contents-begin (org-element-context))
                  (org-insert-heading)
                (beginning-of-line)
                (setf (buffer-substring
                       (line-beginning-position) (line-end-position)) "")
                (org-return)))
             ((org-at-heading-p)
              (if (not (string= "" (org-element-property :title (org-element-context))))
                  (progn (org-end-of-meta-data)
                         (org-insert-heading))
                (beginning-of-line)
                (setf (buffer-substring
                       (line-beginning-position) (line-end-position)) "")))
             ((org-at-table-p)
              (if (-any?
                   (lambda (x) (not (string= "" x)))
                   (nth
                    (- (org-table-current-dline) 1)
                    (org-table-to-lisp)))
                  (org-return)
                ;; empty row
                (beginning-of-line)
                (setf (buffer-substring
                       (line-beginning-position) (line-end-position)) "")
                (org-return)))
             (t
              (org-return)))))

        (defun gb/wrap-org-edit-src-save (orig-func &rest args)
          "remove save adjusted hook, execute save and add hook again.
               thus this function prevents org-babel tangle and setting the file on r/o when edited in org edit src mode"
          (remove-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
          (let ((res (apply orig-func args)))
            (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)
            res))


        (setq org-clock-clocked-in-display nil)
        (defun gb/org-clock-in-switch-to-state-fn (state)
          "switch TODO to IMPLEMENT if clocking in!"
          (if (equal state "TODO")
              "IMPLEMENT"
            nil))

        (defun gb/org-global-props-key-re (key)
          "Construct a regular expression matching key and an optional plus and eating the spaces behind.
             Test for existence of the plus: (match-beginning 1)"
          (concat "^" (regexp-quote key) "\\(\\+\\)?[[:space:]]+"))

        (defun gb/org-global-props (&optional buffer)
          "Get the plists of global org properties of current buffer."
          (with-current-buffer (or buffer (current-buffer))
            (org-element-map (org-element-parse-buffer) 'keyword (lambda (el) (when (string-equal (org-element-property :key el) "PROPERTY") (nth 1 el))))))

        (defun gb/org-global-prop-value (key)
          "Get global org property KEY of current buffer.
               Adding up values for one key is supported."
          (let ((key-re (gb/org-global-props-key-re key))
                (props (gb/org-global-props))
                ret)
            (cl-loop with val for prop in props
                     when (string-match key-re (setq val (plist-get prop :value))) do
                     (setq
                      val (substring val (match-end 0))
                      ret (if (match-beginning 1)
                              (concat ret " " val)
                            val)))
            ret))

        ;; TODO: generalize to all properties
        ;; (defun gb/activate-properties-in-org-mode ()
        ;;   (when (string= major-mode "org-mode")
        ;;     (let* ((readOnly (gb/org-global-prop-value "readonly")))
        ;;       (if (string= readOnly "yes")
        ;;           (setq buffer-read-only t)))))

        :config
        (setq org-agenda-files '("~/slack.org" "~/itemis.org"))
        (setq gb/use-optimized-folded-src-fontificat nil) ;; fontify src blocks only if they ar not folded!
        (setq org-catch-invisible-edits t)

        (defun gb/set-org-pretty-entities (prettify)
          ""
          (interactive)
          (setq-local org-pretty-entities prettify)
          (org-restart-font-lock))

        (defun gb/get-org-hide-block-status (&optional pos)
          "t if babel block is folded, else nil"
          (save-excursion
            (when pos (goto-char pos))
            (let ((element (org-element-at-point)))
              (goto-char (org-element-property :begin element))
              (unless (memq (org-element-type element)
                            '(center-block comment-block dynamic-block example-block
                                           export-block quote-block special-block
                                           src-block verse-block))
                (user-error "Not at a block"))
              (let* ((post (org-element-property :post-affiliated element))
                     (start (save-excursion
                              (goto-char post)
                              (line-end-position)))
                     (end (save-excursion
                            (goto-char (org-element-property :end element))
                            (skip-chars-backward " \t\n")
                            (line-end-position))))
                ;; Do nothing when not before or at the block opening line or at
                ;; the block closing line.
                (unless (let ((eol (line-end-position))) (and (> eol start) (/= eol end)))
                  (eq (get-char-property start 'invisible) 'org-hide-block))))))

        ;; todo: optimize: fontify to the next end src- block marker (not to the end of the file)
        (defun gb/org-hide-block-toggle-maybe--fontify-if-src-block (&rest args)
          "fontify the rest of document if within a org babel src block"
          (with-buffer-modified-unmodified
           (let ((element (org-element-at-point)))
             (when (equal 'src-block (org-element-type element))
               (font-lock-fontify-block)
               ;; (save-excursion (with-temp-message "fontify src block" (org-fontify-meta-lines-and-blocks-1 (or (re-search-forward "[ \t]*#\\+end_src" (point-max) t) (point-max)))))
               ))))

        (defun gb/org-src-font-lock-fontify-block--only-if-non-folded (orig-fun &rest args)
          "if region within folded element, ignore fontification"
          (let ((lang (nth 0 args))
                (start (nth 1 args))
                (end (nth 2 args)))
            (unless (gb/get-org-hide-block-status start)
              (apply orig-fun args)
              ;; (with-temp-message
              ;;     (format "font-lock @%s lang %s" start lang)
              ;;   )
              )))

        (defun gb/fontify-buffer-when-in-org-mode ()
          "if in org mode, fontify buffer"
          (when (equal major-mode 'org-mode)
            (font-lock-fontify-block)))

        (when gb/use-optimized-folded-src-fontificat
          (add-hook 'isearch-mode-end-hook #'gb/fontify-buffer-when-in-org-mode)
          (advice-add 'org-hide-block-toggle-maybe :after #'gb/org-hide-block-toggle-maybe--fontify-if-src-block)
          (advice-add 'org-src-font-lock-fontify-block :around #'gb/org-src-font-lock-fontify-block--only-if-non-folded))

        (setq org-file-apps (append '(("\\.sid\\'" . "sidplayfp %s" )) org-file-apps))
        (setq org-cycle-include-plain-lists 'integrate)
        ;; set org babel backgrounds for several languages
        (setq org-src-block-faces
              '(("emacs-lisp" (:background "#1b1010" :extend t))
                ("java" (:background "#1b1010" :extend t))))

        ;; make sure latex is highlighted in org mode buffers
        ;; `latex'    Highlight LaTeX snippets and environments.
        ;; `script'   Highlight subscript and superscript.
        ;; `entities' Highlight entities.
        ;; `native`   Use native highlighting
        (setq org-highlight-latex-and-related nil) ;; '(native)

        ;; make sure that regular font in src block within org is 'white'
        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '( (org-block ((t (:foreground "gray75")))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
        (setq flycheck-keymap-prefix (kbd "C-c k"))

        ;;--------------------------------------------------------------------------------
        (defhydra hydra-org-mode ()
          "
                  org mode
                  ^-^------------------------------------------------
                  _ci_: clock in             _cti_: toggle item     _cr_: org reveal    Movement:
                  _co_: clock out                                                   C-c p previous bulletin
                  _cq_: clock cancel/quit                                           C-c u up bulletin level
                  _cj_: jump to clock                                               M-<ret>
                  _cd_: display clock times                                         C-<ret>

                  %s(hydra-combine-functions-w-key-bindings
                    '((\"  [ci]  clock in            \" . org-clock-in)
                      (\"  [co]  clock out           \" . org-clock-out)
                      (\"  [cq]  clock cancel/quit   \" . org-clock-cancel)
                      (\"  [cj]  jump to clock       \" . org-clock-goto)
                      (\"  [cd]  display clock times \" . org-clock-display)
                      (\"  [cti] toggle item         \" . org-toggle-item)
                      (\"  [cr]  org reveal          \" . org-reveal)
                      ))
                "
          ("ci" org-clock-in :exit t)
          ("co" org-clock-out :exit t)
          ("cq" org-clock-cancel :exit t)
          ("cj" org-clock-goto :exit t)
          ("cd" org-clock-display :exit t)
          ("cti" org-toggle-item :exit t)
          ("cr" org-reveal :exit t))


        ;; Resume clocking tasks when emacs is restarted
        (org-clock-persistence-insinuate)

        ;; make sure that clock display will include all times (even last year ...)
        (setq org-clock-display-default-range (quote untilnow))

        ;; Yes it's long... but more is better ;
        (setq org-clock-history-length 35)

        ;; Resume clocking task on clock-in if the clock is open
        (setq org-clock-in-resume t)

        ;; name the drawer to be "clocking"
        (setq org-clock-into-drawer "CLOCKING")

        ;; The format string used when creating CLOCKSUM lines.
        (setq org-duration-format '((special . h:mm)))
        (setq org-time-clocksum-format
              (quote
               (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))) ;; make sure that clock sums in org mode show hours and minutes only (no days)

        ;; Change task state to IMPLEMENT when clocking in (only if in STATE TODO)
        (setq org-clock-in-switch-to-state (function  gb/org-clock-in-switch-to-state-fn))

        ;; mark checked lists a bit differently (changed 27)
        ;; (font-lock-add-keywords
        ;;  'org-mode
        ;;  `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
        ;;  'append)

        (setq org-ellipsis "")         ;; make the ... at the end (that indicates folding) be a bit less invasive
        (setq org-hide-leading-stars t) ;; each level only one star
        (setq org-special-ctrl-a/e t)   ;; jump to the head text only (not to the star marking the head)

        ;; replace dashes and bullets with utf-8 bullet
        ;; (font-lock-add-keywords 'org-mode
        ;;                         '(("^ +\\([-*]\\) "
        ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) ""))))))

        ;; make level headings larger / bold
        ;; (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
        ;;                             ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
        ;;                             ((x-list-fonts "Verdana")         '(:font "Verdana"))
        ;;                             ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
        ;;                             (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
        ;;      (base-font-color     (face-foreground 'default nil 'default))
        ;;      (headline           `(:inherit default :weight bold )))

        (custom-theme-set-faces 'user
                                ;;                          `(org-document-title ((t ( :height 1.5 :underline nil))))
                                ;;                          `(org-level-8 ((t (,@headline ,@variable-tuple))))
                                ;;                          `(org-level-7 ((t (,@headline ,@variable-tuple))))
                                ;;                          `(org-level-6 ((t (,@headline ,@variable-tuple))))
                                ;;                          `(org-level-5 ((t (,@headline ,@variable-tuple))))
                                ;;                          `(org-level-4 ((t (:foreground "#a97167"))))
                                ;;                          `(org-level-3 ((t (:foreground "#4fa8a8" ,@headline))))
                                `(org-level-2 ((t (:foreground "burlywood"))))
                                `(outline-2 ((t (:foreground "burlywood")))) ;; change both org-level and outline, since org-tree-slide uses them
                                `(org-level-1 ((t (:foreground "#de935f"))))
                                `(outline-1 ((t (:foreground "#de935f")))))))
  #+END_SRC
*** org mobile (disabled)
    - this will put all org files (known to the system) into the transfer folder which is not what I want, I don't want all files to be
      synced via Dropwizard
    - could be tamed to not use all agenda files!
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-mobile
        :commands org-mobile-pull org-mobile-push
        :after ( org)
        :init
          (progn
            (defun gb/ensure-org-mobile-secret ()
              "ensure that the org mobile sync secret is set"
                ;; used for encryption of org mode files // should be executed after above commands only!
              (if (string-empty-p org-mobile-encryption-password)
                  (let ((auth-map (jde-read-properties-file "~/.org-mobile.auth.gpg")))
                    (setq org-mobile-encryption-password (gethash "org-mobile-encryption-secret" auth-map)))))

            (advice-add 'org-mobile-pull :before #'(lambda () (gb/ensure-org-mobile-secret)))
            (advice-add 'org-mobile-push :before #'(lambda () (gb/ensure-org-mobile-secret)))

            )
        :config
        (progn
        ;; Set to the location of your Org files on your local system
        (setq org-directory "~")
        ;; Set to the name of the file where new notes will be stored
        (setq org-mobile-inbox-for-pull "~/org-dropbox/flagged.org")
        ;; Set to <your Dropbox root directory>/MobileOrg.
        (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
        ;; make sure that no agenda files are put into tranfer folder
        (setq org-mobile-files (quote ("~/notes.synced.org")))
        ;; (setq org-mobile-agendas nil)

        ;; make sure encryption is used
        (setq org-mobile-use-encryption t)
        ))
    #+END_SRC
*** org capture
    - for capture templates see [[http://orgmode.org/manual/Template-elements.html#Template-elements]]
    - intro for capture templates see http://cestlaz.github.io/posts/using-emacs-23-capture-1/
  #+BEGIN_SRC emacs-lisp
    (use-package org-capture
      :after ( org)
      :bind ("C-c c" . org-capture)
      :init (progn
        ;;
        (defun gb/org-file-lineno-store-link ()
          "provide function that stores a file link with line number (when matching the wanted major mode)"
          (cond
           ((string-match "\\(emacs-lisp-mode\\|nxml-mode\\)" (format "%s" major-mode))
            (let* ((link (format "file:%s::%d" (file-truename buffer-file-name)
                                 (line-number-at-pos))))
              (org-store-link-props
               :type "file"
               :link link)))))

        ;; when storing a file link, store line number with it (when matching the wanted major mode)
        (add-hook 'org-store-link-functions 'gb/org-file-lineno-store-link)
        )
      :config
      (progn 

        (setq org-default-notes-file "~/notes.org")

        ;; TODO: define additional capture templates
        (setq org-capture-templates
              (append '(("t" "Todo" entry (file+headline "~/notes.org" "Tasks") "* TODO %?\n  %i\n  %a"))
                      org-capture-templates))

        (require 'org-protocol)
        (defun transform-square-brackets-to-round-ones(string-to-transform)
          "Transforms [ into ( and ] into ), other chars left unchanged."
          (concat
           (mapcar #'(lambda (c) (if (equal c ?\[) ?\( (if (equal c ?\]) ?\) c))) string-to-transform)))

        (setq org-capture-templates
              (append '(("t" "Todo" entry (file+headline "~/notes.org" "Tasks") "* TODO %?\n  %i\n  %a"))
                      `(("p" "Protocol" entry (file+headline "~/notes.org" "Inbox")
                         "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
                        ("L" "Protocol Link" entry (file+headline "~/notes.org" "Inbox")
                         "* %? [[%:link][%(transform-square-brackets-to-round-ones \"%:description\")]]\n"))
                      org-capture-templates))
        ;; make sure that org templates for ical export into org agenda works
        ;; (gnus-calendar-insinuate-org-templates)


        ;; necessary, else an error is reported during org-magit-store-link
        ;; (setq with-editor-file-name-history-exclude nil)
        ))
  #+END_SRC
*** org agenda
  #+BEGIN_SRC emacs-lisp
    (use-package org-agenda
      :after ( org) ;; agenda-accounts are option
      :config
      (progn

        (when (fboundp 'gb/org-agenda-refresh)
          (bind-key "g" #'gb/org-agenda-refresh org-agenda-mode-map))

        ;;don't show tasks as scheduled if they are already shown as a deadline
        (setq org-agenda-skip-scheduled-if-deadline-is-shown t)

        ;;don't give a warning colour to tasks with impending deadlines
        ;;if they are scheduled to be done
        (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))

        ;;don't show tasks that are scheduled or have deadlines in the
        ;;normal todo list
        (setq org-agenda-todo-ignore-deadlines (quote all))
        (setq org-agenda-todo-ignore-scheduled (quote all))

        ;; sort agend entries by,
        ;; time-up       : Put entries with time-of-day indications first, early first
        ;; category-up   : Sort alphabetically by category, A-Z.
        ;; priority-down : Sort numerically by priority, high priority first.
        ;; category-keep : Keep the default order of categories, corresponding to the sequence in org-agenda-files.
        (setq org-agenda-sorting-strategy
              '((agenda time-up category-up)
                (todo priority-down todo-state-up category-down)
                (tags priority-down category-keep)
                (search category-keep)))

        ;; show repeated org agenda entries only once
        (setq org-agenda-show-future-repeats nil)

        ;;open agenda in current window
        (setq org-agenda-window-setup (quote current-window))
        ;;warn me of any deadlines in next 7 days
        (setq org-deadline-warning-days 7)
        ;; set only org agenda files that are currently reachable!
        ;; jump between these files <C-'>
        ;; these files are used for org agenda display of dates/todos etc.

        ;; show a fortnite
        (setq org-agenda-span 14)

        ;; include all diary events into org-agenda view
        (setq org-agenda-include-diary t) ;; this includes the holidays, too


        ;; make sure that a todo cannot switch to done, if one of its descendants is not done yet
        (setq org-enforce-todo-dependencies t)
        ;; make sure that todo cannot switch to done if a checkbox within its descendants is not checked!
        (setq org-enforce-todo-checkbox-dependencies t)

        ;; customize todo lists
        (setq org-todo-keywords
              '((sequence "TODO"               ;; currently to do task
                          "IMPLEMENT(i)"       ;; currently implementing this to do
                          "TEST(t@)"           ;; currently testing this to do
                          "ACCEPT(a@)"         ;; accepted by tester
                          "PLANNED"            ;; planned as future task
                          "|"                  ;; separates todo from done state
                          "OBSOLETE(o)"        ;; now obosolete
                          "CARRY OVER(c)"      ;; carried over to new to do
                          "BRAIN(b!)"          ;; done and keep information as part of your brain
                          "DONE(d!)"           ;; finally done
                          )))
        (setq org-todo-keyword-faces
              '(("PLANNED" . "lightblue")
                ("TODO" . "red")
                ("IMPLEMENT" . (:foreground "orange" :weight bold))
                ("TEST" . "yellow")
                ("ACCEPT" . (:foreground "gray" :weight bold))
                ("OBSOLETE" . "darkgreen")
                ("CARRY OVER" . "brown")
                ("BRAIN". (:foreground "green" :weight bold))
                ("DONE" . "green")))))

  #+END_SRC
*** org agenda user specific stuff
    #+BEGIN_SRC emacs-lisp
      (when agenda-accounts-exists
        (use-package agenda-accounts
          :after ( org org-agenda )
          :load-path "~/.emacs.d/accounts/"
          :config
          (progn
            (bind-key "i" #'gb/org-agenda-diary-entry org-agenda-keymap) ;; don't use :bind, since loading should be done before actully hitting this key!
            (defun gb/org-agenda-diary-entry ()
              "enter a new date into diary and allow selection of which calendar this should go into"
              (interactive)
              ;; now select and set org-agenda-diary-file
              (let* ((filename (completing-read "calendar: " gb/org-calendar-files)) ;; <- provided by agenda-accounts
                     (fullname (concat "~/" filename)))
                (if (file-exists-p fullname)
                    (setq org-agenda-diary-file fullname)))
              (org-agenda-diary-entry)))))
    #+END_SRC
*** ical accept invitations into calendar
    allow to accept invitations and record these into the org-capture-file
    #+BEGIN_SRC emacs-lisp
      ;; (add-to-list 'load-path "~/.emacs.d/ical-event-master/")
      ;; (use-package gnus-calendar

      ;;   :loader :path
      ;;   :after ( org)
      ;;   :config
      ;;   (gnus-calendar-setup)
      ;;   ;; to enable optional iCalendar->Org sync functionality
      ;;   ;; NOTE: both the capture file and the headline(s) inside must already exist
      ;;   ;; remove entry from org capture templates (which are used to actually insert the invitation)
      ;;   (setq org-capture-templates (-remove (lambda (x) (string= gnus-calendar-org-template-name (second x))) org-capture-templates))
      ;;   ;; put all new events into agenda.org which is synced with the itemis work calendar (not private)
      ;;   (setq gnus-calendar-org-capture-file "~/agenda.org")
      ;;   ;; heading-1 within the org file, under which the events are created
      ;;   (setq gnus-calendar-org-capture-headline '("Calendar"))
      ;;   ;; do the setup with the given values
      ;;   (gnus-calendar-org-setup))
    #+END_SRC
*** gcal (see [[https://github.com/myuhe/org-gcal.el][link]]) currently not in use (may be useful if authentification used by org-caldav is no longer accessible)
    - BEFORE EXECUTING "org-gcal-sync", execute "org-gcal-fetch"
    - org-gcal-sync: sync org files with calendars
    - org-gcal-fetch: initially fetch all calendar events into org files (before fetch, the org files should be completely empty!)
    - org-gcal-post-at-point: post/edit org block at point to google calendar
    - org-gcal-referesh-token: refresh oauth token (expires in 1h)
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (use-package org-gcal
        :after ( calendar-accounts org)
        :commands org-gcal-sync org-gcal-fetch org-gcal-post-at-point org-gcal-refresh-token
        :config
        (progn 
            (require 'calendar-accounts)
            (gb/load-calendar-credentials))))
    #+END_SRC
*** caldav sync
    #+BEGIN_SRC emacs-lisp
    (when calendar-accounts-exists
      (use-package org-caldav
        :after ( org calendar-accounts oauth2)
        :commands org-caldav-sync
        :config
        (setq org-icalendar-timezone "Europe/Berlin")
        (setq org-caldav-delete-org-entries 'never)
        (setq org-caldav-delete-calendar-entries 'never)
        (setq org-caldav-debug-level 3)

        (require 'calendar-accounts)
        (gb/load-calendar-credentials)

        ;; redefine sync to cal
        (require 'org-caldav)
        ;;(setq org-caldav-url 'google)

        ;; make sure cal is not deleted
        (defun org-caldav-delete-event (uid)
          "Delete event UID from calendar.
      Returns t on success and nil if an error occurs.  The error will
      be caught and a message displayed instead."
          (message "executing patched version of org-caldav-delete-event")
          (org-caldav-debug-print 1 (format "(Deleting) event UID %s." uid))
          (condition-case err
              (progn
                ;; (url-dav-delete-file (concat (org-caldav-events-url) uid org-caldav-uuid-extension))
                t)
            (error
             (progn
               (message "Could not delete URI %s." uid)
               (org-caldav-debug-print 1 "Got error while removing UID:" err)
               nil))))

        ;; make sure that update never deletes from calendar
        (defun old-org-caldav-update-events-in-cal (icsbuf)
          "Update events in calendar.
      ICSBUF is the buffer containing the exported iCalendar file."
          (message "executing patched version of org-caldav-update-event-in-cal")
          (org-caldav-debug-print 1 "=== Updating events in calendar")
          (with-current-buffer icsbuf
            (widen)
            (goto-char (point-min))
            (let ((events (append (org-caldav-filter-events 'new-in-org)
                                  (org-caldav-filter-events 'changed-in-org)))
                  (counter 0)
                  (url-show-status nil)
                  (event-etag (org-caldav-get-event-etag-list))
                  uid)
              ;; Put the events via CalDAV.
              (dolist (cur events)
                (setq counter (1+ counter))
                (if (eq (org-caldav-event-etag cur) 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Was already put previously." (car cur)))
                  (org-caldav-debug-print 1
                                          (format "Event UID %s: Org --> Cal" (car cur)))
                  (widen)
                  (goto-char (point-min))
                  (while (and (setq uid (org-caldav-get-uid))
                              (not (string-match (car cur) uid))))
                  (unless (string-match (car cur) uid)
                    (error "Could not find UID %s" (car cur)))
                  (org-caldav-narrow-event-under-point)
                  (org-caldav-cleanup-ics-description)
                  (org-caldav-maybe-fix-timezone)
                  (org-caldav-set-sequence-number cur event-etag)
                  (message "Putting event %d of %d" counter (length events))
                  (if (org-caldav-put-event icsbuf)
                      (org-caldav-event-set-etag cur 'put)
                    (org-caldav-debug-print 1
                                            (format "Event UID %s: Error while doing Org --> Cal" (car cur)))
                    (org-caldav-event-set-status cur 'error)
                    (push (list org-caldav-calendar-id (car cur)
                                'error 'error:org->cal)
                          org-caldav-sync-result))))
              ;; Get Etags
              (setq event-etag (org-caldav-get-event-etag-list))
              (dolist (cur events)
                (let ((etag (assoc (car cur) event-etag)))
                  (when (and (not (eq (org-caldav-event-status cur) 'error))
                             etag)
                    (org-caldav-event-set-etag cur (cdr etag))
                    (push (list org-caldav-calendar-id (car cur)
                                (org-caldav-event-status cur) 'org->cal)
                          org-caldav-sync-result)))))
            ;; Remove events that were deleted in org 
            (let ((events (org-caldav-filter-events 'deleted-in-org))
                  (url-show-status nil)
                  (counter 0))
              (dolist (cur events)
                (setq counter (1+ counter))
                (message "(no really) deleting event %d from %d" counter (length events))
                ;; (org-caldav-delete-event (car cur))
                (push (list org-caldav-calendar-id (car cur)
                            'deleted-in-org 'removed-from-cal)
                      org-caldav-sync-result)
                (setq org-caldav-event-list
                      (delete cur org-caldav-event-list))))
            ;; Remove events that could not be put
            (dolist (cur (org-caldav-filter-events 'error))
              (setq org-caldav-event-list
                    (delete cur org-caldav-event-list)))))

        ))
    #+END_SRC
*** accounts for calendar sync
    #+BEGIN_SRC emacs-lisp
      (when calendar-accounts-exists
          (use-package calendar-accounts
            :after ( org)
            :load-path "~/.emacs.d/accounts/"))
    #+END_SRC
*** german holidays into calendar
    #+BEGIN_SRC emacs-lisp
      (use-package german-holidays
        :after ( org)
        :config
        ;; (setq holiday-other-holidays holiday-german-holidays)
        ;; make sure that the right holidays are used (and no others)
        (setq calendar-holidays holiday-german-holidays))
        ;; (setq calendar-holidays
        ;;       (append (if (boundp 'local-holidays) local-holidays '())  
        ;;               (if (boundp 'other-holidays) other-holidays '())
        ;;               holiday-german-holidays)))
    #+END_SRC
*** org bullets
 #+BEGIN_SRC emacs-lisp
   (use-package org-bullets
     :ensure t
     :after ( org)
     :init
     (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
     :config
     (setq org-bullets-bullet-list '("" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""))
     ;; override fontify buffer of org-bullets, since it forces fontifying again, which was already done => waste of time
     ;; (defun org-bullets--fontify-buffer ()
     ;;   (when font-lock-mode
     ;;     (if (and (fboundp 'font-lock-flush)
     ;;            (fboundp 'font-lock-ensure))
     ;;         (with-no-warnings
     ;;           (font-lock-fontify-buffer)))))
     )
 #+END_SRC
*** level 3
**** level 4
***** level 5
****** level 6
******* level 7
******** level 8
********* level 9
********** level 10
*********** level 11
************ level 12
************* level 13
************** level 14
*** password manager
 #+BEGIN_SRC emacs-lisp
   (use-package org-password-manager
     :ensure t
     :bind (:map org-mode-map
                 ("C-c s b" . gb/browse-to-link-property)
                 ("C-c s u" . org-password-manager-get-username)
                 ("C-c s p" . org-password-manager-get-password)
                 ("C-c s g" . org-password-manager-generate-password))
     :after ( org)
     :config
     (defun gb/browse-to-link-property ()
       "get the property ':LINK:' from the entry at point and browse to url given as value"
       (interactive)
       (browse-url (org-entry-get (point) "LINK" t))))
 #+END_SRC
*** hide passwords in org files
    - loaded from [[https://raw.githubusercontent.com/jekor/hidepw/master/hidepw.el][here]]
    - hides passwords in password manager (any entry with ':PASSWORD:')
    - TODO: now in melpa (use-package hidepw)
    #+BEGIN_SRC emacs-lisp
      (if (file-exists-p "~/.emacs.d/additionals/hidepw.el")
          (use-package hidepw
            :load-path "~/.emacs.d/additionals/"
            :after ( org)
            ;; :init (progn (add-hook 'org-mode-hook  'hidepw-mode))
            :config
            (progn
              (setq hidepw-pattern ":.*PASS.*: \\(.*\\)")))
        (message "WARNING: hidepw.el not found. passwords will not be hidden in gpg files."))
    #+END_SRC
*** export modules (e.g. ox-confluence)
 #+BEGIN_SRC emacs-lisp :tangle no
   ;;      (add-to-list 'load-path "~/.emacs.d/org-mode-exports/")
   ;;      (use-package ox-confluence
   ;;        :after ( org)
   ;;        :commands org-confluence-export-as-confluence
   ;; ;;       :load-path "~/.emacs.d/org-mode-exports/"
   ;;        :loader :path)
 #+END_SRC
*** personal blogs
    - expects ~/Document/blog/org-jekyll.el to exist
    - download from [[http://github.com/juanre/org-jekyll][here]]
    - documentation [[http://juanreyero.com/open/org-jekyll/index.html][here]]
 #+BEGIN_SRC emacs-lisp :tangle no
   (if (file-exists-p "~/documents/blog/org-jekyll.el")
       (use-package org-jekyll
         :after ( org)
         ;; :defer 3
         :load-path "~/documents/blog"))
 #+END_SRC
*** make org export use better highlighting with htmlize
 #+BEGIN_SRC emacs-lisp
    (use-package htmlize
      :ensure t)
 #+END_SRC
*** helm org rifle
**** find keybindings
  #+BEGIN_SRC emacs-lisp :tangle no
    (when (eq gb/completion-framework 'helm)
      (use-package helm-org-rifle
        :after ( helm org)
        :commands helm-org-rifle helm-org-rifle-directories helm-org-rifle-files))
  #+END_SRC
**** available functions
***** helm-org-rifle
      searches all open org files
***** helm-org-rifle-current-buffer
      searches the current buffers org file
***** helm-org-rifle-directories
      Shows results from selected directories; with prefix, recursively.
***** helm-org-rifle-files
      Shows results from selected files.
*** org appt (notification of agenda items)
    #+BEGIN_SRC emacs-lisp
      (use-package appt
        ;; :after ( org)
        ;; :defer 20
        :init (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view
        :config

        (setq appt-display-diary nil
              appt-message-warning-time 10  ;; send first warning 10 minutes before appointment
              appt-display-interval 3       ;; warn every 3 minutes from t - appt-message-warning-time
              appt-audible nil
              appt-display-duration 360
              appt-display-format 'echo)


        (setq appt-time-msg-list nil)    ;; clear existing appt list


        (appt-activate 1)                ;; activate appointment notification
        (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
        (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly

        ;; make sure appt are highlighted accordingly
        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '( (mode-line-emphasis ((t (:foreground "DarkGoldenrod3")))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))

        ;; ;; set up the call to terminal-notifier (only working when appt-display-format is set to 'window)
        ;; (defvar gb/appt-notifier-path (s-trim (shell-command-to-string "command -v notify-send")))

        ;; (defun gb/appt-send-notification (title msg)
        ;;   (shell-command (concat gb/appt-notifier-path " " msg " -a " title)))

        ;; ;; designate the window function for my-appt-send-notification
        ;; (defun gb/appt-display (min-to-app new-time msg)
        ;;   (gb/appt-send-notification
        ;;    (format "'Appointment in %s minutes'" min-to-app)    ;; passed to -title in terminal-notifier call
        ;;    (format "'%s'" msg)))                                ;; passed to -message in terminal-notifier call

        ;; (setq appt-disp-window-function (function gb/appt-display))
        )

    #+END_SRC
*** org review
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-review
        :commands org-review-insert-next-review org-review-insert-last-review
        :after ( org))
    #+END_SRC
*** org ref
    - see https://github.com/jkitchin/org-ref
    #+BEGIN_SRC emacs-lisp
      (use-package org-ref
        :commands org-ref-insert-link
                  org-ref-helm-insert-ref-link
                  org-ref-list-of-tables
                  org-ref-list-of-figures
                  org-ref-helm-insert-label-link
        :ensure t
        ;; :after ( org helm-bibtex pdf-tools ivy hydra helm)
        )
    #+END_SRC
*** org clip
    - ox-clip-formatted-copy copies selected region of org mode file as rtf into clipboard for insertion into e.g. open office
    #+BEGIN_SRC emacs-lisp
    (use-package ox-clip
      :commands ox-clip-formatted-copy
      :after ( org htmlize))
    #+END_SRC
*** org babel
    #+BEGIN_SRC emacs-lisp
      ;; set jar path for ditaa
      ;; sh 'brew info ditaa | grep -oe "/usr/local[^ ]*"' produces path to /usr/local/Cellar/ditaa/0.10
      ;; within this dir the file INSTALL_RECEIPT.json exists.
      ;; within this json file, under the key source.version.stable = '0.10' the version string is accessible
      ;; thus the org-ditaa-jar-path can be constructed (which is true for mac os brew systems)
      (setq org-ditaa-jar-path "~/bin/ditaa.jar") ;; "/usr/local/bin/ditaa"

      (cond
       ((eq gb/theme-mode 'light) nil) ;; TODO complete
       (t (progn
            (--each '((org-block-begin-line ((t (;;:underline "#A7A6AA"
                                                 :height 0.8 :foreground "gray50"))))
                      (org-block-end-line ((t (
                                               ;; :overline "#A7A6AA"
                                               :height 0.8 :foreground "#606060")))))
              (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
      ;; set sed command for org babel
      (setq org-babel-sed-command (s-trim (shell-command-to-string "command -v sed")))

      (setq org-src-fontify-natively t)
      (setq org-src-tab-acts-natively t)
      (setq electric-indent-inhibit t)
      (setq org-edit-src-content-indentation 2)
      (setq org-adapt-indentation t)
      (setq org-src-preserve-indentation nil)

      ;; (addToList org-babel-shell-names "fish")

      ;; do not ask for confirmation when executing functions in org babel
      ;; (setq org-confirm-babel-evaluate nil)
      ;; Disable confirmation question when evaluating (C-c C-c) these languages
      (defun gb/org-confirm-babel-evaluate (lang body)
        (not (or (string= lang "plantuml")
                 ;; ... add more above this line when needed ...
                 )))
      (setq org-confirm-babel-evaluate 'gb/org-confirm-babel-evaluate)

      ;; redisplay images after org babel execute
      (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)


      ;;    - original source http://www.holgerschurig.de/en/emacs-init-tangle/
      (defun gb/speedy-emacs-init-tangle (filename)
        "This function will write all source blocks from FILENAME into
      ~/.emacs.d/init.el that are ...

      - not marked as =tangle: no=
      - doesn't have the TODO state =CANCELLED=
      - have a source-code of =emacs-lisp="
        (require 'org)
        (let* ((body-list ())
               (output-file "~/.emacs.d/init.el")
               (org-babel-default-header-args (org-babel-merge-params org-babel-default-header-args
                                                                      (list (cons :tangle output-file)))))
          (message "Writing %s ..." output-file)
          (save-restriction
            (save-excursion
              (org-babel-map-src-blocks filename
                (let* ((info (org-babel-get-src-block-info 'light))
                       (tfile (cdr (assq :tangle (nth 2 info))))
                       (match))
                  (save-excursion
                    (catch 'exit
                      (org-back-to-heading t)
                      (when (looking-at org-outline-regexp)
                        (goto-char (1- (match-end 0))))
                      (when (looking-at (concat " +" org-todo-regexp "\\( +\\|[ \t]*$\\)"))
                        (setq match (match-string 1)))))
                  (unless (or (string= "no" tfile)
                              (string= "CANCELED" match)
                              (not (string= "emacs-lisp" lang)))
                    (add-to-list 'body-list body)))))
            (with-temp-file output-file
              (insert (format ";; Don't edit this file, edit '%s' instead ...\n\n" filename))
              (insert (apply 'concat (reverse body-list)))
              (emacs-lisp-mode)
              (condition-case nil
                  (check-parens)
                ;; error case is not executed even though user-error should be signaled if an error occurs
                (user-error (with-current-buffer (generate-new-buffer "*Generated init.el*")
                              (insert-file output-file)
                              (emacs-lisp-mode)
                              (check-parens)
                              (switch-to-buffer "*Generated init.el*")))))
            (message "Wrote %s ..." output-file))))

      ;; execute org babel if current major mode is org-mode
      ;; and the file has source code regions
      ;; and the file defines a header-args property with value :tangle ...
      ;; if this file writes into ~/.emacs.d/init.el then gb/speedy-emacs-init-tangle is used
      (defun gb/tangle-on-save-org-mode-file()
        (when (string= major-mode "org-mode")
          (progn
            (let ((has-source-regions (gb/buffer-contains-string "^ *#\\+BEGIN_SRC"))
                  (should-tangle (gb/buffer-contains-string "^#\\+PROPERTY: +header-args +:tangle"))
                  (target-is-initel (gb/buffer-contains-string (concat "^#\\+PROPERTY: +header-args +:tangle +" (regexp-quote "~/.emacs.d/init.el")))))
              (if (and has-source-regions should-tangle)
                  (progn
                    (when (package-installed-p 'yankpad)
                      (remove-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))
                    (when (package-installed-p 'pretty-mode)
                      (global-pretty-mode -1))
                    (when ligatures-enabled
                      (remove-hook 'prog-mode-hook
                                   #'add-fira-code-symbol-keywords))

                    (message "executing org-babel-tangle ...")
                    (if target-is-initel
                        (gb/speedy-emacs-init-tangle (buffer-file-name))
                      (let ((inhibit-message t))
                        (org-babel-tangle)))
                    (message "executing org-babel-tangle ... done.")

                    (when ligatures-enabled
                      (add-hook 'prog-mode-hook
                                #'add-fira-code-symbol-keywords))
                    ;; check whether readonly should be applied again
                    ;; only if currently not in detailed edit mode
                    ;; (gb/activate-properties-in-org-mode)
                    ;; the following currently takes about 3 seconds (which I don't want to spend)
                    ;;(when (package-installed-p 'pretty-mode)
                    ;;  (global-pretty-mode 1))
                    (when (package-installed-p 'yankpad)
                      (add-hook 'after-change-major-mode-hook #'yankpad-local-category-to-major-mode))))))))

      ;; execute org babel on safe (if major mode is org-mode
      (add-hook 'after-save-hook 'gb/tangle-on-save-org-mode-file)

      ;; set default header args for plantuml
      (setq org-babel-default-header-args:PlantUML
            '((:results . "file") (:exports . "results") (:noweb . "yes") (:cmdline . "-charset UTF-8")))

      ;; use cider as backend for clojure
      (setq org-babel-clojure-backend (quote cider))

      ;; function is renamed to ...x (since it should not collide with impl. in org)
      (require 'ob-clojure) ;; load this first, then define the new function
      (defun org-babel-execute:clojure (body params)
        "Execute a block of Clojure code with Babel. Changes by GB"
        (let ((expanded (org-babel-expand-body:clojure body params))
              result)
          (cl-case org-babel-clojure-backend
            (cider
             (require 'cider)
             (let ((result-params (cdr (assq :result-params params))))
               (setq result
                     (nrepl-dict-get
                      (nrepl-sync-request:eval
                       expanded (cider-current-connection)) ;; <------------- change in cider api
                      (if (or (member "output" result-params)
                              (member "pp" result-params))
                          "out"
                        "value")))))
            (slime
             (require 'slime)
             (with-temp-buffer
               (insert expanded)
               (setq result
                     (slime-eval
                      `(swank:eval-and-grab-output
                        ,(buffer-substring-no-properties (point-min) (point-max)))
                      (cdr (assq :package params)))))))
          (org-babel-result-cond (cdr (assq :result-params params))
            result
            (condition-case nil (org-babel-script-escape result)
              (error result)))))

      ;; enable all languages listed below within org babel
      (when (version<= "9.0.5" (org-version))
        ;; (require 'ob-clojurescript)
        (setq haskell-process-type 'stack-ghci)
        (require 'ob-haskell)

        (org-babel-do-load-languages
         'org-babel-load-languages
         '((java . t)
           (clojure . t)
           ;; (clojurescript . t)
           (ditaa . t)
           (dot . t)
           ;; (elixir . t)
           (emacs-lisp . t)
           (gnuplot . t)
           (groovy . t)
           (haskell . t)
           (latex . t) ;; needs org-edit-latex
           (maxima . t) ;; maxima
           (plantuml . t)
           ;; (prolog . t)
           (python . t)
           (R . t)
           ;; (scala . t)
           (scheme . t)
           (sed . t)
           (shell . t)
           ;; (sml . t) ;; standard ml
           (sql . t)))

        )
    #+END_SRC
**** org babel clojurescript
     - prerequisite is availability of lumo (arch: 'yaourt -S lumo-git')
     - lumo is expected in /usr/local/bin/lumo (crete symlink might be necessary)
     #+BEGIN_SRC emacs-lisp
     (use-package ob-clojurescript
       :ensure t)
     #+END_SRC
**** org babel lfe
     - use e.g. '#+BEGIN_SRC lfe :session mysession'
     - see [[https://github.com/zweifisch/ob-lfe][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-lfe
       ;; :defer 10
       :after ( org))
     #+END_SRC
**** org babel mongo
     - use with following parameters for begin_src block
       :db        Database name
       :host      Host
       :port      Port
       :user	  Username
       :password  Password
       :mongoexec Mongo executable
     - see [[https://github.com/krisajenkins/ob-mongo][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-mongo
       ;; :defer 10
       :after ( org))
     #+END_SRC
**** org babel redis
     - use e.g. '#+BEGIN_SRC redis db: 127.0.0.1:6379'
     - see [[https://github.com/stardiviner/ob-redis][homepage]]
     - no more availble on elpa
     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ob-redis
       ;; :defer 10
       ;; :after ( org)
       )
     #+END_SRC
**** org babel translate
     - translate a babel source code e.g. '#+BEGIN_SRC translate :src de :dest it'
     - src can be omitted (is then auto)
     - see [[https://github.com/krisajenkins/ob-translate][homepage]]
     #+BEGIN_SRC emacs-lisp
     (use-package ob-translate
       ;; :defer 10
       ;; :after ( org)
       )
     #+END_SRC
**** org babel typescript
     - patch, see https://emacs.stackexchange.com/questions/55690/org-babel-javascript-error
     #+BEGIN_SRC emacs-lisp
       (use-package ob-typescript
         :ensure t
         :config
         (setq org-babel-js-function-wrapper
               "console.log(require('util').inspect(function(){\n%s\n}(), { depth: 100 }))")

         (add-to-list 'org-babel-load-languages '(typescript . t))
         (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
     #+END_SRC
**** org babel kotlin
     #+BEGIN_SRC emacs-lisp
     (use-package ob-kotlin
       ;; :defer 10
       :after ( org))
     #+END_SRC
**** org babel elixir
     #+BEGIN_SRC emacs-lisp
     (use-package ob-elixir
       :ensure t
       :after ( org))
     #+END_SRC
**** org babel browser
     #+BEGIN_SRC emacs-lisp
     (use-package ob-browser
       ;; :defer 10
       ;; :after ( org)
       )
     #+END_SRC
*** ob async
    - add ':async t' to #begin_src header, execution of block (C-c C-c within babel block) executes asynchronously)
    - see [[https://github.com/astahlman/ob-async][here]]
    #+BEGIN_SRC emacs-lisp
    (use-package ob-async
      :ensure t
       :after ( org async))
    #+END_SRC
*** adaptive warp
    #+BEGIN_SRC emacs-lisp :tangle no
    (when (locate-library "adaptive-wrap")
      (use-package adaptive-wrap))
    #+END_SRC
*** insertion of web images
    - allow insertion of images via url, which automatically downloads
      into a local folder and creates a link within the org file
      [[https://github.com/tashrifsanil/org-easy-img-insert]]
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-easy-img-insert
        :after ( org)
        :bind ("C-c i i" . org-easy-img-insert)
        :config (progn))
    #+END_SRC
*** org reveal (presentation)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ox-reveal
      :ensure t
      :after ( org htmlize)
      :config
      (progn
        ;; ox-reveal in the current version adds old format of structure template list, which needs to be removed here!
        (if (s-starts-with-p "#+BEGIN_NOTES" (car (cdr (car org-structure-template-alist))))
            (setq org-structure-template-alist (cdr org-structure-template-alist)))
        (setq org-reveal-root "./reveal.js"))) ;; look into local folder
    #+END_SRC
*** org table sticky headers
    - see [[https://github.com/cute-jumper/org-table-sticky-header][home page]]
    - headers of org tables stay in the header line while scrolling them out of view
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-table-sticky-header
        :ensure t
        :after ( org)
        :init
        (progn (add-hook 'org-mode-hook 'org-table-sticky-header-mode)))
    #+END_SRC
*** org pdftools (must be loaded before org mode)
    - see [[https://github.com/fuxialexander/org-pdftools][homepage]]
    - executing M-x org-store-link within pdf-view-mode, will store a link that can be inserted into org mode via C-c C-l
    - when opening this link, pdf-view-mode is opened instead of system default pdf viewer!
    #+BEGIN_SRC emacs-lisp
      (setq org-pdftools-link-prefix "pdfview")
      (use-package org-pdftools
        :ensure t
        :init (org-pdftools-setup-link)
        :config
        (defun gb/pdf-view-kill-window ()
          (interactive)
          (gb/org-store-link-to "~/pdf-views.org")
          (gb/kill-a-buffer-and-delete-window nil))

        (defun gb/pdf-view-kill ()
          (interactive)
          (gb/org-store-link-to "~/pdf-views.org")
          (gb/kill-a-buffer nil))

        (defun gb/org-store-link-to (link-file)
          ;; format: pdfview:~/Downloads/Coronateste_Altona_03_09_2020b.pdf::2++0.00
          (ignore-errors
            (let* ((file (buffer-file-name))
                   (page (pdf-view-current-page))
                   (link (format "%s:%s::%i++0.00" org-pdftools-link-prefix file page))
                   (name (file-name-base file)))
              (save-excursion
                (with-current-buffer (find-file-noselect link-file t)
                  (goto-char (point-max))
                  (if (not (re-search-backward (regexp-quote file) nil t))
                      (gb/org-store-link-to--insert-link-at-end file link name page)
                    (goto-char (line-beginning-position))
                    (unless (re-search-forward (regexp-quote link) nil t)
                      (gb/org-store-link-to--insert-link-at-end file link name page))))))))

        (defun gb/org-store-link-to--insert-link-at-end (file link name page)
          (goto-char (point-max))
          (insert "- ")
          (org-insert-link file link (format "%s - %s : %i" (format-time-string "%Y%m%d %H:%M") name page))
          (insert "\n"))

        (bind-key "q" #'gb/pdf-view-kill pdf-view-mode-map)
        (bind-key "C-x k" #'gb/pdf-view-kill pdf-view-mode-map)
        (bind-key "C-x C-k" #'gb/pdf-view-kill-window pdf-view-mode-map))

      ;; (use-package org-noter-pdftools
      ;;   :ensure t
      ;;   :after org-noter
      ;;   :config
      ;;   (with-eval-after-load 'pdf-annot
      ;;     (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
    #+END_SRC
*** org magit
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package orgit
      :after ( org magit)
      ;; :defer 40
      )
    #+END_SRC
*** org sidebar
    - see https://github.com/alphapapa/org-sidebar
      (related to https://github.com/alphapapa/org-super-agenda)
    #+begin_src emacs-lisp
      (use-package org-sidebar
        :ensure t
        :commands (org-sidebar-toggle org-sidebar)
        :custom
        (org-ql-sidebar-buffer-setup-hook
              '((lambda ()
                  "Set `mode-line-format' to nil."
                  (setf mode-line-format nil))))
        (org-super-agenda-groups
              '(
                (:todo "TEST" :order 1)
                (:todo "IMPLEMENT" :order 2)
                (:todo "TODO" :order 3)
                (:todo "PLANNED" :order 8))))
    #+end_src
** slack
 #+BEGIN_SRC emacs-lisp
   (use-package emojify
     :ensure t
     :hook (slack-mode . emojify-turn-on-emojify-mode)
     (org-mode . emojify-turn-off-emojify-mode ))

   (when (file-exists-p "~/repo/emacs-slack/slack.el")
     (use-package slack
       :load-path "~/repo/emacs-slack"
       ;; :commands (gb/slack-on gb/slack-off)
       :custom (slack-log-level 'warn "make log less verbose")
       :init
       (setq slack-enable-global-mode-string t)
       (setq slack-enable-emoji t) ;; if you want to enable emoji, default nil
       ;; (setq slack-room-subscription '(clojurians itemisHamburg))
       (setq slack-prefer-current-team t)

       (with-eval-after-load 'tracking
         (bind-key "s-\\" #'tracking-next-buffer tracking-mode-map)
         (bind-key "C-c C-SPC" #'avy-goto-char-timer tracking-mode-map) ;; restore original binding
         (bind-key "C-c SPC" #'avy-goto-char-timer tracking-mode-map))
       ;; Ensure the buffer exists when a message arrives on a
       ;; channel that wasn't open.

       ;; buffer tracking takes place only, if slack-buffer-create-on-notify is true!
       (setq slack-buffer-create-on-notify nil) ;; since tracking buffers is currently not used, this is nil

       :config
       (setq lui-time-stamp-format "[%m-%d %H:%M]")
       (setq lui-fill-column 110)
       (setq slack-thread-also-send-to-room nil) ;; never send thread message to channel, too

       (setq slack-modeline-filter
             '("^itemis - general$"
               "^itemis - somethingspecial$"
               "^itemis - random$"
               "^itemis - xtext"
               "^itemis - web-engineering$"
               "^itemis - nintendo-toad_pr$"
               "^itemis - publications$"))

       (defun gb/timer-active-p (timer)
         "check whether the given timer is currently active"
         (or (memq timer timer-list)
            (memq timer timer-idle-list)))

       ;; redefine whether team is relevant for modeline display
       (defun slack-team-modeline-enabledp (team)
         (if (boundp 'pomodoro-timer)
             (not (gb/timer-active-p pomodoro-timer))
           (s-equals? (oref team name) "itemis")))

       (defun gb/slack-update-modeline-advice ()
         (slack-update-modeline))

       (when (fboundp 'pomodoro-start)
         (advice-add #'gb/slack-update-modeline-advice :after 'pomodoro-start))
       (when (fboundp 'pomodoro-stop)
         (advice-add #'gb/slack-update-modeline-advice :after 'pomodoro-stop))
       (when (fboundp 'pomodoro-pause)
         (advice-add #'gb/slack-update-modeline-advice :after 'pomodoro-pause))
       (when (fboundp 'pomodoro-resume)
         (advice-add #'gb/slack-update-modeline-advice :after 'pomodoro-resume))

       (defun gb/slack-disable-modeline ()
         "remove slack modeline element from modeline if present, reenable with slack-enable-modeline"
         (setq global-mode-string (remove '(:eval slack-modeline) global-mode-string)))

       (defun gb/slack-init-mode-config ()
         "do some settings for slack"
         ;; show pictures in one piece (since they are chunked in lines)
         (setq-local line-spacing 0))

       (add-hook 'slack-mode-hook #'emojify-mode)
       (add-hook 'slack-mode-hook #'gb/slack-init-mode-config)
       (add-hook 'slack-thread-message-buffer-mode-hook #'emojify-mode)
       (add-hook 'slack-thread-message-buffer-mode-hook #'gb/slack-init-mode-config)
       (add-hook 'slack-file-info-buffer-mode-hook #'emojify-mode)
       (add-hook 'slack-file-info-buffer-mode-hook #'gb/slack-init-mode-config)


       (when (eq gb/completion-framework 'ivy)
         (defun gb/slack--emojify-insert-emoji ()
           (interactive)
           (when-let ((emoji (slack-select-emoji (slack-team-select))))
             (insert emoji)))

         (defun gb/slack--message-reaction-input (_team)
           (when-let ((emoji (slack-select-emoji (slack-team-select))))
             (if (and (string-prefix-p ":" emoji)
                      (string-suffix-p ":" emoji))
                 (substring emoji 1 -1)
               emoji)))

         (defun gb/slack--message-add-reaction ()
           (interactive)
           (slack-if-let* ((buf slack-current-buffer)
                           (team (slack-buffer-team buf))
                           (reaction (gb/slack--message-reaction-input team)))
                          (slack-buffer-add-reaction-to-message buf
                                                                reaction
                                                                (slack-get-ts))))

         ;; insert (embed) emoji
         (bind-key "C-c :" #'gb/slack--emojify-insert-emoji slack-mode-map)
         (bind-key "C-c :" #'gb/slack--emojify-insert-emoji slack-message-compose-buffer-mode-map)
         (bind-key "C-c :" #'gb/slack--emojify-insert-emoji slack-thread-message-buffer-mode-map)

         (bind-key "C-c C-a" #'gb/slack--message-add-reaction slack-message-buffer-mode-map)
         (bind-key "C-c C-a" #'gb/slack--message-add-reaction slack-mode-map)
         (bind-key "C-c C-a" #'gb/slack--message-add-reaction slack-thread-message-buffer-mode-map))

       (when (eq gb/completion-framework 'helm)
         (bind-key "C-c :" #'emojify-insert-emoji slack-mode-map)
         (bind-key "C-c :" #'emojify-insert-emoji slack-message-compose-buffer-mode-map)
         (bind-key "C-c :" #'emojify-insert-emoji slack-thread-message-buffer-mode-map)

         ;; add reaction
         (bind-key "C-c C-a" #'slack-message-add-reaction slack-message-buffer-mode-map)
         (bind-key "C-c C-a" #'slack-message-add-reaction slack-mode-map)
         (bind-key "C-c C-a" #'slack-message-add-reaction slack-thread-message-buffer-mode-map))

       ;; remove reaction
       (bind-key "C-c C-S-a" #'slack-message-remove-reaction slack-message-buffer-mode-map)
       (bind-key "C-c C-S-a" #'slack-message-remove-reaction slack-mode-map)
       (bind-key "C-c C-S-a" #'slack-message-remove-reaction slack-thread-message-buffer-mode-map)

       ;; insert (embed) direct mention of user
       (bind-key "C-c @" #'slack-message-embed-mention slack-mode-map)
       (bind-key "C-c @" #'slack-message-embed-mention slack-message-compose-buffer-mode-map)
       (bind-key "C-c @" #'slack-message-embed-mention slack-thread-message-buffer-mode-map)

       ;; mark as read
       (bind-key "C-c C-c" #'gb/slack-buffer--mark-read slack-mode-map)

       ;; edit message in separate buffer
       (bind-key "C-c '" #'slack-message-write-another-buffer slack-thread-message-buffer-mode-map)
       (bind-key "C-c '" #'slack-message-write-another-buffer slack-message-buffer-mode-map)

       ;; reply in thread
       (bind-key "C-c C-r" #'slack-thread-show-or-create slack-message-buffer-mode-map)
       (bind-key "C-c C-r" #'slack-thread-show-or-create slack-mode-map)
       (bind-key "C-c C-r" #'slack-thread-show-or-create slack-thread-message-buffer-mode-map)

       (setq gb/slack-team-registered nil)
       (defun gb/slack-register-teams ()
         "read slack api tokens and set configuration accordingly"
         (unless gb/slack-team-registered
           (let* ((auth-map (jde-read-properties-file "~/.slack.api.token.gpg")))
             (slack-register-team
              :name "itemis"
              :default t
              :token (gethash "slack-token" auth-map)
              :subscribed-channels '()
              :full-and-display-names t
              :mark-as-read-immediately nil
              :modeline-name "i"
              :visible-threads t
              :animate-image nil)
             (setq gb/slack-team-registered t))))

       (defvar gb/slack-update-list-timer nil)

       ;; make sure to not track common channels (annoying)
       ;; this is only relevant if tracking is used (which currently isn't)
       (setq tracking-ignored-buffers '(".*itemis : general.*" ".*itemis : xtext.*" ".*homecooking.*" ".*nintendo-pipe_pr.*" ".*itemis : random.*"))

       (defun gb/slack-all-room-names ()
         ""
         (--map (slack-room-name it (slack-team-select))
                (cl-loop for team in (list (slack-team-select))
                         append (append (slack-team-ims team)
                                        (slack-team-groups team)
                                        (slack-team-channels team)))))

       (defun gb/slack-room-by-regex (regex)
         ""
         (--first (s-matches? regex (slack-room-name it (slack-team-select)))
                  (cl-loop for team in (list (slack-team-select))
                           append (append (slack-team-ims team)
                                          (slack-team-groups team)
                                          (slack-team-channels team)))))

       (defun gb/slack-room-display (regex)
         (slack-room-display (gb/slack-room-by-regex regex) (slack-team-select)))

       (defun gb/slack-room-by-id (id-string)
         "get room by id"
         (--first (equal (oref it id) id-string)
                  (cl-loop for team in (list (slack-team-select))
                           append (append (slack-team-ims team)
                                          (slack-team-groups team)
                                          (slack-team-channels team)))))

       (defun gb/slack-group-mpim-open ()
         "open a the group mpim"
         (interactive)
         (let* ((req-resp (slack-group-mpim-open)))
           (make-thread `(lambda ()
                           (while (not (request-response-done-p ,req-resp))
                             (message "wait for room")
                             (sleep-for 0 100))
                           (message "open room")
                           (let ((room-id (plist-get (plist-get (request-response-data ,req-resp) :channel) :id)))
                             (slack-room-display (gb/slack-room-by-id room-id) (slack-team-select)))))))

       (setq gb/slack-status-active-list '("programming :typescript:" "programming :xtext:" "programming :java-coffee:" "enjoying lambdas :racket-lang:" "break :coffee:"))
       (setq gb/slack-status-away-list '("mampf :fork_and_knife:" "home :house_with_garden:" "vacationing :mount_fuji:"))

       (defun gb/slack-status-set-active ()
         (interactive)
         (gb/slack--status-set-to t))

       (defun gb/slack-status-set-inactive ()
         (interactive)
         (gb/slack--status-set-to nil))

       (defun gb/slack--status-set-to (active)
         "set slack status"
         (when-let* ((selected-status (completing-read "status" (--map (emojify-string it) (if active gb/slack-status-active-list gb/slack-status-away-list))))
                     (icon-matches    (s-match ":\\([^:]+\\):" selected-status))
                     (icon            (car icon-matches))
                     (text-matches    (s-match "\\([^:]+\\):" selected-status))
                     (text            (s-trim (cadr text-matches))))
           (message (format "icon %s, text %s" icon text))
           (slack-user-set-status-request (slack-team-select) icon text)
           (run-at-time 5 nil #'gb/slack-modeline-status-update)
           (if active
               (gb/slack-user-set-active)
             (gb/slack-user-set-away))))

       ;; (gb/slack-room-display "^nord$")

       ;; report slack status to mode line (updating it every ?s
       ;; (slack-user-status (plist-get(gb/slack-user-by-name "gunther") :id) (slack-team-select)) ;; get the status
       ;; (emojify-string ":xtext:")

       (defvar gb/slack-modeline--status nil "current user status in slack")
       (defvar gb/slack-modeline-status--timer nil "running timer for status updates")

       (defun gb/slack-modeline-status-activate ()
         "activate slack status in modeline"
         (setq gb/slack-modeline-status--timer (run-at-time 5 60 #'gb/slack-modeline-status-update))
         (add-to-list 'global-mode-string '(:eval gb/slack-modeline--status) t))

       (defun gb/slack-modeline-status-deactivate ()
         "remove slack status from modeline"
         (when gb/slack-modeline-status--timer
           (cancel-timer gb/slack-modeline-status--timer)
           (setq gb/slack-modeline-status--timer nil))
         (setq global-mode-string (remove '(:eval gb/slack-modeline--status) global-mode-string)))

       (defun gb/slack-modeline-status--string-transform (full-status)
         "transform complete slack status string to the string actually shown in the modeline"
         (let* ((first-icon (car (s-match ":[^:]+:" full-status))))
           (if (or (not first-icon)
                   (string-empty-p first-icon))
               full-status
             first-icon)))

       (defun gb/slack-modeline-status-update ()
         (setq gb/slack-modeline--status (s-concat " " (emojify-string (gb/slack-modeline-status--string-transform (slack-user-status (oref (slack-team-select) self-id) (slack-team-select))))))
         (force-mode-line-update))

       (defun gb/slack-user-presence-get ()
         (let* ((team (slack-team-select)))
           (gethash (oref team self-id)
                    (oref team presence)
                    "")))

       (defun gb/slack-user-set-away ()
         "set my user away in the current team"
         (let* ((team (slack-team-select)))
           (slack-request-set-presence team "away")))

       (defun gb/slack-user-set-active ()
         "set my user away in the current team"
         (let* ((team (slack-team-select)))
           (slack-request-set-presence team "auto")))

       (defun gb/slack-user-by-name (name)
         "get the slack id of the given name in the current group"
         (--first (and (s-equals-p name (plist-get it :name)) (eq :json-false (plist-get it :deleted))) (hash-table-values (oref (slack-team-select) users))))


       (defun gb/slack-rooms-unread ()
         "get all rooms with unread messages"
         (let* ((team (slack-team-select)))
           (cl-loop for team in (list team)
                    append (cl-remove-if
                            #'(lambda (room)
                                (not (slack-room-has-unread-p room team)))
                            (append (slack-team-ims team)
                                    (slack-team-groups team)
                                    (slack-team-channels team))))))

       (defun gb/slack-buffer--mark-read ()
         (interactive)
         (when (slack-message-buffer-p slack-current-buffer)
           (let* ((this slack-current-buffer)
                  (ts (slack-buffer-latest-ts this)))
             (slack-buffer-update-mark-request this ts)
             (message (format "Slack buffer %s is no up to date." (slack-buffer-name this))))))

       (defun gb/slack-off ()
         (interactive)
         (ignore-errors
           (when (-contains? kill-emacs-hook #'gb/slack-off)
             (remove-hook 'kill-emacs-hook #'gb/slack-off)))
         (ignore-errors (gb/slack-user-set-away))
         (gb/slack-disable-modeline)
         (gb/slack-modeline-status-deactivate)
         (when gb/slack-update-list-timer
           (ignore-errors (cancel-timer gb/slack-update-list-timer))
           (setq gb/slack-update-list-timer nil))
         (ignore-errors (slack-ws-close)))

       (defun gb/slack-on ()
         (interactive)
         (gb/slack-register-teams)
         (slack-start)
         (slack-enable-modeline)
         (gb/slack-user-set-active)
         (gb/slack-modeline-status-activate)
         (when gb/slack-update-list-timer
           (ignore-errors (cancel-timer gb/slack-update-list-timer))
           (setq gb/slack-update-list-timer nil))
         (setq gb/slack-update-list-timer (run-at-time nil 900 #'slack-room-list-update))
         (unless (-contains? kill-emacs-hook #'gb/slack-off)
           (add-hook 'kill-emacs-hook #'gb/slack-off t))))

     (use-package alert
       :ensure t
       :config
       (defun gb/alert-message-notify-org-file (info)
         (when (get-buffer "slack.org") (with-current-buffer "slack.org" (save-buffer)))
         (write-region
          (s-concat
           "* TODO "
           (s-replace (regexp-quote "\\[") "[" (plist-get info :title))
           " : "
           (format
            "[[emacs-slack:%s.%s][%s]] :slack:"
            (plist-get info :channel)
            (plist-get info :ts)
            (s-truncate 80 (s-replace "\n" ";" (plist-get info :message))))
           "\n"
           (format "<%s>" (format-time-string "%Y-%m-%d %H:%M"))
           "\n"
           (plist-get info :message)
           "\n")
          nil
          "/home/pe/slack.org"
          t))

       (defun gb/alert-message-notify-dunst (info)
         ""
         (let ((s-com (format "notify-send '%s' '%s'"
                              (plist-get info :title)
                              (plist-get info :message)
                              ;; (symbol-name (plist-get info :severity)) ;; severity does not match
                              )))
           (message s-com)
           (shell-command-to-string s-com)))

       (alert-define-style
        'gb-alert-via-org-file
        :title    "Make Org headings for slack messages I receive - Style"
        :notifier #'gb/alert-message-notify-org-file
        :remover  nil)

       (alert-define-style
        'gb-alert-via-dunst
        :title    "Alert via dunstify - Style"
        :notifier #'gb/alert-message-notify-dunst
        :remover  nil)

       (setq alert-default-style 'message)
       ;; ;; disable all alerts
       (setq alert-user-configuration
             '((((:title . "\\(.*nord\\|Slackbot\\|.*generali\\|.*nintendo-pipe\\|.*offizielles\\|.* mpdm-.*\\)")(:category . "slack")) gb-alert-via-org-file nil)
               (((:category . "slack")) ignore nil)
               (((:severity high)) gb-alert-via-dunst nil)))

       ;; (add-to-list
       ;;  'alert-user-configuration
       ;;  '(((:title . "\\(nord\\|Slackbot\\|generali\\|nintendo\\)")(:category . "slack")) gb-alert-style nil))
       ))
 #+END_SRC
* ido (disabled)
** ido itself (configured to being not used, since it is started anyways)
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (eq gb/completion-framework 'ido)
       (use-package ido
         :config
         ;; ido-mode allows you to more easily navigate choices. For example,
         ;; when you want to switch buffers, ido presents you with a list
         ;; of buffers in the the mini-buffer. As you start to type a buffer's
         ;; name, ido will narrow down the list of buffers to match the text
         ;; you've typed in
         ;; http://www.emacswiki.org/emacs/InteractivelyDoThings
         (ido-mode 1)

         ;; This allows partial matches, e.g. "tl" will match "Tyrion Lannister"
         (setq ido-enable-flex-matching t)

         ;; Turn this behavior off because it's annoying
         (setq ido-use-filename-at-point nil)

         ;; Don't try to match file across all "work" directories; only match files
         ;; in the current directory displayed in the minibuffer
         (setq ido-auto-merge-work-directories-length -1)

         ;; Includes buffer names of recently open files, even if they're not
         ;; open now
         (setq ido-use-virtual-buffers t)
         ))
   #+END_SRC
** ido grid (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-grid-mode
    :after ( ido)
    :disabled t
    :config
    ;; ido-grid-mode-max-columns 2
    ;; ido-grid-mode-min-columns 2
    (setq ido-grid-mode-max-rows 15
          ido-grid-mode-min-rows 10
          ido-grid-mode-max-columns 4
          ido-grid-mode-prefix-scrolls t
          ido-grid-mode-scroll-down #'ido-grid-mode-next-row
          ido-grid-mode-scroll-up #'ido-grid-mode-previous-row
          ido-grid-mode-order 'Row-mode ;; order is rows -> columns (t = columns -> rows)
          ido-grid-mode-start-collapsed nil) ;; collapsed = 1 row, on <tab> expand (if more than one is available)
    (ido-grid-mode 1))
#+END_SRC
** ido vertical (currently disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-vertical-mode
    :disabled t
    :after ( ido)
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))
#+END_SRC
** ido ubiquitous (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ido-ubiquitous
       :after ( ido)
       :disabled t
       :config 
       ;; This enables ido in all contexts where it could be useful, not just
       ;; for selecting buffer and file names
       (ido-ubiquitous-mode 1))   
   #+END_SRC
** flex ido (disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
    (use-package flx-ido
      :after ( ido org)
      :disabled t
      :config
    (flx-ido-mode 1)
    (ido-mode 1)
    (ido-everywhere 1)
    ;; disable ido faces to see flx highlights.
    (setq ido-enable-flex-matching t)
    (setq ido-use-faces nil)
    (setq org-completion-use-ido t))   
   #+END_SRC
* helm
** helm
   #+BEGIN_SRC emacs-lisp
     (use-package async
       :ensure t) ;; TODO: add all async requirements, otherwise this will not work
     (use-package popup
       :ensure t)
     ;;  (use-package helm-core
     ;;    :ensure t
     ;;    :after ( async)
     ;;    )
     (when (eq gb/completion-framework 'helm)
       (use-package helm
         :ensure t
         ;; :after ( async popup rainbow-delimiters ido)
         :bind (("M-x" . helm-M-x)
                ("C-x C-f" . helm-find-files)
                ("s-f" . helm-for-files)
                ("C-x s-f" . helm-for-files)
                ("C-x C-b" . helm-mini) ;;helm-buffers-list
                ("C-s-i" . helm-semantic-or-imenu)
                ;; resume previous helm session whatever it was, with the selection that was active then
                ;; helm-resume
                )
         :init (progn
                 ;; register new function
                 (add-hook 'helm-minibuffer-set-up-hook
                           'gb/helm-hide-minibuffer-maybe))
         :custom (helm-truncate-lines t "make sure lines are truncated in helm buffers")
         (helm-echo-input-in-header-line t "make sure keyboard entry is displayed in header line of helm buffer")
         (history-delete-duplicates t "make sure helm does not show duplicate entries")
         (helm-ff-keep-cached-candidates nil "make sure helm does not refresh caches when idle (reduce cpu load)")
         :config
         (progn
           (defun gb/org-center-when-at-bottom (&rest args)
             "recenter when focussing into an org file at the very bottom"
             (when (and(boundp 'mode-name)(equal mode-name "Org"))
               (save-excursion
                 (ignore-errors
                   (goto-char (line-end-position))
                   (unless (pos-visible-in-window-p (+ 1 (point)))
                     (recenter-top-bottom))))))
           (advice-add 'helm :after #'gb/org-center-when-at-bottom)
           ;;(advice-remove 'helm #'gb/org-center-when-at-bottom)

           ;; patch helm-keyboard-quit to only abort-recursive-edit if it is really in progress
           (defun helm-keyboard-quit ()
             "Quit minibuffer in helm.
     If action buffer is displayed, kill it."
             (interactive)
             (with-helm-alive-p
               (when (get-buffer-window helm-action-buffer 'visible)
                 (kill-buffer helm-action-buffer))
               (setq helm-exit-status 1)
               (when (> (recursion-depth) 0)
                 (abort-recursive-edit))))
           ;; make sure that minibuffer stays untouched if entry is displayed in top of helm buffer
           (defun gb/helm-hide-minibuffer-maybe ()
             "Hide minibuffer in Helm session if we use the header line as input field."
             (when (with-helm-buffer helm-echo-input-in-header-line)
               (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
                 (overlay-put ov 'window (selected-window))
                 (overlay-put ov 'face
                              (let ((bg-color (face-background 'default nil)))
                                `(:background ,bg-color :foreground ,bg-color)))
                 (setq-local cursor-type nil))))


           (helm-mode 1)
           (setq helm-display-function 'pop-to-buffer)
           (require 'helm-locate)
           (setq helm-locate-command "locate %s %s")
           (cond
            ((eq gb/theme-mode 'light) nil) ;; TODO complete
            (t (progn
                 (--each '((match ((t (:background "#1d1f21" :foreground "DarkGoldenrod1" :inverse-video nil)))))
                   (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
           (setq helm-split-window-default-side 'right)
           (setq helm-buffer-max-length nil)
           (setq helm-ff-skip-boring-files t)
           (require 'helm-files)
           (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/elpa/.*")
           (add-to-list 'helm-boring-file-regexp-list ".*/\.emacs\.d/.*autoloads\.elc?$")
           (add-to-list 'helm-boring-file-regexp-list "TAGS$")
           (add-to-list 'helm-boring-file-regexp-list "ido\.last$")
           (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*cache\.elc?$")
           (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/.*bookmarks$")
           (add-to-list 'helm-boring-file-regexp-list "News/KILL$")
           (add-to-list 'helm-boring-file-regexp-list "\.emacs\.d/\.session$")
           (add-to-list 'helm-boring-file-regexp-list "\.newsrc$")
           (add-to-list 'helm-boring-file-regexp-list "\.newsrc\.eld$")
           (add-to-list 'helm-boring-file-regexp-list "\.elfeed/index$")
           (setq helm-M-x-always-save-history t))))
   #+END_SRC
** helm posframe
   - show helm completion in a posframe
   - disabled because it is
     - not displayed at point position but at the bottom of the screen
     - it provides only a couple of lines for candidate selection
     - it has incompatibilities with exwm when running a graphical application (cannot s-b)
   - problems, when used with xapp in frame
   - problems, when using it in a shell buffer
   #+begin_src emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-posframe
         :ensure t
         :config
         (setq gb/helm-posframe-min-height 50)
         (setq gb/helm-posframe-min-width 120)
         (defun helm-posframe-display (buffer &optional _resume)
           "The display function which is used by `helm-display-function'.
     Argument BUFFER."
           (setq helm-posframe-buffer buffer)
           (posframe-show
            buffer
            :position (point)
            :poshandler helm-posframe-poshandler
            :width (or helm-posframe-width (+ (window-width) 2))
            :height (or helm-posframe-height helm-display-buffer-height)
            :min-height gb/helm-posframe-min-height
            :min-width gb/helm-posframe-min-width
            :internal-border-width 2
            :internal-border-color "#403040"
            ;; :font-height 14
            ;; :font gb/default-font
            :override-parameters helm-posframe-parameters
            :respect-header-line t)
           (with-current-buffer buffer
             (setq-local truncate-lines helm-truncate-lines)))
         ;; (setq helm-posframe-poshandler #'gb/posframe-poshandler-frame-center)
         (setq helm-posframe-poshandler #'gb/posframe-poshandler-frame-center-top)
         (defun gb/helm-set-posframe-parameters ()
           "set helm-posframe parameters. run previous to display, to ensure right display in multimonitor environments"
           (let ((xfac (cond ((eq 'helm-git-grep (helm-this-command)) 0.98)
                             ((eq 'helm-for-files (helm-this-command)) 0.77)
                             ((eq 'helm-mini (helm-this-command)) 0.77)
                             ((eq 'gb/exwm-program-select (helm-this-command)) (if (eq gb/dual-screen-mode 'presentation) 0.77 0.2))
                             ((eq 'helm-M-x (helm-this-command)) (if (eq gb/dual-screen-mode 'presentation) 0.77 0.3))
                             (t (if (eq gb/dual-screen-mode 'presentation) 0.77 0.5))))
                 (yfac (cond ((eq 'helm-for-files (helm-this-command)) 0.77)
                             ((eq 'helm-mini (helm-this-command)) 0.77)
                             ((eq 'helm-M-x (helm-this-command)) 0.77)
                             (t (if (eq gb/dual-screen-mode 'presentation) 0.77 0.5)))))
             ;; (message (symbol-name (helm-this-command)))
             (setq gb/helm-posframe-min-height (round (* yfac (cdr (assoc 'height (frame-parameters (selected-frame)))))))
             (setq gb/helm-posframe-min-width (round (* xfac (cdr (assoc 'width (frame-parameters (selected-frame)))))))
             (setq gb/posframe-offset (cdr (assoc 'left (frame-parameters (selected-frame)))))
             (setq helm-posframe-parameters
                   `((parent-frame)                                                          ;; (works only on single monitor)
                     (display . ,(cdr (assoc 'display (frame-parameters (selected-frame))))) ;; (hopefully holds display of current monitor)
                     (font . ,(cdr (assoc 'font (frame-parameters (selected-frame)))))
                     (alpha 90 90)
                     (left-fringe . 10)
                     (right-fringe . 10)))))
         (advice-add 'helm-posframe-display :before #'(lambda (orig-func &rest args) (gb/helm-set-posframe-parameters)))
         (helm-posframe-enable)
         ;; make sure minibuffer does not use helm completion!
         (bind-key "TAB" #'(lambda () (interactive) (setq inhibit-message t) (helm-posframe-disable) (helm-mode -1) (completion-at-point) (helm-mode 1) (helm-posframe-enable)(setq inhibit-message nil)) minibuffer-local-map)
         (bind-key "<tab>" #'(lambda () (interactive) (setq inhibit-message t) (helm-posframe-disable) (helm-mode -1) (completion-at-point) (helm-mode 1) (helm-posframe-enable)(setq inhibit-message nil)) minibuffer-local-map)))
   #+end_src
** helm org
   #+begin_src emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-org
         :bind (:map org-mode-map ("s-i" . helm-org-in-buffer-headings))
         :ensure t))
   #+end_src
** helm cmd t
   #+begin_src emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-cmd-t
         :ensure t
         :bind (("s-g" . helm-cmd-t)
                ("s-t" . helm-cmd-t-repos))
         :config
         (setq helm-cmd-t-candidate-number-limit 60)))
   #+end_src
** helm git grep
   #+begin_src emacs-lisp 
     (when (eq gb/completion-framework 'helm)
       (use-package helm-ls-git
         :ensure t
         :commands (helm-ls-git-ls)))
   #+end_src
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-git-grep
         :ensure t
         :after ( helm)
         :bind (("C-c g h" . helm-git-grep)
                :map isearch-mode-map
                ("C-c g h" . helm-git-grep-from-isearch)
                :map helm-map
                ("C-c g h" . helm-git-grep-from-helm))
         ;; :config
         ;; (bind-key "C-c g" 'helm-git-grep)
         ;; ;; Invoke `helm-git-grep' from isearch.
         ;; (bind-key "C-c g" 'helm-git-grep-from-isearch isearch-mode-map)
         ;; ;; Invoke `helm-git-grep' from other helm.
         ;; (bind-key "C-c g" 'helm-git-grep-from-helm helm-map)
         ))
   #+END_SRC
** helm projectile
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-projectile
         :after ( helm projectile)
         :config
         (helm-projectile-on))) ;; enable helm projectile key bindings, helm-projectile-off restores old keybindings
   #+END_SRC
** sort helm with flex
   - helm candidates are sorted using flx (more fuzzy sorting)
 #+BEGIN_SRC emacs-lisp
   (when (eq gb/completion-framework 'helm)
     (use-package helm-flx
       :ensure t
       :after ( helm)
       :config
       (progn
         (helm-flx-mode +1)
         (setq helm-flx-limit 500)
         ;; optional fuzzy matching for helm-M-x
         (setq helm-M-x-fuzzy-match t)
         (setq completion-styles `(basic partial-completion emacs22 initials ,(if (version<= emacs-version "27.0") 'helm-flex 'flex)))

         (setq helm-bookmark-show-location t)
         (setq helm-completion-in-region-fuzzy-match t)
         (setq helm-file-cache-fuzzy-match t)
         (setq helm-mode-fuzzy-match t)
         ;; ---
         (setq helm-ff-fuzzy-matching t)
         ;; only possible in unix environments (adds -b to locate)
         ;; (setq helm-locate-fuzzy-match t)
         (setq helm-etags-fuzzy-match t)
         (setq helm-recentf-fuzzy-match t)
         (setq helm-imenu-fuzzy-match t)
         (setq helm-buffers-fuzzy-matching t)
         (setq helm-lisp-fuzzy-completion t)
         (setq helm-apropos-fuzzy-match t)
         (setq helm-company-fuzzy-match t)
         (setq helm-projectile-fuzzy-match t)
         (setq helm-locate-library-fuzzy-match t))))
 #+END_SRC
** helm extensions
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (eq gb/completion-framework 'helm)
       (use-package helm-ext
         :ensure t
         :after ( helm)
         :config
         (progn
           (helm-ext-ff-enable-skipping-dots nil) ;; skip . and .. directory entries in non-empty directories :: nil because renaming from dired to other open dir would not work
           (helm-ext-ff-enable-zsh-path-expansion t) ;; allow for /h/q/f/b to expand to /home/qjp/foo/bar
           (helm-ext-ff-enable-auto-path-expansion t) ;; expansion is done during typing
           (helm-ext-minibuffer-enable-header-line-maybe t) ;; allow helm expansion in mini buffer (using header line to do so)
           ;; additional command ace-jump-helm-line
           )))
   #+END_SRC
* vagrant docker ansible
** docker
#+BEGIN_SRC emacs-lisp
  (use-package docker
    :commands docker-machines docker-volumes docker-images docker-containers
    :ensure t
    :config
    (progn
      (if (is-macos-p)
          (progn
            (setenv "DOCKER_TLS_VERIFY" "1")
            (setenv "DOCKER_HOST" "tcp://192.168.99.100:2376")
            (setenv "DOCKER_CERT_PATH" "~/.docker/machine/machines/docker-host-4gb-2cpu")
            (setenv "DOCKER_MACHINE_NAME" "docker-host-4gb-2cpu")))
      ))
  (use-package docker-tramp
    :ensure t
    :after ( docker))
#+END_SRC
** vagrant
#+BEGIN_SRC emacs-lisp
  (use-package vagrant
    :commands vagrant-up vagrant-edit vagrant-status)
  (use-package vagrant-tramp
    ;; :defer 20
    :after ( vagrant)
    :commands vagrant-tramp-term)
#+END_SRC
** ansible
*** ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ansible
        ;; :defer 30
        :commands ansible)
    #+END_SRC
*** ansible-doc (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ansible-doc
      ;; :defer 30
      :commands ansible-doc ansible-doc-mode)
    #+END_SRC
*** company-ansible (disabled)
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package company-ansible
      ;; :defer 30
      :after ( company))
    #+END_SRC
* imenu
  - display imenu in separate buffer (through 'M-x imenu-list-minor-mode')
  - https://github.com/bmag/imenu-list
  #+BEGIN_SRC emacs-lisp
    (use-package imenu-list
      :ensure t)
    ;; (use-package imenu+)
  #+END_SRC
* imenu-anywhere
  show ido/helm menu for all etags of currently open buffers
  the commands are
  - imenu-anyhwere
  - helm-imenu-anywhere
  #+BEGIN_SRC emacs-lisp
    (when (eq gb/completion-framework 'helm)
      (use-package imenu-anywhere
        :ensure t
        :bind (("s-i" . helm-imenu-anywhere)
               ("s-I" . helm-imenu-anywhere))))
  #+END_SRC
* crux (disabled)
  - look at https://github.com/bbatsov/crux for additional functions that might be of interest
#+BEGIN_SRC emacs-lisp :tangle no
(use-package crux
   :disabled t
   :bind (("C-u s-f" . crux-recentf-ido-find-file)) ;; recent file selection with ido
)
#+END_SRC
* DISABLED flycheck-tip
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck-tip
    :disabled t)
#+END_SRC
 * hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :bind (
           ( "<f1>" . hydra-allhydras/body) ;; globally defined, can be locally redefined
           ( "<M-f1>" . hydra-allhydras/body) ;; always jump to the global hydra
           ;; make buffer specific f1 bindings
           ;; :map org-agenda-mode-map
           ;; ( "<f1>" . hydra-org-agenda-view/body )
           )
    :config



    ;;--------------------------------------------------------------------------------
    ;; (when (package-installed-p 'org)
    ;;   (defun org-agenda-cts ()
    ;;     (ignore-errors
    ;;       (let* ((args (get-text-property
    ;;                     (min (1- (point-max)) (point))
    ;;                     'org-last-args)))

    ;;         (nth 2 args))))

    ;;   ;; currently not functional (probably because of hydra update)
    ;;   (defhydra hydra-org-agenda-view ()
    ;;     "
    ;;         org agenda view
    ;;         ------------------------------------------------------
    ;;         _d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
    ;;         _w_: ?w? week       _[_: inactive      _A_: arch-files
    ;;         _t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
    ;;         _m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
    ;;         _y_: ?y? year       _q_: quit          _L__l__c_: ?l?

    ;;       %s(hydra-combine-functions-w-key-bindings
    ;;         '((\"  [d]   day      \" . org-agenda-day-view)
    ;;           (\"  [w]   week     \" . org-agenda-week-view)
    ;;           (\"  [t]   fortnight\" . org-agenda-fortnight-view)
    ;;           (\"  [m]   month    \" . org-agenda-month-view)
    ;;           (\"  [y]   year     \" . org-agenda-year-view)
    ;;           (\"  [lLc] log mode \" . org-agenda-log-mode)
    ;;           (\"  [f]   follow   \" . org-agenda-follow-mode)
    ;;           (\"  [aA]  archive  \" . org-agenda-archives-mode)
    ;;           (\"  [r]   report   \" . org-agenda-clockreport-mode)
    ;;           (\"  [e]   entry    \" . org-agenda-entry-text-mode)
    ;;           (\"  [g]   grid     \" . org-agenda-toggle-time-grid)
    ;;           (\"  [D]   diary    \" . org-agenda-toggle-diary)
    ;;           ))
    ;;       "
    ;;     ("SPC" org-agenda-reset-view)
    ;;     ("d" org-agenda-day-view
    ;;      (if (eq 'day (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("w" org-agenda-week-view
    ;;      (if (eq 'week (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("t" org-agenda-fortnight-view
    ;;      (if (eq 'fortnight (org-agenda-cts))
    ;;          "[x]" "[ ]"))
    ;;     ("m" org-agenda-month-view
    ;;      (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("y" org-agenda-year-view
    ;;      (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
    ;;     ("l" org-agenda-log-mode
    ;;      (format "% -3S" org-agenda-show-log))
    ;;     ("L" (org-agenda-log-mode '(4)))
    ;;     ("c" (org-agenda-log-mode 'clockcheck))
    ;;     ("f" org-agenda-follow-mode
    ;;      (format "% -3S" org-agenda-follow-mode))
    ;;     ("a" org-agenda-archives-mode)
    ;;     ("A" (org-agenda-archives-mode 'files))
    ;;     ("r" org-agenda-clockreport-mode
    ;;      (format "% -3S" org-agenda-clockreport-mode))
    ;;     ("e" org-agenda-entry-text-mode
    ;;      (format "% -3S" org-agenda-entry-text-mode))
    ;;     ("g" org-agenda-toggle-time-grid
    ;;      (format "% -3S" org-agenda-use-time-grid))
    ;;     ("D" org-agenda-toggle-diary
    ;;      (format "% -3S" org-agenda-include-diary))
    ;;     ("!" org-agenda-toggle-deadlines)
    ;;     ("["
    ;;      (let ((org-agenda-include-inactive-timestamps t))
    ;;        (org-agenda-check-type t 'timeline 'agenda)
    ;;        (org-agenda-redo)))
    ;;     ("q" (message "Abort") :exit t)))

    ;;--------------------------------------------------------------------------------
    (defhydra hydra-profiler ()
      "
          profiler
          ^-^-------------------^-^-----------------
          _s_: start profiler   _r_: profiler report
          _e_: end profiler
        "
      ("s" profiler-start :exit t)
      ("e" profiler-stop :exit t)
      ("r" profiler-report :exit t))

    ;;--------------------------------------------------------------------------------
    (when (eq gb/completion-framework 'helm)
      (when (package-installed-p 'dash)
        (defhydra hydra-dash ()
          "
           dash
           ^-^---------------------^-^--------------------------
           _h_ helm dash at point  _d_ dash at point
           ^ ^                     _D_ dash at point with docset

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [h] helm dash at point     \" . helm-dash-at-point)
              (\"  [d] dash at point          \" . dash-at-point)
              (\"  [D] dash at point w/ docset\" . dash-at-point-with-docset)))
        "
          ("h" helm-dash-at-point :exit t)
          ("d" dash-at-point :exit t)
          ("D" dash-at-point-with-docset :exit t)
          )))

    ;;--------------------------------------------------------------------------------
    (when (package-installed-p 'avy-zap)
      (defhydra hydra-avy ()
        "
          avy
          ^-^-------------------^-^-----------------
          _z_: zap up to char        _c_: jump to word
          _Z_: zap to including char _l_: jump to line
          ^ ^                        _i_: jump to char within line

          %s(hydra-combine-functions-w-key-bindings
            '((\"  [z] zap up to char       \" . avy-zap-up-to-char)
              (\"  [Z] zap to including char\" . avy-zap-to-char-dwim)
              (\"  [c] jump to word         \" . avy-goto-word-1)
              (\"  [l] jump to line         \" . avy-goto-line)
              (\"  [i] jump to char w/i line\" . avy-goto-char-in-line)))
        "
        ("c" avy-goto-word-1 :exit t)
        ("z" avy-zap-to-char :exit t)
        ("Z" avy-zap-to-char-dwim :exit t)
        ("l" avy-goto-line :exit t)
        ("i" avy-goto-char-in-line :exit t)))

  (defhydra hydra-ui-info ()
       "
         ui-info
         -----------------------------
         _=_: what cursor position (C-u for font information)

         %s(hydra-combine-functions-w-key-bindings
            '((\" [=] what cursor position \" . what-cursor-position))))

       "
       ("=" what-cursor-position :exit t))

    ;;--------------------------------------------------------------------------------
    ;; TODO: install only those hydras that are actually defined
    (defhydra hydra-allhydras ()
      "
          list of all hydras
          ^--^------------------------^-^---------------
          _cr_: clojure refactoring   _m_ : multi cursor
          _n_ : navigate              _gm_: gnus mime
          _oa_: org agenda view       _gs_: gnus summary
          _om_: org mode              _gg_: gnus group
          _pp_: emacs profiler        _a_ : avy
          _i_ : ivy                   _d_ : dash
          _u_ : ui info
          ^ ^                         _q_ : quit
        "
      ("a" hydra-avy/body :exit t)
      ("cr" hydra-all-clojure-refactorings/body :exit t)
      ("m" hydra-multiple-cursors/body :exit t)
      ("n"  hydra-navigate-history/body :exit t)
      ("gs"  hydra-gnus-summary/body :exit t)
      ("gm" hydra-gnus-article-mime-part/body :exit t)
      ("gg" hydra-gnus-group/body :exit t)
      ("oa" hydra-org-agenda-view/body :exit t)
      ("om" hydra-org-mode/body :exit t)
      ("pp" hydra-profiler/body :exit t)
      ("i" hydra-ivy/body :exit t)
      ("d" hydra-dash/body :exit t)
      ("u" hydra-ui-info/body :exit t)
      ("q" (message "Abort") :exit t))

    )
#+END_SRC
** major mode hydra
   - define pretty hydras for major modes pretty easy (see [[https://github.com/jerrypnz/major-mode-hydra.el][here]])
   #+begin_src emacs-lisp
   (use-package major-mode-hydra
     :ensure t)
   #+end_src
* guide keys (disabled)
** alternative to which-key
*** can be tuned to react to certain prefixes only
*** can be tuned to highlight displayed shortcuts based on regular expressions
*** [[https://github.com/kai2nenobu/guide-key]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package guide-key
  :disabled t
  :init
  (setq guide-key/guide-key-sequence '("C-c C-x"))
  (guide-key-mode 1))
(use-package guide-key-tip
  :disabled t
  :after ( guide-key))
#+END_SRC
* gnuplot
** major mode to edit .gp files and drive gnuplot directly from there
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot
    :mode ( "\\.gp\\'" . gnuplot-mode)
    :ensure t
    :commands gnuplot-mode
    :config
    (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
    (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot-mode" t))
#+END_SRC
** alternative
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot-mode
    :ensure t)
#+END_SRC
* graphviz dot
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :commands graphviz-dot-mode
    
    :config
    (setq graphviz-dot-view-command "xdot %s"))
#+END_SRC
* backup
** backup edited files
   #+BEGIN_SRC emacs-lisp
     ;; Write backup files to own directory
     (setq backup-directory-alist `(("." . ,(expand-file-name "~/file-backups")))
           backup-by-copying t
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC
** backup with version control and helm
  all files saved are automatically backed up using git.
  with M-x helm-backup while within the open file, old
  versions can be ediffed with the current
#+BEGIN_SRC emacs-lisp
  (use-package helm-backup
    :load-path "~/repo/helm-backup"
    :init (add-hook 'after-save-hook #'helm-backup-versioning)
    :config
    (setq helm-backup-excluded-entries
          `(,(regexp-quote "/home/pe/.emacs-bmk-bmenu-state.el")
            ,(regexp-quote "/home/pe/.emacs.d/company-statistics-cache.el")
            ,(s-concat (regexp-quote "/home/pe/.emacs.d/emms/") ".*")
            ,(regexp-quote "/home/pe/.emacs.d/init.el")
            ,(regexp-quote "/home/pe/.newsrc-dribble" )
            ,(regexp-quote "/home/pe/.newsrc.eld")
            ,(regexp-quote "/home/pe/cal-based-diary")
            ,(s-concat (regexp-quote "/home/pe/documents/roam/" ) ".*")
            ,(s-concat (regexp-quote "/home/pe/repo/") ".*"))))
#+END_SRC
* latex (auctex)
** auctex
   #+BEGIN_SRC emacs-lisp
     (use-package tex-mode
       :ensure auctex
       :after ( flymake)
       :init (progn
         ;; latex, activate flyspell
         (add-hook 'TeX-mode-hook (lambda () (progn (flyspell-mode 1))))

         ;; activate auto fill mode
         (add-hook 'TeX-mode-hook #'gb/enable-auto-fill-mode)

         ;; make sure that flymake works with latex installation on mac
         (defun flymake-get-tex-args (file-name)
           (list "pdflatex" (list "-file-line-error" "-draftmode" "-interaction=nonstopmode" file-name)))
         (add-hook 'TeX-mode-hook (lambda () (flymake-mode 1)))       )
       :config
       (progn
         (setq TeX-auto-save t)
         (setq TeX-parse-self t)
         (setq TeX-save-query nil)
         (setq org-preview-latex-default-process 'imagemagick)

         (global-prettify-symbols-mode)))
   #+END_SRC
** company for auctex
   - see [[https://github.com/alexeyr/company-auctex/][here]]
   - adds company backend for latex proposals
   #+BEGIN_SRC emacs-lisp
     (use-package company-auctex
       :ensure t
       :after ( tex-mode company yasnippet)
       :config (company-auctex-init))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (use-package company-math
       :ensure t
       :after ( company tex-mode)
       :init (add-hook 'TeX-mode-hook 'gb/latex-mode-setup)
       :config
       ;; local configuration for TeX modes
       (defun gb/latex-mode-setup ()
         (setq-local company-backends
                     (append '((company-math-symbols-latex company-latex-commands))
                             company-backends)))

       )
   #+END_SRC
** bibtex
   - check https://nickhigham.wordpress.com/2016/01/06/managing-bibtex-files-with-emacs/
   #+BEGIN_SRC emacs-lisp
     (when (locate-library "parsebib")
       (use-package parsebib))
     (use-package let-alist)
     (use-package biblio-core
       :after ( let-alist seq dash))
     (use-package biblio
       :after ( biblio-core))
     (when (eq gb/completion-framework 'helm)
       (use-package helm-bibtex
         :after ( helm parsebib dash biblio)))
   #+END_SRC
** latex extra
   - see [[https://github.com/Malabarba/latex-extra][here]]
   - add some extra navigation (C-c C-n/p next/previous, a/e beginning/end, f/b same level forward/back, u up one level)
   - content folding (tab)
   - white space handling (C-c C-q : fill paragraph similar to M-q)
  #+BEGIN_SRC emacs-lisp
    (use-package latex-extra
      :after ( tex-mode)
      :hook (LaTeX-mode-hook . latex-extra-mode))
  #+END_SRC
** do previewing with "M-x latex-preview-pane-mode"
   updates preview on every save
   disable by calling the same command again
  #+BEGIN_SRC emacs-lisp
  (use-package latex-preview-pane
    :after ( tex-mode pdf-tools)
    :commands latex-preview-pane-mode
    :config
    (progn
      ;; (require 'pdf-tools)
      (setq latex-preview-pane-use-frame (if gb/use-exwm t))
      (latex-preview-pane-enable)
      (require 'latex-preview-pane)
      ;;    NOTES: adjustments had to be made so that preview works with pdf-tools:
      (defun latex-preview-pane-update-p ()
        (if (eq (lpp/invoke-pdf-latex-command) 1)
            (progn
              (lpp/display-backtrace)
              (remove-overlays)
              (lpp/line-errors-to-layovers (lpp/line-errors))
              )

          (let ((pdf-filename (replace-regexp-in-string "\.tex$" ".pdf" (lpp/buffer-file-name)))
                (tex-buff (current-buffer))
                (pdf-buff (replace-regexp-in-string "\.tex" ".pdf" (buffer-name (get-file-buffer (lpp/buffer-file-name))))))
            (remove-overlays)
            ;; if the file doesn't exist, say that the file isn't available due to error messages
            (if (file-exists-p pdf-filename)
                (if (eq (get-buffer pdf-buff) nil)
                    (set-window-buffer (lpp/window-containing-preview) (find-file-noselect pdf-filename))
                  (progn
                    (set-window-buffer (lpp/window-containing-preview) pdf-buff)
                    (switch-to-buffer-other-window pdf-buff)
                    (doc-view-revert-buffer nil t)
                    (revert-buffer :NOCONFIRM t) ;; gb 20161117: added such that pdf-tools work, too!
                    (switch-to-buffer-other-window tex-buff)
                    ))

              ))))
      ))
  #+END_SRC
* dired
** configuration
   #+BEGIN_SRC emacs-lisp
     (use-package dired
       :bind (("C-x d" . dired)
              :map dired-mode-map
              ("C-c m" . gb/dired-open-media)
              ("C-p" . diredp-previous-line)
              ("`" . gb/dired-open-term)
              ("e" . gb/dired-ediff-files))
       :init
       (add-hook 'dired-mode-hook 'auto-revert-mode)
       (add-hook 'dired-mode-hook 'dired-omit-mode)
       (defun gb/dired-open-media ()
         "open mount point for media in separate dired window"
         (interactive)
         (dired "/run/media/pe"))
       :config
       (setq dired-omit-size-limit 60000)
       (setq dired-dwim-target t) ;; try to guess the directory to use for dired
       (setq dired-listing-switches "-Alh --group-directories-first") ;; default switches for ls to be used for dired listing
       (setq diredp-hide-details-propagate-flag t) ;; opening subfolders inherit details flag (shown/hidden)
       (if gnu-ls-installed
           (setq insert-directory-program gnu-ls-bin-path))
       (setq  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..*\\|^build$\\|^out$")
       (setq dired-guess-shell-alist-user '(
                                            ("\\.webm\\'\\|\\.mkv\\'\\|\\.mpe?g\\'\\|\\.avi\\'\\|\\.mp4\\'\\|\\.flv\\'" "cvlc")
                                            ("\\.sid\\'" "sidplayfp")
                                            ("\\.html?\\'" "firefox")
                                            ("\\.docx?\\'\\|\\.xlsx?\\'\\|\\.pptx?\\'\\|\\.odt\\'" "soffice")
                                            ("\\.eps\\'\\|\\.pdf\\'" "evince")))

       (defun gb/dired-create-directory-with-marked-files (directory)
         "Create a directory called DIRECTORY and move all marked files into that directory (if any).
     Parent directories of DIRECTORY are created as needed.
     If DIRECTORY already exists, signal an error."
         (interactive
          (list (read-file-name "Create directory: " (dired-current-directory))))
         (let* ((expanded (directory-file-name (expand-file-name directory)))
                new)
           (if (file-exists-p expanded)
               (error "Cannot create directory %s: file exists" expanded))
           (setq new (dired--find-topmost-parent-dir expanded))
           (make-directory expanded t)
           (--each
               (dired-get-marked-files)
             (let ((name (file-name-nondirectory it)))
               (message (format "moving file %s to %s "  it (format "%s/%s" expanded name)))
               (rename-file it (format "%s/%s" expanded name))))
           (when new
             (dired-add-file new)
             (dired-move-to-filename))))

       ;; see https://oremacs.com/2016/02/24/dired-rsync/
       (defun gb/dired-rsync (dest)
         "copy marked files asynchronously with progress information in separate buffer"
         (interactive
          (list
           (expand-file-name
            (read-file-name
             "Rsync to:"
             (dired-dwim-target-directory)))))
         ;; store all selected files into "files" list
         (let ((files (dired-get-marked-files
                       nil current-prefix-arg))
               ;; the rsync command
               (tmtxt/rsync-command
                "rsync -arvz --progress "))
           ;; add all selected file names as arguments
           ;; to the rsync command
           (dolist (file files)
             (setq tmtxt/rsync-command
                   (concat tmtxt/rsync-command
                           (shell-quote-argument file)
                           " ")))
           ;; append the destination
           (setq tmtxt/rsync-command
                 (concat tmtxt/rsync-command
                         (shell-quote-argument dest)))
           ;; run the async shell command
           (async-shell-command tmtxt/rsync-command "*rsync*")
           ;; finally, switch to that window
           (other-window 1)))

       ;; snippet from
       (defun gb/dired-open-term ()
         "Open an `ansi-term' that corresponds to current directory."
         (interactive)
         (let* ((current-dir (dired-current-directory))
                (current-file (dired-get-filename))
                (wanted-dir (if (file-directory-p current-file)
                                current-file
                              current-dir)))
           (if (file-remote-p wanted-dir)
               (term-send-string
                (gb/terminal wanted-dir)
                (when (file-remote-p wanted-dir)
                  (let ((tramp-file-name (tramp-dissect-file-name wanted-dir t)))
                    (format "ssh %s@%s\n"
                            (aref tramp-file-name 1) (aref tramp-file-name 2)))))
             (cd wanted-dir)
             (gb/terminal wanted-dir))))

       (defun gb/dired-open-file-from-here ()
         "Open an `ansi-term' that corresponds to current directory."
         (interactive)
         (let* ((current-dir (dired-current-directory))
                (current-file (dired-get-filename))
                (wanted-dir (if (file-directory-p current-file)
                                current-file
                              current-dir)))
           (unless (file-remote-p wanted-dir)
             (if (eq gb/completion-framework 'helm)
                 (helm-find-files-1 wanted-dir)
               (find-file wanted-dir)))))

       (defun gb/terminal (&optional suffix)
         "Switch to terminal. Launch if nonexistent."
         (interactive)
         (let* ((buffer-name (generate-new-buffer-name (s-concat "*terminal" (or suffix "") "*"))))
           (shell buffer-name)))

       ;; snippet from https://oremacs.com/2017/03/18/dired-ediff/
       (defun gb/dired-ediff-files ()
         "ediff two marked files (no questions asked)"
         (interactive)
         (let ((files (dired-get-marked-files))
               (wnd (current-window-configuration)))
           (if (<= (length files) 2)
               (let ((file1 (car files))
                     (file2 (if (cdr files)
                                (cadr files)
                              (read-file-name
                               "file: "
                               (dired-dwim-target-directory)))))
                 (if (file-newer-than-file-p file1 file2)
                     (ediff-files file2 file1)
                   (ediff-files file1 file2))
                 (add-hook 'ediff-after-quit-hook-internal
                           (lambda ()
                             (setq ediff-after-quit-hook-internal nil)
                             (set-window-configuration wnd))))
             (error "no more than 2 files should be marked")))))
   #+END_SRC
** dired imenu (to select files)
   #+begin_src emacs-lisp
   (use-package dired-imenu
     :ensure t
     ;; key must not be configured through :bind, since add hook is not executed if s-i is used
     :config (bind-key "s-i" #'imenu  dired-mode-map))
   #+end_src
** dired subtree
   #+BEGIN_SRC emacs-lisp
     (use-package dired-subtree
       :ensure t
       :demand t
       :commands (gb/dired-toggle-expanding-single-dirs dired-subtree-up dired-subtree-up)
       :bind (:map dired-mode-map
                   ("TAB" . gb/dired-toggle-expanding-single-dirs)
                   ("[" . dired-subtree-up)
                   ("C-c C-u" . dired-subtree-up))
       :config
       (cond
        ((eq gb/theme-mode 'light) nil) ;; TODO complete
        (t (progn
             (--each '((dired-subtree-depth-1-face ((t (:background "#252e30" :extend t))))
                       (dired-subtree-depth-2-face ((t (:background "#232a2b" :extend t))))
                       (dired-subtree-depth-3-face ((t (:background "#212627" :extend t))))
                       (dired-subtree-depth-4-face ((t (:background "#1e2223" :extend t))))
                       (dired-subtree-depth-5-face ((t (:background "#1c1d1e" :extend t))))
                       (dired-subtree-depth-6-face ((t (:background "#1a191a" :extend t)))))
               (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))

     (defun gb/dired--get-depth-at-point ()
       "get the level (staring with 1) of the subdirectory at point (else nil)"
       (when (or (dired-subtree--dired-line-is-directory-or-link-p) t)
         (let* ((beg (point))
                (self (dired-subtree--get-ov beg)))
           (or (and self (1+ (overlay-get self 'dired-subtree-depth)))
               1))))

     (defun gb/dired-toggle-expanding-single-dirs ()
       "toggle subdir folding, expanding subdirectories with single folders recursively"
       (interactive)
       (save-excursion
         (when (dired-subtree--dired-line-is-directory-or-link-p)
           (dired-subtree-toggle)
           (when (dired-subtree--is-expanded-p)
             (let* ((depth (gb/dired--get-depth-at-point)))
               (forward-line)
               (when (dired-subtree--dired-line-is-directory-or-link-p)
                 (let* ((c-depth (gb/dired--get-depth-at-point)))
                   (when (and (dired-subtree--dired-line-is-directory-or-link-p)
                              (= c-depth (1+ depth)))
                     (forward-line)
                     (let* ((s-depth (gb/dired--get-depth-at-point)))
                       (forward-line -1)
                       (when (< (or s-depth 1) c-depth)
                         (gb/dired-toggle-expanding-single-dirs)))))))))
         (when (fboundp 'dired-sidebar-redisplay-icons)
           (dired-sidebar-redisplay-icons))))
   #+END_SRC
** dired sidebar
   - patched line 605 in dired-sidebar.el with '(dirs (split-string (cadr (split-string name (regexp-quote root))) "/")))'
   #+BEGIN_SRC emacs-lisp
     (use-package vscode-icon
       :ensure t
       :config)
     (use-package dired-sidebar
       :ensure t
       :bind (( "s-A" . dired-sidebar-toggle-sidebar)
              ( "s-a" . gb/dired-sidebar-follow-file)
              :map dired-sidebar-mode-map
              ( "c-s" . nonincremental-search-forward)
              ( "C-x C-f" . gb/dired-open-file-from-here)
              ( "<tab>" . gb/dired-toggle-expanding-single-dirs))
       ;; :after (dired all-the-icons vscode-icon)
       :config
       ;; make sure that long lines are truncated in sidebar
       (defun gb/dired-keep-cursor-during-tui-update (orig-fun &rest args)
         "execute dired omit expunge after dired sidebar tui update"
         (let ((old-point (point)))
           (apply orig-fun args)
           (dired-omit-expunge)
           (goto-char old-point)
           (global-hl-line-highlight)))

       (advice-add 'dired-sidebar-revert :around #'gb/dired-keep-cursor-during-tui-update)

       ;; (advice-add 'dired-sidebar-revert :after #'(lambda (&rest args) (message "TRACE: dired-sidebar-revert")))
       ;; (advice-remove 'dired-sidebar-tui-update #'gb/dired-keep-cursor-during-tui-update)

       (advice-add 'dired-sidebar-toggle-sidebar :after
                   #'(lambda (&rest args)
                       (when (and (dired-sidebar-showing-sidebar-p)
                                (eq (current-buffer) (dired-sidebar-buffer)))
                         (toggle-truncate-lines '(1))
                         (setq line-spacing 0))))

       (defun gb/dired-sidebar-follow-file ()
         "ensure sidebar is open and position cursor on file from which this function was called"
         (interactive)
         (if (and (dired-sidebar-showing-sidebar-p)
                  (string= (buffer-name) (buffer-name (dired-sidebar-buffer))))
             (dired-sidebar-hide-sidebar)
           (if (buffer-file-name)
               (unless (dired-sidebar-showing-sidebar-p)
                 (dired-sidebar-show-sidebar))
             (dired-sidebar-toggle-sidebar))
           (when (buffer-file-name)
             (let* ((filename (expand-file-name (buffer-file-name)))
                    (current-root (expand-file-name (replace-regexp-in-string "^:" "" (buffer-name (dired-sidebar-buffer))))))
               (select-window (get-buffer-window (dired-sidebar-buffer)))
               (if (s-starts-with? current-root filename)
                   (let* ((omitmode dired-omit-mode))
                     (dired-omit-mode -1) ;; make sure to switch off omit mode for cursor placement (since this is disrupted otherwise)
                     (dired-sidebar-point-at-file filename current-root)
                     (when omitmode (dired-omit-mode t))))))))
       (progn
         (setq truncate-partial-width-windows 20) ;; ensure that windows smaller than 20 truncate long lines
         (setq dired-sidebar-width (min 70 (/ (* 60 (frame-width)) (/ 1920 (default-font-width)))))
         (setq dired-sidebar-one-instance-p t) ;; ensure one instance of sidebar per frame
         (setq dired-sidebar-icon-scale (/ (* 0.2 (frame-width)) (/ 1920 (default-font-width)))) ;;
         (setq dired-sidebar-theme 'vscode)
         (setq dired-sidebar-follow-file-at-point-on-toggle-open t)
         (setq dired-sidebar-should-follow-file nil) ;; follow file in dired sidebar tree, put that on a hotkey
         (setq dired-sidebar-use-term-integration nil) ;; get workdir by dired root (direnv is called a bit too often)
         ))
   #+END_SRC
** dired-du (size calc in dired)
   #+BEGIN_SRC emacs-lisp
   (use-package dired-du
     :ensure t
     :config
     (setq dired-du-size-format t)
     (setq dired-du-on-find-dired-ok t))
   #+END_SRC
** dired ls (lisp emulation)
   #+BEGIN_SRC emacs-lisp
     ;; useful in environments where ls is not a native program (e.g. windows)
     ;; allows usage of dired and ls switches
     (unless gnu-ls-installed
       (use-package ls-lisp
         :config
         (progn
           (setq ls-lisp-use-insert-directory-program nil)
           (setq ls-lisp-ignore-case 't))))
   #+END_SRC
** dired quick sort
   #+BEGIN_SRC emacs-lisp
   (when gnu-ls-installed
     (use-package dired-quick-sort
       :after ( dired hydra)
       :config
       (dired-quick-sort-setup)))
   #+END_SRC
** dired sort
   #+BEGIN_SRC emacs-lisp
     ;; popup dialog from dired buffer to set (sort) switches of ls command
     (use-package dired-sort-menu
       :after ( dired ls-lisp)
       :commands dired-sort-dialog)
   #+END_SRC
** dired+
   - adds nice coloring to expanded view of dired (coloring date part etc.)
   #+BEGIN_SRC emacs-lisp
   ;; adds lots of functions all starting with diredp-
   (use-package dired+
     :load-path "~/.emacs.d/additionals/"
     :config (bind-key "s-!" 'diredp-async-shell-command-this-file dired-mode-map)
             (bind-key "C-p" 'diredp-previous-line dired-mode-map)

     )
   #+END_SRC
** dired rainbow
   #+BEGIN_SRC emacs-lisp
     (use-package dired-rainbow
       :ensure t
       :after ( dired)) ;; Extended file highlighting according to its type
   #+END_SRC
* stripe-buffer
  add stripes to background of dired (or any other mode)
  #+BEGIN_SRC emacs-lisp
    (when (locate-library "stripe-buffer")
      (use-package stripe-buffer
        :init (progn
                ;; (add-hook 'dired-mode-hook 'turn-on-stripe-buffer-mode)
                ;; (add-hook 'dired-mode-hook 'stripe-listify-buffer)
                )
        :config
        (cond
         ((eq gb/theme-mode 'light) nil) ;; TODO complete
         (t (progn
              (--each '((stripe-highlight ((t (:background "gray15")))))
                (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))
  #+END_SRC
* figlet (text->ascii art)
  - 'M-x figlet' to enter a text that is transformed into asci art
  - C-u will allow the selection of the font additionally
  #+BEGIN_SRC emacs-lisp
  (use-package figlet
    :commands figlet)
  #+END_SRC
* suggest
  execute "M-x suggest" opens suggest mode
  define input, expected output and it will provide an emacs-lisp function that does exactly that
  (e.g. input = "Hello", output = "hello", result = (downcase "Hello") ;=> "hello")
  #+BEGIN_SRC emacs-lisp
    (use-package suggest
      :commands suggest)
  #+END_SRC
* visual regexp
  #+BEGIN_SRC emacs-lisp
    (use-package visual-regexp
      :ensure t)
    (use-package visual-regexp-steroids
      :ensure t
      :after ( visual-regexp)
      :config
      (progn 
        ;; bind key is used within config section, since vr/... are functions of visual-regexp which
        ;; are adviced by visual-regexp-steroids. If used within :bind-key, this package is not loaded!!
        (bind-key "M-%" #' vr/query-replace)
        ;; ("C-c r" . vr/replace)
        ;; ("C-r" . vr/isearch-backward)
        ;; ("C-s" . vr/isearch-forward)
        (bind-key "C-c m" #'vr/mc-mark)
        (setq vr/default-regexp-modifiers (quote (:I t :M t :S nil :U nil)))))
  #+END_SRC
* lsp - language server protocol mode
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point language server protocol mode")
#+END_SRC
  #+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :commands lsp-mode
      :hook (scala-mode . lsp)
      :config (setq lsp-prefer-flymake nil))
  #+END_SRC
* nix specifics
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point nix specifics")
#+END_SRC
  - alternative to package ~direnv~ is ~envrc~, could be worth a try
  #+BEGIN_SRC emacs-lisp
    (use-package nixos-options
      :defer 30)
    (use-package company-nixos-options
      :after (company nixos-options cl-lib)
      :ensure t
      :config
      ;; overwrite function with patched version (to work with org-babel)
      (defun company-nixos--in-nix-context-p ()
        (or (eq major-mode 'nix-mode)
           (equal "nix" (file-name-extension
                         (or (buffer-file-name (current-buffer)) "")))))
      :init (add-to-list 'company-backends 'company-nixos-options))
    (use-package nix-mode)
    (use-package direnv
      :config
      (direnv-mode)
      (setq direnv-use-faces-in-summary nil)
      (advice-add 'direnv--export :before #'(lambda (orig-func &rest args) (message "running direnv ..."))))
  #+END_SRC
* currently evaluated
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point currently evaluated")
#+END_SRC
** github reviews with emacs
   #+begin_src emacs-lisp
   (use-package greview
     :load-path "~/.emacs.d/additionals/greview"
     :commands (greview-start-review))
   #+end_src
** switch buffer expose
   #+begin_src emacs-lisp
   (use-package buffer-expose
     :load-path "~/.emacs.d/additionals/buffer-expose/"
     :bind (( "s-e" . #'buffer-expose))
     :config (setq buffer-expose-show-current-buffer t))
   #+end_src
** switch buffers
   #+begin_src emacs-lisp
     (use-package nswbuff
       :commands (nswbuff-switch-to-next-buffer nswbuff-switch-to-previous-buffer)
       :ensure t
       :init
       (progn
         (defun gb/nswbuff-in-other-frame-p (orig-function &rest args)
           "check for buffer in other frames only if not the scratch buffer"
           (unless (string= (buffer-name (car args)) "*scratch*")
             (apply orig-function args)))
         (advice-add 'nswbuff-in-other-frame-p :around #'gb/nswbuff-in-other-frame-p))
       :config
       (progn
         (setq nswbuff-buffer-list-function nil)
         (setq nswbuff-status-window-at-top t)
         (setq nswbuff-exclude-buffer-regexps (quote ("^ " "^\\*helm")))
         (setq nswbuff-status-window-layout (quote adjust))
         (setq nswbuff-clear-delay 1.5)
         (cond
          ((eq gb/theme-mode 'light) nil) ;; TODO complete
          (t (progn
               (--each '((nswbuff-current-buffer-face ((t (:foreground "GoldenRod1" :weight bold))))
                         (nswbuff-separator-face ((t (:foreground "GoldenRod1"))))
                         (nswbuff-special-buffers-face ((t (:foreground "dim gray" :underline nil :weight normal)))))
                 (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))
       :bind (("s-<tab>" . nswbuff-switch-to-next-buffer)
              ("S-s-<iso-lefttab>" . nswbuff-switch-to-previous-buffer)))
   #+end_src
** terraform
   #+begin_src emacs-lisp
     (use-package terraform-mode
       :ensure t
       :config
       (when (fboundp #'dumb-jump-go)
         (add-to-list 'dumb-jump-find-rules
                      '(:type "resource" :supports ("ag" "grep" "rg" "git-grep")
                              :language "terraform"
                              :regex "^\\s*resource\\s+\".*\" \"JJJ\"\\j"
                              :tests ("resource \"aws_some\" \"name\" { }")))
         (add-to-list 'dumb-jump-find-rules
                      '(:type "variable" :supports ("ag" "grep" "rg" "git-grep")
                              :language "terraform"
                              :regex "^\\s*variable\\s+\"JJJ\"\\j"
                              :tests ("variable \"name\" { }")))
         (add-to-list 'dumb-jump-language-file-exts
                      '(:language "terraform" :ext "tf" :agtype "terraform" :rgtype nil))
         (add-to-list 'dumb-jump-language-comments
                      '(:comment "#" :language "terraform"))
         )
       (when (locate-file "terraform" exec-path)
         (defun gb/terraform-formatter-hook ()
           "format terraform files on save"
           (when (string= major-mode "terraform-mode")
             (shell-command (s-concat "pushd " (file-name-directory (buffer-file-name)) "&& terraform fmt && popd"))
             (message "autosave action formatting terraform files")))
         (add-hook 'after-save-hook #'gb/terraform-formatter-hook)))
     (use-package company-terraform
       :ensure t
       :after (company terraform-mode)
       :config (company-terraform-init))
     (use-package terraform-doc
       :ensure t
       :after (terraform-mode)
       :commands terraform-doc)
   #+end_src
** jest (javascript/typescript testing)
   - see https://jestjs.io/
   - bind the command 'jest-popup' (main command)
   #+BEGIN_SRC emacs-lisp
     (use-package jest
       :ensure t
       :commands (jest))
     (use-package flycheck-jest
       :ensure t
       :after (flycheck jest)
       :config (flycheck-jest-setup))
   #+END_SRC
** blimb (image manipulation using imagemagick)
   - lets you interactively select magick commands to manipulate the image in the buffer
   - it has command autocomplete, description and some parameter completion facilities
   - see [[https://github.com/walseb/blimp][homepage]]
   - in image view hit ~C-c C-o~ to open blimp interface of functions to execute on the image
   #+BEGIN_SRC emacs-lisp
     (use-package blimp
       :ensure t
       :hook (image-mode-hook . blimp-mode))
   #+END_SRC
** emms (emacs music system)
   #+BEGIN_SRC emacs-lisp
     (use-package emms
       :ensure t
       :commands (emms emms-browser)
       :config
       (require 'emms-setup)
       (emms-all)
       (emms-default-players)
       (setq emms-source-file-default-directory "~/music/")
       (setq emms-playlist-buffer-name "*Music*")
       (setq emms-info-asynchronously t)
       ;; (require 'emms-info-libtag) ;;; load functions that will talk to emms-print-metadata which in turn talks to libtag and gets metadata
       (setq emms-info-functions '(emms-info-mp3info)) ;;; make sure libtag is the only thing delivering metadata
       (require 'emms-mode-line)
       (emms-mode-line 1)
       (bind-key "<tab>" 'emms-browser-toggle-subitems emms-browser-mode-map)
       (require 'emms-playing-time)
       (emms-playing-time 1))
   #+END_SRC
** posframe
   - posframe allows floating frames to be displayed at point position
   - to update the local repo, rebase to upstream/master!
   - needed patching posframe.el:499
     #+begin_src emacs-lisp :tangle no
         (font-height (with-current-buffer (window-buffer parent-window)
                        (posframe--get-font-height position-info
                                                   ;; position
                                                   )))
     #+end_src
   #+BEGIN_SRC emacs-lisp
     (use-package posframe
       ;; :load-path "~/repo/posframe"
       :ensure t
       :init
       (defun gb/delete-all-open-posframes ()
         "Delete all open posframes"
         (interactive)
         (dolist (frame (frame-list))
           (let ((buffer-info (frame-parameter frame 'posframe-buffer)))
             (when buffer-info
               (posframe-delete-frame (car buffer-info))
               (message (format "delete %s" (car buffer-info))))))))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - posframe")
#+END_SRC
** flycheck-posframe (disabled)
   - display flycheck results in posframe (as floating frame at point position)
   - enable via 'flycheck-posframe-mode' (enabled by default)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flycheck-posframe
       :ensure t
       :after flycheck
       :hook (flycheck-mode . flycheck-posframe-mode)
       :config (flycheck-posframe-configure-pretty-defaults))
   #+END_SRC
** flycheck-package (elisp packages)
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-package
       :ensure t
       :after (flycheck))
   #+END_SRC
** ace helm line
   - display ace jump characters on each line (C-') when in helm mode
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package ace-jump-helm-line
         :after ( helm)
         :ensure t
         :bind (:map helm-map
                     ( "C-'" . ace-jump-helm-line))))
   #+END_SRC
** screen cast -> gif
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "gif-screencast")
     (use-package gif-screencast)) ;; one gif per user action
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - screen cast")
#+END_SRC
** async dired (execute several copy/zip etc. tasks asynchronously)
   - see [[https://vxlabs.com/2018/03/30/asynchronous-rsync-with-emacs-dired-and-tramp/][here]], [[https://truongtx.me/tmtxt-dired-async.html][here]] and [[https://truongtx.me/tmtxt-async-tasks.html][here]]
   - install elisp files
     git clone https://github.com/tmtxt/tmtxt-async-tasks.git
     git clone https://github.com/tmtxt/tmtxt-dired-async.git
   #+BEGIN_SRC emacs-lisp
   (when (and (file-exists-p "~/.emacs.d/additionals/tmtxt-async-tasks/tmtxt-async-tasks.el")
           (file-exists-p "~/.emacs.d/additionals/tmtxt-dired-async/tmtxt-dired-async.el"))
     (progn
       (use-package tmtxt-async-tasks
         :load-path "~/.emacs.d/additionals/tmtxt-async-tasks/")
       (use-package tmtxt-dired-async
         :after ( tmtxt-async-tasks dired)
         :load-path "~/.emacs.d/additionals/tmtxt-dired-async/"
         :bind (:map dired-mode-map
              ("C-c C-r" . tda/rsync)
              ("C-c C-z" . tda/zip)
              ("C-c C-u" . tda/unzip)
              ("C-c C-a" . tda/rsync-multiple-mark-file)
              ("C-c C-e" . tda/rysnc-multiple-empty-list)
              ("C-c C-d" . tda/rsync-multiple-remove-item)
              ("C-c C-v" . tda/rsync-multiple)
              ("C-c C-s" . tda/get-files-size)
              ("C-c C-q" . tda/download-to-current-dir)))))
   #+END_SRC
** info colors
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "info-colors")
     (use-package info-colors
       :init (add-hook 'Info-selection-hook 'info-colors-fontify-node)))
   #+END_SRC
** flycheck gradle
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck-gradle
     :after ( flycheck)
     :config (flycheck-gradle-setup))
   #+END_SRC
** cakecrumbs (show hierarchy in header for css and html)
   #+BEGIN_SRC emacs-lisp
     (use-package cakecrumbs
       :ensure t
       :commands (cakecrumbs-mode)
       :config
       ;; Specify all major-mode (`cakecrumbs' decide how to deal with
       ;; cursor's context by variable `major-mode'.)
       (setq cakecrumbs-html-major-modes   '(html-mode web-mode nxml-mode sgml-mode))
       (setq cakecrumbs-jade-major-modes   '(yajade-mode jade-mode pug-mode))
       (setq cakecrumbs-scss-major-modes   '(scss-mode less-css-mode css-mode))
       (setq cakecrumbs-stylus-major-modes '(stylus-mode sass-mode))  ; currently, sass-mode use the same rule with stylus-mode

       ;; Auto `add-hook' for above major-mode.  (Auto enable `cakecrumbs'
       ;; for the major-modes which have specify in above variables)
       ;; (cakecrumbs-auto-setup)

       ;; Set to number to refresh after idling N seconds.
       ;; Set to nil, refresh without any delay.
       (setq cakecrumbs-refresh-delay-seconds 0.1)

       ;; Appearances
       (setq cakecrumbs-separator " | ")
       (setq cakecrumbs-ellipsis "[...] ")

       ;; Ignore some patterns in selector string
       (setq cakecrumbs-ignored-patterns '(
                                           "[.]col-[a-z][a-z]-[0-9]+"  ; Bootstrap's .col-*
                                           ))
       )
   #+END_SRC
** auto-sudoedit
   - opens tramp sudo if file is readonly automatically (see [[https://github.com/ncaq/auto-sudoedit][here]])
   #+BEGIN_SRC emacs-lisp
     (use-package auto-sudoedit
       :ensure t
       :config (auto-sudoedit-mode 1))
   #+END_SRC
** eshell auto suggestion
   #+BEGIN_SRC emacs-lisp
   (use-package esh-autosuggest
     :ensure t
     :after ( company))
   #+END_SRC
** dimmer (deactivated, slowing things down)
   - dim non selected buffers (slightly)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package dimmer
       :ensure t
       :config (dimmer-activate)
       (setq dimmer-exclusion-regexp "\\*helm.*"))
   #+END_SRC
** eterm-256color - (disabled, installs lots of fonts that slow down frame creation, since each font is recalculated)
   - see [[http://github.com/dieggsy/eterm-256color][here]]
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package eterm-256color
     :ensure t
     :after ( xterm-color)
     :init (add-hook 'term-mode-hook #'eterm-256color-mode))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - eterm-256color")
#+END_SRC
** pcre2el (replace regular expression syntax with more readable one)
   - see here
   #+BEGIN_SRC emacs-lisp
   (use-package pcre2el
     :ensure pcre2el
     :config (pcre-mode 1))
   #+END_SRC
** helm-exwm (allow for helm based change of exwm buffers)
   - see [[https://github.com/emacs-helm/helm-exwm][here]], problems documented [[https://github.com/emacs-helm/helm/issues/1889][here]]
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-exwm
         :ensure t
         :after ( exwm helm)
         :config
         (progn
           (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
           (setq helm-exwm-source (helm-exwm-build-source))
           (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                             helm-exwm-source
                                             helm-source-recentf))
           )))
   #+END_SRC
** indent-info (deactivated)
   - allows for display of current indent settings in the mode line
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package indent-info
     :config (global-indent-info-mode 1))
   #+END_SRC
** lsp-javascript-typescript (deactivated, for now, collision with tide)
   - see [[https://github.com/emacs-lsp/lsp-javascript]]
   - install lsp-javascript-typescript with npm: npm i -g javascript-typescript-langserver
   - currently disabled, does not compose well with tide (check whether tide should be disabled)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package lsp-javascript-typescript
     :init
     (add-hook 'js-mode-hook #'lsp-javascript-typescript-enable)
     (add-hook 'typescript-mode-hook #'lsp-javascript-typescript-enable) ;; for typescript support
     (add-hook 'js3-mode-hook #'lsp-javascript-typescript-enable) ;; for js3-mode support
     (add-hook 'rjsx-mode #'lsp-javascript-typescript-enable) ;; for rjsx-mode support
     )
   #+END_SRC
** lsp-ui
   - emacs ui integration for lsp (like flycheck etc.)
   #+BEGIN_SRC emacs-lisp
     (when (locate-library "lsp-ui")
       (use-package lsp-ui
         :ensure t
         :hook (lsp-mode-hook . lsp-ui-mode)
         :custom
         (lsp-ui-doc-max-width 100)
         (lsp-ui-doc-position 'bottom)))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - lsp-ui")
#+END_SRC
** company lsp
   #+BEGIN_SRC emacs-lisp
   (use-package company-lsp
     :after ( company lsp-mode)
     :ensure t
     :config (push 'company-lsp company-backends))
   #+END_SRC
** iy-goto-char
   - C-c f <char> : goto the next occurrance of <char>. <char> can then be repeatedly pressed to move on to the next after that
     #+BEGIN_SRC emacs-lisp
       (use-package iy-go-to-char
         :bind (("C-c f" . iy-go-to-char)
                ("C-c F" . iy-go-to-char-backward))
         )
     #+END_SRC
** edit-at-point
   - edit(copy,cut..) current things(word,symbol..) under cursor
   #+BEGIN_SRC emacs-lisp
   (use-package edit-at-point)
   #+END_SRC
** eno, ace like copy, cut, past and move
   #+BEGIN_SRC emacs-lisp
     (use-package eno
       :after ( dash edit-at-point)
       :bind
         (("M-s-w j" . eno-word-goto) ;; Meta super w as leader key
          ("M-s-w c" . eno-word-copy)
          ("M-s-w t" . eno-word-cut)
          ("M-s-w p" . eno-word-paste)
          ("M-s-b j" . eno-symbol-goto)
          ("M-s-b c" . eno-symbol-copy)
          ("M-s-b t" . eno-symbol-cut)
          ("M-s-b p" . eno-symbol-paste)
          ("M-s-s j" . eno-str-goto)
          ("M-s-s c" . eno-str-copy)
          ("M-s-s t" . eno-str-cut)
          ("M-s-s p" . eno-str-paste)
          ("M-s-l j" . eno-line-goto)
          ("M-s-l c" . eno-line-copy)
          ("M-s-l t" . eno-line-cut)
          ("M-s-l p" . eno-line-paste)
          ("M-s-p j" . eno-paren-goto)
          ("M-s-p c" . eno-paren-copy)
          ("M-s-p t" . eno-paren-cut)
          ("M-s-p p" . eno-paren-paste)))
   #+END_SRC
** flycheck inline
   - display flycheck error messages inline (not as popup)
   - check whether this clashes with other flycheck packages (like flycheck-posframe)
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-inline
       :ensure t
       ;; :after ( flycheck inline-docs)
       :config
       (flycheck-inline-mode 1) ;; see readme
       )
   #+END_SRC
** flymd
   - opens firefox to display a live view of the markdown in the buffer.
     saving the buffer does automatically update the browser view of it!
   #+BEGIN_SRC emacs-lisp
     (if chromium-installed
         (use-package flymd
           :commands flymd-flyit
           :config
           ((progn )
            ;; make sure firefox is opened, since flymd-flyit does not work with chrome!
            (defun gb/flymd-browser-function (url)
              (let ((browse-url-browser-function 'browse-url-firefox))
                (browse-url url)))
            (setq flymd-browser-open-function 'gb/flymd-browser-function))))
   #+END_SRC
** helm google
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-google
         :commands helm-google helm-google-suggest
         :after ( helm))) ;; quick google searches, really ?
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - helm google")
#+END_SRC
** ivy swiper hydra
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'ivy)
       (use-package ivy-hydra
         :after ( hydra ivy))) ;; adds an hydra for ivy/swiper TODO: include into own hydras
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - ivy swiper hydra")
#+END_SRC
** ripgrep over directory trees
   #+BEGIN_SRC emacs-lisp
     (use-package ripgrep
       :commands ripgrep-regexp
       :bind (("C-c g r" . ripgrep-regexp))) ;; allow M-x ripgrep-regexp (search in directory + subdirectories)
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - rip grep")
#+END_SRC
** elisp refs (find references to elisp functions....)
   #+BEGIN_SRC emacs-lisp
   (use-package elisp-refs) ;; allow M-x elisp-refs-...
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - elisp efs")
#+END_SRC
** company bib tex
   #+BEGIN_SRC emacs-lisp
   (use-package company-bibtex
     :after ( company tex-mode)) ;; add bibtex references using company
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - bib tex")
#+END_SRC
** cider stuff
   #+BEGIN_SRC emacs-lisp
   ;; C-c C-t (hydra for test in cider)
   ;; C-c M-r (hydra for repl)
   ;; C-c M-t (test)
   ;; C-c C-d (hydra for documentation)
   ;; (use-package cider-hydra ;; adds hydras
   ;;   :ensure t
   ;;   :after ( hydra cider))
   (use-package cider-decompile ;; decompilation extension for cider [https://github.com/clojure-emacs/cider-decompile]
     :ensure t
     :after ( cider javap-mode))
   ;; (use-package cider-profile ;; CIDER profiling support [https://github.com/thunknyc/nrepl-profile]
   ;;   :defer 10
   ;;   :after ( cider)
   ;;   :init
   ;;   (progn
   ;;     (add-hook 'cider-mode-hook 'cider-profile-mode)
   ;;     (add-hook 'cider-repl-mode-hook 'cider-profile-mode)))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - cider stuff")
#+END_SRC
** window / frame tiling
   #+BEGIN_SRC emacs-lisp
   (use-package tile
     :commands tile tile-select tile-frames-horizontal tile-frames-vertically tile-frames-top-to-bottom tile-frames-side-by-side) ;; see [https://github.com/IvanMalison/tile], tiles windows into predefined setups
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - window / frame")
#+END_SRC
** bug hunter
   #+BEGIN_SRC emacs-lisp
   (use-package bug-hunter ;; allows via commands to hunt bugs in emacs lisp files see https://github.com/Malabarba/elisp-bug-hunter

     :commands bug-hunter-file bug-hunter-init-file)

   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - bug hunter")
#+END_SRC
** flycheck scala (deactivated, ensime provides all functionality needed here)
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; install flycheck for scala
   (use-package flycheck-scala-sbt
     :after ( ensime flycheck)
     ;; :defer t
     :init
     (progn
       (add-hook 'scala-mode-hook 'flycheck-scala-sbt-init)))

   ;; allow detection of language
   #+END_SRC
** natural language detection
   #+BEGIN_SRC emacs-lisp
   (use-package language-detection
     :commands language-detection-buffer)
   #+END_SRC
** butler (jenkins interface for emacs)
   #+BEGIN_SRC emacs-lisp
     (use-package butler
       :commands butler-status
       :config
       (progn
         ;; add server to the list
         ;; (add-to-list 'butler-server-list
         ;;          '(jenkins "SERVER-NAME"
         ;;                    (server-address . "https://jenkins-address")
         ;;                    (server-user . "user")
         ;;                    (server-password . "pass")))

         ;; add server with authfile
         ;; (add-to-list 'butler-server-list
         ;;              '(jenkins "SERVER-NAME"
         ;;                        (server-address . "https://jenkins-addres")
         ;;                        (auth-file . "~/.authinfo.gpg")))
         ;; The following line should exist in ~/.authinfo.gpg:
         ;; machine SERVER-NAME login USERNAME password PASSWORD
         ))
   #+END_SRC
** mode for unix tool pass
   #+BEGIN_SRC emacs-lisp
   (use-package passmm
     :commands passmm-list-passwords)
   #+END_SRC
** wolfram (currently disabled)
   - check [[https://github.com/hsjunnesson/wolfram.el][link]]
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package wolfram)
   #+END_SRC
** yaml
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode (("\\.?yml\\(\\.tpl\\)?\\'" . yaml-mode)
              ("\\.?yaml\\(\\.tpl\\)?\\'" . yaml-mode)))

     (use-package yaml-tomato
       :ensure t
       :after ( yaml-mode)
       :commands (yaml-tomato-show-current-path yaml-tomato-copy))
   #+END_SRC
** historian
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "historian")
    (use-package historian))
   #+END_SRC
** org-brain (disabled - now using notdeft)
   organize org files within org-brain-path into somthing like a mindmap / wiki that can be browsed
   check the [[https://github.com/Kungsgeten/org-brain][home page]]
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-brain
       :after ( org dash)
       :commands org-brain-open org-brain-visualize org-brain-insert-link
       :config
       (progn
         (setq org-brain-path "~/brain")
         (if (not (file-exists-p org-brain-path))
             (make-directory org-brain-path t))
         (when (eq gb/completion-framework 'helm)
           (defun helm-org-rifle-brain ()
             "Rifle files in `org-brain-path'."
             (interactive)
             (helm-org-rifle-directories (list org-brain-path))))))
   #+END_SRC
** org edit latex (edit latex code in separate buffer)
   - see [[https://github.com/et2010/org-edit-latex][here]]
   #+BEGIN_SRC emacs-lisp
   (use-package org-edit-latex
     ;; :after ( org tex-mode)
     ;; :defer 60
     )
   #+END_SRC
** helm books
   - allows searching for book titles using the google book api with helm
   #+BEGIN_SRC emacs-lisp
     (when (eq gb/completion-framework 'helm)
       (use-package helm-books
         :commands helm-books))
   #+END_SRC
** symbol-overlay
   - see [[https://github.com/wolray/symbol-overlay/][here]]
   - add some keylinks
   - allow highlighting of symbols
   #+BEGIN_SRC emacs-lisp
   (use-package symbol-overlay
     :ensure t
     :config (setq symbol-overlay-colors '("dodger blue" "spring green" "orchid" "salmon")))
   #+END_SRC
** smart hungry delete
   - possible replacement for hungry-delete
   - do smart delete of spaces
   #+BEGIN_SRC emacs-lisp
     (use-package smart-hungry-delete
       :ensure t
       :bind (("S-<backspace>" . smart-hungry-delete-backward-char)
   		      ("C-S-d" . smart-hungry-delete-forward-char)))
   #+END_SRC
** org recent headings
   - keep a list of lru org headings to choose from
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-recent-headings
       :after ( org)
       :config
       (when (eq gb/completion-framework 'helm)
         (bind-key "M-s-^" org-recent-headings-helm) ;; equivalent to M-s-i
         )
       (progn
         (org-recent-headings-mode)))
   #+END_SRC
** org sticky headers
   - keep last header of org in head line displayed if other wise scrolling out of view
   - problematic, sometimes org-sticky-header is empty
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package org-sticky-header
     :after ( org))
   #+END_SRC
** lsp with source-graph language servers
   #+BEGIN_SRC emacs-lisp
   ;; (use-package lsp-go :after ( lsp-mode))
   ;; (use-package lsp-haskell :after ( lsp-mode))
   (use-package lsp-java
     ;; :defer 10
     :ensure t
     :after ( lsp-mode))
   ;; (use-package lsp-python :after ( lsp-mode))
   ;; (use-package lsp-rust :after ( lsp-mode))
   #+END_SRC
** ledger (accounting manager)
   #+BEGIN_SRC emacs-lisp
     (when ledger-installed
       (use-package ledger-mode
         :ensure t)
       (use-package flycheck-ledger
         :ensure t
         :after ( ledger-mode flycheck)))
   #+END_SRC
** move frames around
   #+BEGIN_SRC emacs-lisp
     (defun move-frame-right-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame))))
                  (maxx (-  (display-pixel-width) 800)))
              (set-frame-position (selected-frame) (min (+ xpos 800) maxx) ypos)))

     (defun move-frame-left-800 () "move the selected frame by 800 pixel to the right"
            (interactive)
            (let ((xpos (car (frame-position (selected-frame))))
                  (ypos (cdr (frame-position (selected-frame)))))
              (set-frame-position (selected-frame) (max (- xpos 800) 0) ypos)))
   #+END_SRC
** json-navigator
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "json-navigator")
     (use-package json-navigator))
   #+END_SRC
** dired-collapse
   - collapse empty directories (like src/main/java... is done by github)
   #+BEGIN_SRC emacs-lisp
   (use-package dired-collapse
     :commands dired-collapse-mode)
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - dired-collapse")
#+END_SRC
** org-pomodoro (time management technique)
   - install libnotify (e.g. nix-env -iA nixos.libnotify)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-pomodoro
       :after ( appt)
       :commands org-pomodoro-clock-in
       :init (add-hook 'org-pomodoro-finished-hook 'gb/pomodoro-finished-notification)
       :config
       (progn
         (defun notify-osx (title message)
           (call-process "terminal-notifier"
                         nil 0 nil
                         "-group" "Emacs"
                         "-title" title
                         "-sender" "org.gnu.Emacs"
                         "-message" message))
         (defun gb/pomodoro-finished-notification ()
           "notify user about finished pomodoro"
           (if (is-macos-p)
               (notify-osx "Pomodoro completed" "Time for a short break")
             (message "Pomodoro completed, time for a short break") ;; notification for unix missing
             ))
         (setq org-pomodoro-play-sounds nil)
         ))
   #+END_SRC
** comint (shell extensions) (disabled)
   - see [[https://github.com/riscy/shx-for-emacs/blob/master/README.org][homepage]]
   - e.g. additional highlighting
   - given on the home page:
     - Display graphics and plots in the shell with a simple markup language (e.g., <view image.png>)
     - Add event-driven and timed behaviors to any shell session
     - Open any filename or URL by arrowing up to it and pressing <enter>
     - Yank any line to the prompt by arrowing up to it and pressing C-<enter>
     - Check the time a command was run by mousing over its prompt
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package shx
     :ensure t
     :init (progn
        ;; add hook for shell
        (add-hook 'shell-mode-hook #'shx-mode)
     )
     :config
        ;;(shx-global-mode 1) ;; global shx mode resulted in "text read only" error in ielm when pressing return
     )
   #+END_SRC
** comint settings
   #+begin_src emacs-lisp
     (cond
      ((eq gb/theme-mode 'light) nil) ;; TODO complete
      (t (progn
           (--each '( (comint-highlight-prompt ((t (:foreground "peru")))))
             (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
     (setq comint-input-ring-file-name "~/.comint_hist")
     (setq comint-input-ring-size 8192)
   #+end_src
** ob-rust
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package ob-rust
     :after( org))
   #+END_SRC
** underline with char
   - call with prefix command let's you select with which char to underline
   - underlines previous line up to its end with '-'
   #+BEGIN_SRC emacs-lisp
     (use-package underline-with-char
       :commands underline-with-char)
   #+END_SRC
** yarn mode
   - open yarn lock files in a read only mode
   #+BEGIN_SRC emacs-lisp
   (use-package yarn-mode
     :ensure t
     :mode (("\\yarn.lock\\'" . yarn-mode)))
   #+END_SRC
** all the icons dired
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-dired
       :ensure t
       :after ( all-the-icons dired)
       :bind (:map dired-mode-map
                   ("C-x t t" . #'all-the-icons-dired-mode)))
   #+END_SRC
** all the icons gnus
   - on hold, icons disturb custom ui settings of gnu
   - [ ] test this package with gnus ui customizations off
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package all-the-icons-gnus
     :after ( gnus all-the-icons dash)
     :config (all-the-icons-gnus-setup))
   #+END_SRC
** docker compose mode
   #+BEGIN_SRC emacs-lisp
   (when (locate-library "docker-compose-mode")
     (use-package docker-compose-mode))
   #+END_SRC
** comint (bifocal)
   - will automatically split a comint buffer, if scrolling into the history (by bifocal-up, down, next, prev)
     this will enable you to view current comint output (or just keep the input line) while looking at the history of the buffer
   #+BEGIN_SRC emacs-lisp
   (use-package bifocal
     :commands bifocal-mode)
   #+END_SRC
** popwin (make windows like help, completion show in a popupwindow that can be closed via C-g
   #+BEGIN_SRC emacs-lisp
     (use-package popwin
       :ensure t
       :config
       (popwin-mode 1)
       (setq popwin:popup-window-height 30))
   #+END_SRC
** neotree (deactivated)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package neotree
       :config
         (progn
         (setq neo-theme (if (display-graphic-p) 'nerd 'arrow))
         (setq neo-window-width 35)
         (setq neo-banner-face '((t (:foreground "DarkGoldenrod3" :weight bold))))
         (setq neo-dir-link-face '((t (:foreground "DarkOrange1"))))
         (setq neo-expand-btn-face '((t (:foreground "DarkOrange1"))))
         (setq neo-file-link-face '((t (:foreground "burlywood1"))))
         (setq neo-smart-open t)
         (setq projectile-switch-project-action 'neotree-projectile-action)))
   #+END_SRC
* general (key binding)
  #+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t)
  #+END_SRC
* kubernetes
  #+begin_src emacs-lisp
    (use-package k8s-mode
      :ensure t
      :hook (k8s-mode . yas-minor-mode)
      :config
      ;; Set indent offset
      (setq k8s-indent-offset nil)

      ;; The site docs URL
      (setq k8s-site-docs-url "https://kubernetes.io/docs/reference/generated/kubernetes-api/")

      ;; The defautl API version
      (setq k8s-site-docs-version "v1.13")

      ;; The browser funtion to browse the docs site. Default is `browse-url-browser-function`
      ;; (setq k8s-search-documentation-browser-function nil)
      (setq k8s-search-documentation-browser-function (quote browse-url-firefox))
      )
    (use-package kubernetes
      :ensure t
      :commands (kubernetes-overview))
    (when (eq gb/completion-framework 'helm)
      (use-package kubernetes-helm
        :commands (kubernetes-helm-dep-up kubernetes-helm-install kubernetes-helm-upgrade kubernetes-helm-values kubernetes-helm-status kubernetes-helm-template)
        :ensure t))
  #+end_src
  - use C-x C-f /kubectl:container:/path/to/file
  #+begin_src emacs-lisp
  (use-package kubernetes-tramp
    :ensure t)
  #+end_src
* vue (disabled)
  #+begin_src emacs-lisp :tangle no
  (use-package vue-html-mode
    :ensure t)
  (use-package vue-mode
    :ensure t)
  #+end_src
* racket
  #+begin_src emacs-lisp
    (use-package racket-mode
      :ensure t
      :bind (:map racket-mode-map
                  ("C-c r" . #'racket-run)
                  ("C-c C-." . #'racket-repl-describe)
                  ("M-." . #'racket-repl-visit-definition))
      :config
      (when (boundp 'pretty-modes-aliases)
        (add-to-list 'pretty-modes-aliases '(racket-mode . scheme-mode)))
      (add-hook 'racket-mode-hook 'racket-xp-mode)
      (when (fboundp 'paredit-mode)
        (add-hook 'racket-mode-hook 'paredit-mode)
        (add-hook 'racket-repl-mode-hook 'paredit-mode))
      (when (boundp 'prettify-greek-upper)
        (add-hook 'racket-mode-hook
                  (lambda ()
                    (setq prettify-symbols-alist prettify-greek-lower)
                    (prettify-symbols-mode t)
                    (pretty-mode 1))))
      (when (fboundp 'gb/enable-ligatures)
        (add-hook 'racket-mode-hook
                  (lambda () (gb/enable-ligatures))))
      (setq racket-show-functions '(racket-show-echo-area))

      (when (fboundp #'yafolding-mode)
        (defun gb/racket-fold-all-tests ()
          (interactive)
          (racket--for-all-tests "Folded" 'yafolding-hide-element))

        (defun gb/racket-unfold-all-tests ()
          (interactive)
          (racket--for-all-tests "Unfolded" 'yafolding-show-element))

        (bind-key "C-c C-f" #'gb/racket-fold-all-tests racket-mode-map)
        (bind-key "C-c C-u" #'gb/racket-unfold-all-tests racket-mode-map)))

    (use-package flymake-racket
      :after racket-mode
      :ensure t
      :config (flymake-racket-setup))

    (use-package scribble-mode ;; documentation files
      :after racket-mode
      :ensure t
      :init
      (add-hook 'scribble-mode-hook #'racket-mode))

    (use-package ob-racket
      :load-path "~/.emacs.d/additionals/ob-racket/"
      :after org
      :config
      (add-to-list 'org-babel-load-languages '(racket . t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
  #+end_src
* shell-pop
  #+begin_src emacs-lisp
  (use-package shell-pop
    :config
    (defun gb/shell-pop-new ()
      (interactive)
      (let ((current-prefix-arg '(4))) ;; emulate C-u
        (call-interactively 'shell-pop)))
    :bind (("C-c C-h" . gb/shell-pop-new)))
  #+end_src
* restclient
  - provide a mode that allows for rest calls and result presentation
    simply paste the following text into a buffer and activate restclient-mode
        :basicauth := (base64-encode-string "******:****")
        :auth-header = AUTHORIZATION: Basic :basicauth

        GET https://api.k8s.dev....de/api/v1/namespaces/default/pods?limit=500
        ACCEPT: application/json;as=Table;v=v1beta1;g=meta.k8s.io, application/json
        USER-AGENT: kubectl/v1.14.0 (linux/amd64) kubernetes/641856d
        :auth-header

  #+begin_src emacs-lisp :tangle no
    (use-package restclient
      :ensure t)
    (use-package ob-restclient
      :ensure t
      :config (add-to-list 'org-babel-load-languages '(restclient . t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    (use-package company-restclient
      :after company
      :ensure t
      :config (add-to-list 'company-backends 'company-restclient))
    (when (eq gb/completion-framework 'helm)
      (use-package restclient-helm
        :ensure t))
    (use-package restclient-test
      :ensure t)
  #+end_src
* exwm (emacs window manager)
  #+BEGIN_SRC emacs-lisp
    (report-elapsed "check point exwm")
  #+END_SRC
  - C-q <next key>: results in next key being send to the x-application unmodified
  - infos
    - eclipse usage
      - since eclipse is configured to use emacs key bindings they may collide with exwm and emacs native keybindings.  Thus it makes more
        sense to use eclipse in key mode (TODO: automatically switch to key mode when in eclipse).  However, if in key mode, buffer
        switching via C-x C-b is not available. To switch back to line mode use s-r (which resets exwm for this application).
  - [[https://github.com/ch11ng/exwm/wiki/Configuration-example][example configuration]]
  - desktop functions
    - audio functions
       #+begin_src emacs-lisp
         (defun gb/audio-outputs-available ()
           "read available audio outputs"
           (split-string (s-trim (shell-command-to-string "pactl list short sinks | grep 'alsa_output' | awk '{ print $2 }'")) "\n"))

         (defun gb/audio-inputs-available ()
           "read available audio inputs"
           (split-string (s-trim (shell-command-to-string "pactl list short sources | grep 'alsa_input' | awk '{ print $2 }'")) "\n"))

         (defun gb/audio-output-selected ()
           "get the current audio output selected"
           (s-trim (shell-command-to-string  "pactl info | grep -e \"^Default Sink:\" | awk '{ print $3 }'")))

         (defun gb/audio-input-selected ()
           "get the current audio input selected"
           (s-trim (shell-command-to-string  "pactl info | grep -e \"^Default Source:\" | awk '{ print $3 }'")))

         (defun gb/audio-auto-select-sink ()
           "automatically select usb device, else pci device"
           (interactive)
           (let* ((usb-device (s-trim (shell-command-to-string "pactl list short sinks | grep -i usb- | cut -f2")))
                  (built-in (s-trim (shell-command-to-string "pactl list short sinks | grep -i pci- | cut -f2"))))
             (shell-command-to-string (format "pactl set-default-sink %s"
                                              (if (seq-empty-p usb-device)
                                                  built-in
                                                usb-device)))))

         (defcustom gb/sound-theme-base-dir "~/sound" "base dir for sound files" :group 'gb/sound-theme :type 'string)
         (defcustom gb/sound-theme-effect-volume "clack" "sound file to be used on volume change" :group 'gb/sound-theme :type 'string)
         (defcustom gb/sound-theme-effect-switch-workspace "zing" "sound file to be used " :group 'gb/sound-theme :type 'string)
         (defcustom gb/sound-theme-volume "-v 0.8" "volume parameter for sound player to play sounds with" :group 'gb/sound-theme :type 'string)
         (defcustom gb/sound-theme-player "play" "player to be used for playing sound files" :group 'gb/sound-theme :type 'string)

         (defcustom gb/sound-theme-muted nil "whether to mute sounds" :group 'gb/sound-theme :type 'boolean)

         (defun gb/play-theme-sound (sound)
           "play sound from theme"
           (unless gb/sound-theme-muted
             (start-process-shell-command "play-sound-theme" nil (format "%s %s %s/%s.wav" gb/sound-theme-player gb/sound-theme-volume gb/sound-theme-base-dir sound))))

         (defun gb/audio-volume-set (precent)
           "set volume to PERCENT%"
           (with-ignored-messages
            (let ((output-selected (gb/audio-output-selected)))
              (shell-command (format "pactl set-sink-volume %s 100%%" output-selected))
              (while-no-input
                (gb/play-theme-sound gb/sound-theme-effect-volume)
                (gb/dunst-report-volume output-selected)))))

         (defun gb/audio-lower-volume ()
           "lower volume by 5%"
           (interactive)
           (with-ignored-messages
            (let ((output-selected (gb/audio-output-selected)))
              (shell-command (format "pactl set-sink-volume %s -5%%" output-selected))
              (while-no-input
                (gb/play-theme-sound gb/sound-theme-effect-volume)
                (gb/dunst-report-volume output-selected)))))

         (defun gb/dunst-report-volume (element)
           (let ((volume (gb/get-volume element))
                 (volume-state (gb/get-volume-state element))
                 (element-str (replace-regexp-in-string "\\(alsa_output.\\|.analog-stereo\\|-00\\)" "" element)))
             (if (s-equals? "on" volume-state)
                 (shell-command (format "dunstify -a \"changeVolume\" -u low -i audio-volume-high -r \"991049\" \"Volume: %i%%\n%s\" \"$(getProcessingString 20 '' '' %i)\"" volume element-str volume))
               (shell-command (format "dunstify -a \"changeVolume\" -u low -i audio-volume-muted -r \"991049\" \"Volume muted\n%s\"" element-str)))))

         (defun gb/get-volume (element)
           "get current volume as number"
           (string-to-number
            (s-replace "%" "" (s-trim (shell-command-to-string (format "pactl list sinks | grep -A 9 \"Name: %s\" | grep -e \"^[[:space:]]*Volume:\" | awk '{ print $5 \" / \" $12 }'" element))))))

         (defun gb/get-volume-state (element)
           "return 'on' (regular) or 'off' (muted)"
           (s-trim (shell-command-to-string "amixer get Master | tail -1 | awk '{print $6}' | sed 's/[^a-z]*//g'")))

         (defun gb/audio-raise-volume ()
           "raise volume by 5%"
           (interactive)
           (with-ignored-messages
            (let ((output-selected (gb/audio-output-selected)))
              (when (> 130 (gb/get-volume output-selected))
                (shell-command (format "pactl set-sink-volume %s +5%%" output-selected))
                (while-no-input
                  (gb/play-theme-sound gb/sound-theme-effect-volume)
                  (gb/dunst-report-volume output-selected))))))

         (defun gb/audio-mute-volume ()
           "mute volume master"
           (interactive)
           (let ((output-selected (gb/audio-output-selected)))
             (shell-command "amixer sset Master toggle")
             (gb/dunst-report-volume output-selected)))

         (defun gb/audio-mute-mic ()
           "mute volume microphone"
           (interactive)
           (shell-command "amixer sset Capture toggle"))

         (defun gb/audio-output-set (sink-name)
           (shell-command-to-string (format "pactl set-default-sink %s" sink-name)))

         (defun gb/audio-output-set-builtin ()
           (gb/audio-output-set (car (--filter (s-matches? "pci.*analog-stereo" it) (gb/audio-outputs-available)))))

         (defun gb/audio-output-select ()
           "select audio output "
           (interactive)
           (let ((sink-name (completing-read "audio-output:" (gb/audio-outputs-available) nil t)))
             (gb/audio-output-set sink-name)
             (message (format "output: %s" (gb/audio-output-selected)))))

         (defun gb/audio-input-select ()
           "select audio input"
           (interactive)
           (let ((source-name (completing-read "audio-input:" (gb/audio-inputs-available) nil t)))
             (shell-command-to-string (format "pactl set-default-source %s" source-name))
             (message (format "input: %s" (gb/audio-input-selected)))))

         (defun gb/audio-restart-server ()
           "restart audio server"
           (interactive)
           (shell-command-to-string "pulseaudio --check && pulseaudio -k")
           (async-shell-command "pulseaudio" nil nil)
           (message "audio server (re)started ..."))
       #+end_src
    - brightness functions
       #+begin_src emacs-lisp
         (defun gb/brightness-up ()
           "increase monitor 0 brightness by 10%"
           (interactive)
           (with-ignored-messages
            (shell-command "xbacklight -inc 10")
            (while-no-input
              (let ((brightness (s-trim (shell-command-to-string "xbacklight -get"))))
                (shell-command (format "dunstify -a \"changeBrightness\" -u low -i brightness-high -r \"991048\" \"Brightness: %s%%\" \"$(getProcessingString 20 '' '' %s)\"" brightness brightness))))))

         (defun gb/brightness-set (percent)
           "set brightness of monior 0 to PERCENT"
           (shell-command (format "xbacklight -set %i" percent))
           (let ((brightness (s-trim (shell-command-to-string "xbacklight -get"))))
             (message (s-concat "brightness set, now: " brightness " %%"))))
         (gb/brightness-set 50);; set brightness to 50% on startup

         (defun gb/brightness-down ()
           "decrease monitor 0 brightness by 10%"
           (interactive)
           (with-ignored-messages
            (shell-command "xbacklight -dec 10")
            (while-no-input
              (let ((brightness (s-trim (shell-command-to-string "xbacklight -get"))))
                (shell-command (format "dunstify -a \"changeBrightness\" -u low -i brightness-high -r \"991048\" \"Brightness: %s%%\" \"$(getProcessingString 20 '' '' %s)\"" brightness brightness))))))
       #+end_src
    - lock, screen saver, compositor
       #+begin_src emacs-lisp
         (defun gb/netflix ()
           (interactive)
           (gb/compositor-enable)
           (gb/brightness-set 100)
           (gb/cpu-freq-limit)
           (gb/audio-volume-set 100)
           (browse-url-chrome "https://www.netflix.com"))

         (defun gb/compositor-enable ()
           "run compton compositor if not already running"
           (interactive)
           (unless (string-equal "running" (s-trim (shell-command-to-string "pgrep compton && echo 'running'")))
             (async-start-process "compton" "compton" nil)))

         (defun gb/compositor-disable ()
           "kill compton compositor if already running"
           (interactive)
           (shell-command-to-string "pkill compton"))

         (defun gb/dunst-notify-disable ()
           "disable dunst desktop notification (temporarily)"
           (interactive)
           (shell-command "notify-send \"DUNST_COMMAND_PAUSE\""))

         (defun gb/dunst-notify-enable ()
           "(re)enable dunst desktop notification"
           (interactive)
           (shell-command "notify-send \"DUNST_COMMAND_RESUME\""))

         (defun gb/lock-screen ()
           "lock screen"
           (interactive)
           (when (gb/upower--on-battery)
             (gb/brightness-set 0))
           (gb/dunst-notify-disable)
           (shell-command "xset s activate"))

         (defun gb/screensaver-enable ()
           "enable screen saver"
           (interactive)
           (shell-command "xset s default")
           (shell-command "xset s on")
           (shell-command "xset +dpms")
           (message "enabled screensaver"))

         (defun gb/screensaver-disable ()
           "enable screen saver"
           (interactive)
           (shell-command "xset s noblank")
           (shell-command "xset s off")
           (shell-command "xset -dpms")
           (message "disabled screensaver"))

         (defun gb/hibernate-laptop ()
           "put laptop into hibernation (complete off, store memory onto disc)"
           (interactive)
           (shell-command-to-string "sudo systemctl stop bluetooth.service") ;; just to make sure
           (if (not (string-empty-p (shell-command-to-string "pgrep duplicity")))
               (message "Running duplicity (backup), hibernate aborted.")
             (shell-command-to-string "xfce4-power-manager") ;; make sure the power manager is running
             (shell-command-to-string "systemctl hibernate")))

         (defun gb/upower--on-battery ()
           (string= "yes" (s-trim (shell-command-to-string "upower -d | grep \"on-battery\" | tr -s \" \" | cut -f3 -d' '"))))

         (defun gb/suspend-laptop ()
           "put laptop into suspension (soft off, still uses power to keep memory up to date)"
           (interactive)
           (shell-command-to-string "sudo systemctl stop bluetooth.service") ;; just to make sure
           (if (not (string-empty-p (shell-command-to-string "pgrep duplicity")))
               (message "Running duplicity (backup), suspend aborted.")
             (when (gnus-buffers)
               (message "exiting gnus")
               (let ((old-gie gnus-interactive-exit))
                 (setq gnus-interactive-exit nil)
                 (gnus-group-exit)
                 (setq gnus-interactive-exit old-gie)))
             (shell-command-to-string "xfce4-power-manager") ;; make sure the power manager is running
             ;; if suspend does not work try switching off bluetooth service
             (shell-command-to-string "systemctl suspend")))

         (defun gb/reboot--immediately ()
           "immediately execute reboot, without running hooks nor asking questions"
           (shell-command "reboot"))

         (defun gb/reboot ()
           "reboot pc"
           (interactive)
           (when (yes-or-no-p "Reboot PC?")
             (if (not (string-empty-p (shell-command-to-string "pgrep duplicity")))
                 (message "Running duplicity (backup), reboot aborted.")
               (progn
                 (add-hook 'kill-emacs-hook #'gb/reboot--immediately t)
                 (save-buffers-kill-emacs)))))

         (defun gb/reset-direnv ()
           "restart direnv mode, restart tide server and bash-completion"
           (interactive)
           (direnv-mode nil)
           (direnv-mode 1)
           (if (get-buffer "*tide-server*")
               (tide-restart-server))
           (bash-completion-reset))

         (defun gb/shutdown--immediately ()
           "immediately execute shutdown, without running hooks nor asking questions"
           (shell-command "shutdown -h now"))

         (defun gb/shutdown ()
           "reboot pc"
           (interactive)
           (when (yes-or-no-p "Shutdown PC?")
             (progn
               (if (not (string-empty-p (shell-command-to-string "pgrep duplicity")))
                   (message "Running duplicity (backup), shutdown aborted.")
                 (add-hook 'kill-emacs-hook #'gb/shutdown--immediately t)
                 (save-buffers-kill-emacs)))))

         (defun gb/start-if-not-running (filename)
           "start this program if not already running"
           (let* ((program (file-name-base filename))
                  (is-executable (file-executable-p filename))
                  (is-running (not (string-empty-p (shell-command-to-string (concat "ps -A | grep " program))))))
             (cond ((and is-executable is-running) (message (format "OK: %s already running." program)))
                   (is-executable (progn (message (format "OK: starting %s." program))
                                         (start-process-shell-command filename nil)))
                   (t (message (format "WARNING: program %s could not be run." filename))))
             ))

       #+end_src
    - monitor output functions
       #+begin_src emacs-lisp
         (defun gb/get-second-monitor ()
           "get the second monitor if connected"
           (s-trim (shell-command-to-string "xrandr | grep -v disconnected | grep connected | grep -v primary | awk '{ print $1 }'")))

         (when (fboundp 'memoize)
           (memoize #'gb/get-second-monitor 10))

         (defun gb/get-primary-monitor ()
           "get the primary monitor if connected"
           (s-trim (shell-command-to-string "xrandr | grep -v disconnected | grep connected | grep primary | awk '{ print $1 }'")))

         (when (fboundp 'memoize)
           (memoize #'gb/get-primary-monitor 10))

         (defun gb/reset-primary-monitor ()
           "get the primary monitor if connected"
           (interactive)
           (s-trim (shell-command-to-string (format "xrandr --output %s --auto" (gb/exwm--get-primary-monitor)))))
       #+end_src
    - additional window functions
       #+begin_src emacs-lisp
         (defun gb/remove-upper-window ()
           ""
           (interactive)
           (if-let (upper-window (windmove-find-other-window 'up))
               (delete-window upper-window)))

         (defun gb/remove-lower-window ()
           ""
           (interactive)
           (if-let (lower-window (windmove-find-other-window 'down))
               (delete-window lower-window)))

         (defun gb/remove-left-window ()
           ""
           (interactive)
           (if-let (left-window (windmove-find-other-window 'left))
               (let ((width (window-total-width left-window)))
                 (delete-window left-window)
                 (when (not (frame-root-window-p (get-buffer-window)))
                   (window-resize (get-buffer-window) width t)))))

         (defun gb/remove-right-window ()
           ""
           (interactive)
           (if-let (right-window (windmove-find-other-window 'right))
               (delete-window right-window)))


       #+end_src
    - cpu frequency
      #+begin_src emacs-lisp
        (defun gb/cpu-freq-max-get ()
          (string-to-number (s-trim (shell-command-to-string "cat /sys/devices/system/cpu/cpufreq/policy0/cpuinfo_max_freq"))))

        (defun gb/cpu-freq-min-get ()
          (string-to-number (s-trim (shell-command-to-string "cat /sys/devices/system/cpu/cpufreq/policy0/cpuinfo_min_freq"))))


        (defun gb/cpu-freq-lowest ()
          "set cpu frequency to 800MHz limit, to prevent cpu fan"
          (interactive)
          (let ((cpu-freq 800000))
            (if (and (<= cpu-freq (gb/cpu-freq-max-get))
                     (>= cpu-freq (gb/cpu-freq-min-get)))
                (s-trim (shell-command-to-string "cpu-freq-set.sh 800000"))
              (message (format "ERROR: requested freq (%i) is not within cpu limits" cpu-freq)))))

        (defun gb/cpu-freq-limit ()
          "set cpu frequency to 1.2GHz limit, to prevent cpu fan"
          (interactive)
          (let ((cpu-freq 1600000))
            (if (and (<= cpu-freq (gb/cpu-freq-max-get))
                     (>= cpu-freq (gb/cpu-freq-min-get)))
                (s-trim (shell-command-to-string "cpu-freq-set.sh 1600000"))
              (message (format "ERROR: requested freq (%i) is not within cpu limits" cpu-freq)))))

        (defun gb/cpu-freq-unlimit ()
          "set cpu freq to unlimited, (which is the max capable)"
          (interactive)
          (shell-command-to-string (format "cpu-freq-set.sh %i" (gb/cpu-freq-max-get))))
      #+end_src

  - exwm configuration
    #+BEGIN_SRC emacs-lisp
      (when gb/use-exwm
        (use-package xelb
          :after (ace-window windmove)
          :ensure t))
    #+END_SRC
  - exwm
    #+BEGIN_SRC emacs-lisp
      (when gb/use-exwm
        (use-package exwm
          :after (xelb)
          :bind (("<XF86MonBrightnessUp>" . gb/brightness-up)
                 ("<XF86MonBrightnessDown>" . gb/brightness-down)
                 ("<XF86AudioLowerVolume>" . gb/audio-lower-volume)
                 ("<XF86AudioRaiseVolume>" . gb/audio-raise-volume)
                 ("<XF86AudioMute>" . gb/audio-mute-volume)
                 ("<XF86AudioMicMute>" . gb/audio-mute-mic)
                 ("<s-f6>" . gb/brightness-up)
                 ("<s-f5>" . gb/brightness-down)
                 ("<s-f2>" . gb/audio-lower-volume)
                 ("<s-f3>" . gb/audio-raise-volume)
                 ("<s-f4>" . gb/audio-mute-mic)
                 ("<s-f1>" . gb/audio-mute-volume))
          :config
          (setq exwm-floating-border-color "#403040")
          (setq exwm-floating-border-width 2)
          :init (progn
                  (defun gb/exwm-visualize-workspace-switch (newidx length display-width)
                    "visualize the switched to workspace by a foreground ascii art"
                    (interactive)
                    (let* (
                           (spaces-before newidx)
                           (spaces-after (- length newidx 1))
                           (separator-top (s-concat "" (s-join "" (-repeat display-width "")) ""))
                           (separator (s-concat "" (s-join "" (-repeat display-width "")) ""))
                           (separator-bottom (s-concat "" (s-join "" (-repeat display-width "")) ""))
                           (empty-space (s-concat "" (s-join "" (-repeat display-width " ")) ""))
                           (new-space (s-concat "" (s-join "" (-repeat display-width "")) ""))
                           (top-filled )
                           (display (s-concat separator-top "\n" (s-join (s-concat "\n" separator "\n") (append (-repeat spaces-before empty-space) `(,new-space) (-repeat spaces-after empty-space))) "\n" separator-bottom))
                           (my-posframe-buffer " *my-posframe-buffer*"))

                      (with-current-buffer (get-buffer-create my-posframe-buffer)
                        (erase-buffer)
                        (setq line-spacing 0)
                        (insert display))
                      (setq switch-posframe-parameters
                            `((parent-frame . ,(window-frame))                                        ;; (works only on single monitor)
                              (display . ,(cdr (assoc 'display (frame-parameters (selected-frame))))) ;; (hopefully holds display of current monitor)
                              (font . ,(cdr (assoc 'font (frame-parameters (selected-frame)))))
                              (alpha 0.3 0.3)
                              ;; (left-fringe . 10)
                              ;; (right-fringe . 10)
                              ))

                      (posframe-hide my-posframe-buffer)
                      (posframe-show my-posframe-buffer
                                     :string display
                                     ;; :override-parameters switch-posframe-parameters
                                     :poshandler 'posframe-poshandler-frame-center
                                     :foreground-color "gray30"
                                     :timeout 2)
                      ;; (posframe-show " *inpos-posframe-buffer"
                      ;;                :string (s-concat "monitor workspace [" (number-to-string newidx) "]")
                      ;;                :position (point)
                      ;;                :timeout 1
                      ;;                :background-color "dark orange"
                      ;;                :foreground-color "black")
                      ;; (start-process-shell-command " *play sound*" nil "mpg123 ~/Downloads/typewriter-line-break-1.mp3")
                      ))

                  (defvar gb/exwm--previous-workspace 1 "workspace index before going left")

                  (defun gb/exwm-workspace-switch (index &optional force previousIdx)
                    "remember workspace index when switching to 0 (left, laptop monitor)"
                    (let ((actualPrevIdx (or previousIdx (exwm-workspace--position exwm-workspace--current))))
                      (when ( and (= index 0) (> actualPrevIdx 0))
                        (setq gb/exwm--previous-workspace actualPrevIdx))
                      (exwm-workspace-switch index force)))

                  (defun gb/exwm-workspace-left ()
                    "jump to workspace left of the current one (multi monitor)"
                    ;; if on multimonitor, check if there is one left of this
                    (interactive)
                    (let* ((workspaceIdx (exwm-workspace--position exwm-workspace--current))
                           (monitor (nth (+ 1 (* 2 workspaceIdx)) exwm-randr-workspace-monitor-plist)))
                      (if (or (s-equals? (gb/get-primary-monitor) monitor)
                             (string-empty-p (gb/get-second-monitor)))
                          (progn (message "no workspace left of this.") (beacon-blink) nil)
                        (gb/exwm-workspace-switch 0 t workspaceIdx)
                        (gb/play-theme-sound gb/sound-theme-effect-switch-workspace)
                        (message (format "<<     now %s" (exwm-workspace--position exwm-workspace--current)))
                        ;; (x-focus-frame (selected-frame))
                        (doom-modeline-set-selected-window)
                        t)))

                  (defun gb/exwm-workspace-right ()
                    "jump to workspace right of the current one (multi monitor)"
                    ;; if on multimonitor, check if there is one left of this
                    (interactive)
                    (let* ((workspaceIdx (exwm-workspace--position exwm-workspace--current))
                           (monitor (nth (+ 1 (* 2 workspaceIdx)) exwm-randr-workspace-monitor-plist)))
                      (if (and (s-equals? (gb/get-primary-monitor) monitor)
                             (not (string-empty-p (gb/get-second-monitor))))
                          (progn ;; (setq gb/exwm--previous-workspace workspaceIdx)
                            (exwm-workspace-switch gb/exwm--previous-workspace t)
                            (gb/play-theme-sound gb/sound-theme-effect-switch-workspace)
                            (message (format ">>     now %s" (exwm-workspace--position exwm-workspace--current)))
                            ;; (x-focus-frame (selected-frame))
                            (doom-modeline-set-selected-window)
                            t)
                        (message "no workspace right of this.")
                        (beacon-blink)
                        nil)))

                  (defun gb/exwm-workspace-down ()
                    "jump to workspace down of the current one (multi monitor)"
                    (interactive)
                    (let* ((workspaceIdx (exwm-workspace--position exwm-workspace--current))
                           (monitor (nth (+ 1 (* 2 workspaceIdx)) exwm-randr-workspace-monitor-plist))
                           (lastIndex (- (length exwm-workspace--list) 1))
                           (single-mon-p (string-empty-p (gb/get-second-monitor))))
                      (if (or (and (s-equals? (gb/get-second-monitor) monitor)
                                (< workspaceIdx lastIndex))
                             (and single-mon-p
                                (< workspaceIdx lastIndex)))
                          (progn (gb/exwm-workspace-switch (+ 1 workspaceIdx) t)
                                 (while-no-input
                                   (gb/exwm-visualize-workspace-switch (+ workspaceIdx (if single-mon-p 1 0)) (- (length exwm-workspace--list) (if single-mon-p 0 1)) 10)
                                   (gb/play-theme-sound gb/sound-theme-effect-switch-workspace)
                                   (message (format "\\/     now %s" (exwm-workspace--position exwm-workspace--current))))
                                 ;; (x-focus-frame (selected-frame))
                                 (doom-modeline-set-selected-window))
                        (message "no workspace below this."))
                      (beacon-blink)))

                  (defun gb/exwm-workspace-up ()
                    "jump to workspace up of the current one (multi monitor)"
                    (interactive)
                    (let* ((workspaceIdx (exwm-workspace--position exwm-workspace--current))
                           (monitor (nth (+ 1 (* 2 workspaceIdx)) exwm-randr-workspace-monitor-plist))
                           (single-mon-p (string-empty-p (gb/get-second-monitor))))
                      (if (or (and (s-equals? (gb/get-second-monitor) monitor)
                                (> workspaceIdx 1))
                             (and single-mon-p
                                (> workspaceIdx 0)))
                          (progn (gb/exwm-workspace-switch (- workspaceIdx 1) t)
                                 (while-no-input
                                   (gb/exwm-visualize-workspace-switch (- workspaceIdx (if single-mon-p 1 2)) (- (length exwm-workspace--list) (if single-mon-p 0 1)) 10)
                                   (gb/play-theme-sound gb/sound-theme-effect-switch-workspace)
                                   (message (format "/\\     now %s" (exwm-workspace--position exwm-workspace--current))))
                                 ;; (x-focus-frame (selected-frame))
                                 (doom-modeline-set-selected-window))
                        (message "no workspace above this"))
                      (beacon-blink)))
                  (defun gb/exwm-next-workspace (&optional inc)
                    "jump to the next (inc) workspace"
                    (interactive)
                    (let* ((inc (or inc 1))
                           (index (+ exwm-workspace-current-index inc))
                           (len (length exwm-workspace--list)))
                      (exwm-workspace-switch (cond
                                              ((< index 0) (+ index len))
                                              ((< index len) index)
                                              (t (- index len))))) t)
                  (defun gb/exwm-previous-workspace (&optional inc)
                    "jump to the previous (inc) workspace"
                    (interactive)
                    (gb/exwm-next-workspace (- (or inc 1))))

                  (when (file-exists-p "~/.emacs.d/work/itemis.el")
                    (use-package itemis
                      :load-path "~/.emacs.d/work/")))

          :ensure t))
    #+END_SRC
  - exwm-mff
    #+BEGIN_SRC emacs-lisp
      (when gb/use-exwm
        (use-package exwm-mff
          :ensure t
          :config
          (require 'exwm-core)
          (defun gb/mouse-pointer-to-cursor ()
            (interactive)
            (if (and (boundp exwm-class-name) exwm-class-name)
                (exwm-mff-warp-to-selected-window)
              (let ((position (window-absolute-pixel-position)))
                (set-mouse-absolute-pixel-position
                 (car position) (cdr position)))))
          :after exwm-config
          ))
    #+END_SRC
  - exwm-config
    #+BEGIN_SRC emacs-lisp
      (when gb/use-exwm
        (use-package exwm-config
          :after ( exwm )
          :config
          (require 'exwm-core)
          (exwm-config-default) ;; enables ido mode !
          (ido-mode -1)

          ;; (if (shell-command-to-string "ps -A | grep VBoxClient")
          ;;     (message "OK: VBoxClient seems to be running, thus clipboard sharing is probably active")
          ;;   (message "ERROR: VBoxClient is not running! Clipboard sharing is not available"))

          (setq gb/dual-screen-mode 'regular) ;; 'presentation 'shared-screen

          (defun gb/toggle-presentation-monitor-setup ()
            ""
            (interactive)
            (if (eq gb/dual-screen-mode 'presentation)
                (setq gb/dual-screen-mode 'regular)
              (setq gb/dual-screen-mode 'presentation))
            (gb/refresh-exwm-monitor-setup))

          (defun gb/toggle-shared-screen-monitor-setup ()
            ""
            (interactive)
            (if (eq gb/dual-screen-mode 'shared-screen)
                (setq gb/dual-screen-mode 'regular)
              (setq gb/dual-screen-mode 'shared-screen))
            (gb/refresh-exwm-monitor-setup))

          (defun gb/xrandr-monitor-resolution (monitor)
            "get the maximal resolution of the given monitor"
            (s-trim (shell-command-to-string (s-concat "xrandr -q | grep " monitor " -A 1 | tail -n 1 | awk '{ print $1; }'"))))

          (defun gb/reset-exwm-monitor-setup ()
            "reset the (multi) monitor setup for exwm"
            (interactive)
            (shell-command-to-string "xrandr --auto")
            (gb/refresh-exwm-monitor-setup))

          (defun gb/exwm--get-connected-monitors ()
            ""
            (s-split "\n" (s-trim (shell-command-to-string "xrandr | grep ' connected' | cut -f1 -d' '"))))

          (defun gb/exwm--get-primary-monitor ()
            ""
            (s-trim (shell-command-to-string "xrandr | grep ' connected' | grep 'primary' | cut -f1 -d' '")))

          (defun gb/exwm--get-secondary-monitor ()
            ""
            (when-let ((other-monitors (remove (gb/exwm--get-primary-monitor) (gb/exwm--get-connected-monitors))))
              (car other-monitors)))

          (defun gb/exwm--get-geometry-str (monitor)
            ""
            (car (s-split "+" (s-trim (shell-command-to-string (format "xrandr | grep -e '%s connected' | sed \"s/%s connected \\\(primary \\\)*//g\" | cut -f1 -d' '" monitor monitor))))))

          (defun gb/refresh-exwm-monitor-setup ()
            "refresh current multi monitor setup for exwm"
            (interactive)
            (let ((dual-monitor (<= 2 (length (gb/exwm--get-connected-monitors))))
                  (primary-monitor (gb/exwm--get-primary-monitor)))
              (message "exwm change hook")
              (if dual-monitor
                  (let* ((second-monitor (gb/exwm--get-secondary-monitor))
                         (sm-resolution (gb/exwm--get-geometry-str second-monitor)))
                    (message (format "dual-monitor setup (primary: %s, secondary: %s@%s)" primary-monitor second-monitor sm-resolution))
                    (cond
                     ((string-empty-p second-monitor)
                      (setq exwm-randr-workspace-monitor-plist (-interleave (number-sequence 0 (-  (exwm-workspace--count) 1)) (-repeat (exwm-workspace--count) primary-monitor))))
                     ((or (eq gb/dual-screen-mode 'presentation) (eq gb/dual-screen-mode 'shared-screen))
                      (progn
                        (message "dual monitor presentation/shared-screen mode")
                        (setq  exwm-randr-workspace-monitor-plist (append `(0 ,primary-monitor) (-interleave (number-sequence 1 (-  (exwm-workspace--count) 1)) (-repeat (- (exwm-workspace--count) 1) primary-monitor))))
                        (shell-command (s-concat "xrandr --output " second-monitor " --same-as "  primary-monitor " --mode " (gb/xrandr-monitor-resolution primary-monitor)))))
                     (t
                      (progn
                        (message "dual monitor")
                        (setq  exwm-randr-workspace-monitor-plist (append `(0 ,primary-monitor) (-interleave (number-sequence 1 (-  (exwm-workspace--count) 1)) (-repeat (- (exwm-workspace--count) 1) second-monitor))))
                        (shell-command (s-concat "xrandr --output " primary-monitor " --left-of "  second-monitor " --auto"))
                        (shell-command (s-concat "xrandr --output " second-monitor " --preferred"))))))
                (progn
                  (message "single monitor")
                  (setq exwm-randr-workspace-monitor-plist (-interleave (number-sequence 0 (-  (exwm-workspace--count) 1)) (-repeat (exwm-workspace--count) primary-monitor)))
                  (shell-command-to-string "xrandr --auto")))
              (gb/reset-main-fonts)
              (exwm-randr-refresh)))

          ;; make sure multi monitor support is active
          (progn
            (message "Starting multimonitor support for exwm.")
            (require 'exwm-randr)
            (add-hook 'exwm-randr-screen-change-hook #'gb/refresh-exwm-monitor-setup)
            (exwm-randr-enable))


          (setq gb/previous-window-focus-exwm-class-name nil)
          (setq gb/previous-window-focus nil)
          (setq gb/previous-window-focus-commit-count 0)
          ;; patch function (wrap in when) such that this function will do nothing if not in an x-window
          ;; eglot help display in minibuffer puts focus elsewhere, resulting in repeated timed calls to this function which
          ;; will put a lot of strain on the cpu
          ;; execute complete function if coming from or going to an x window!
          ;; (defun exwm-input--update-focus-commit (window)
          ;;   "Commit updating input focus."
          ;;   (let ((new-window (not (eq window gb/previous-window-focus))))
          ;;     (when new-window
          ;;       (setq gb/previous-window-focus-commit-count 0)
          ;;       (message "exwm focus counter reset (new window)"))

          ;;     (when (< gb/previous-window-focus-commit-count 100) ;; do this focusing a couple of times even if the window does not change
          ;;       ;; (or exwm-class-name
          ;;       ;;   gb/previous-window-focus-exwm-class-name)
          ;;       (progn
          ;;         (message "exwm focus update commit")
          ;;         (setq gb/previous-window-focus-commit-count (+ 1 gb/previous-window-focus-commit-count))
          ;;         (setq gb/previous-window-focus-exwm-class-name exwm-class-name)
          ;;         (setq gb/previous-window-focus window)
          ;;         (setq exwm-input--update-focus-lock t)
          ;;         (unwind-protect
          ;;             (exwm-input--update-focus window)
          ;;           (setq exwm-input--update-focus-lock nil))))))

          ;; The following example demonstrates how to set a key binding only available
          ;; in line mode. It's simply done by first push the prefix key to
          ;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
          ;; The example shorten 'C-c q' to 'C-q'.
          (push ?\C-q exwm-input-prefix-keys)
          (push ?\M-\s exwm-input-prefix-keys)
          (general-define-key
           :keymaps 'override
           :prefix "M-SPC"
           ;; "s" 'helm-swoop
           "SPC" 'avy-goto-char-timer)
          (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)



          ;; globally set keys that will not be routed to the respective xwindow (some keys set by exwm-input-set-key are swallowed by x-applications)
          (setq exwm-input-global-keys
                `(([?\s-r] . exwm-reset)
                  ([?\s-w] . exwm-workspace-switch)
                  (,(kbd "<s-tab>") . nswbuff-switch-to-next-buffer)
                  (,(kbd "<s-iso-lefttab>") . nswbuff-switch-to-previous-buffer)))

          (defun gb/wrap-in-exwm-reset (interactive-function)
            "run exwm reset right before calling the given function"
            (interactive)
            (when (and exwm-class-name
                       (or (string= exwm-class-name "X64")
                           ;; (string= (downcase exwm-class-name) "eclipse")
                           ;; (string= (downcase exwm-class-name) "dosbox")
                           ;; (string= (downcase exwm-class-name) "jetbrains-idea-ce")
                           ))
              (exwm-reset))
            (funcall interactive-function))


          (defun gb/windmove-left ()
            ""
            (interactive)
            (if (windmove-find-other-window 'left)
                (windmove-left)
              (if (gb/exwm-workspace-left)
                  (while (windmove-find-other-window 'right)
                    (windmove-right)))))

          (defun gb/windmove-right ()
            ""
            (interactive)
            (if (windmove-find-other-window 'right)
                (windmove-right)
              (if (gb/exwm-workspace-right)
                  (while (windmove-find-other-window 'left)
                    (windmove-left)))))

          (defun gb/exwm-distinct-exwm-buffer-names ()
            "list of distinct running exwm buffers/programs"
            (-distinct
             (map-values-apply
              (lambda (name)
                (->> name
                     (buffer-name)
                     (replace-regexp-in-string "<[0-9]*>$" "")
                     (downcase)))
              exwm--id-buffer-alist)))

          (defun gb/exwm--switch (program &optional alias)
            "try to switch to a running program (nil on failure"
            (let* ((browser-alias (s-concat program "-browser"))
                   (stable-removed (s-replace "-stable" "" program)))
              (if (-contains? (gb/exwm-distinct-exwm-buffer-names) program)
                  (exwm-workspace-switch-to-buffer (s-capitalize program))
                (if (-contains? (gb/exwm-distinct-exwm-buffer-names) browser-alias)
                    (exwm-workspace-switch-to-buffer (s-capitalize browser-alias))
                  ;; (exwm-reset) ;; make sure that keyboard is no longer captured
                  (when (-contains? (gb/exwm-distinct-exwm-buffer-names) stable-removed)
                    (exwm-workspace-switch-to-buffer (s-capitalize stable-removed)))))))

          (when (eq gb/completion-framework 'helm)
            (require 'helm-external)

            (defun gb/exwm--switch-or-run (program &optional alias)
              "switch to this program if already open or start it"
              ;; (exwm-reset)
              (unless (gb/exwm--switch program alias)
                (helm-run-external-command program)
                (run-at-time 1 nil `(lambda () (gb/exwm--switch ,program)))))

            (defun gb/exwm-program-select (program)
              "select a native (unix) program to execute, select the buffer named as
             the program instead, if such a buffer exists"
              (interactive (list
                            (helm-comp-read
                             "RunProgram: "
                             (helm-external-commands-list-1 'sort)
                             :must-match t
                             :del-input nil
                             :name "External Commands"
                             :history helm-external-command-history)))
              ;; (setq exwm-manage-force-tiling (string-equal program "dosbx"))
              (gb/exwm--switch-or-run program)
              ;; (run-at-time 3 nil #'(lambda () (setq exwm-manage-force-tiling nil)))
              ))

          (defun gb/exwm-insert-string-anywhere (string)
            "insert given string in exwm x window, or any other emacs buffer"
            (if exwm-class-name
                (progn
                  (kill-new string)
                  (sleep-for 0.2)
                  (dolist (key (string-to-list (kbd "C-v")))
                    (exwm-input--fake-key key)))
              (insert string)))

          (defun gb/firefox-open-on-workspace-1 ()
            ""
            (interactive)
            (gb/exwm-workspace-switch 1)
            (let ((fbuffer (--find (s-matches? "Firefox.*" (buffer-name(cdr  it))) exwm--id-buffer-alist)))
              (if fbuffer
                  (switch-to-buffer (cdr fbuffer))
                  (start-process-shell-command "firefox" nil "jfirefox"))))

          (defun gb/mail-open-on-workspace-7 ()
            ""
            (interactive)
            (gb/exwm-workspace-switch 7)
            (unless (--any? (s-matches? it (buffer-name)) '(".Summary.*" ".Group.*" ".Article" ".BBDB."))
              (call-interactively #'gnus)))

          (defun gb/emacs-init-open ()
            ""
            (interactive)
            (find-file "~/repo/emacs-init/emacs-init.org"))

          (defun gb/slack-open-on-workspace-1 ()
            ""
            (interactive)
            (gb/exwm-workspace-switch 1)
            (start-process-shell-command "slack-buffer" nil "slack-ui"))

          (defun gb/pass-open-on-workspace-0 ()
            ""
            (interactive)
            (gb/exwm-workspace-switch 0)
            (ignore-errors (windmove-right))
            (unless (s-equals? (buffer-name) (f-filename gb/password-store))
              (split-window-right-and-select-scratch)
              (find-file gb/password-store)))

          ;; changes via exwm-input-set-key become active after restart of exwm only!
          (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") #'gb/brightness-up)
          (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") #'gb/brightness-down)
          (exwm-input-set-key (kbd "<XF86AudioLowerVolume>") #'gb/audio-lower-volume)
          (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") #'gb/audio-raise-volume)
          (exwm-input-set-key (kbd "<XF86AudioMute>") #'gb/audio-mute-volume)
          (exwm-input-set-key (kbd "<s-f6>") #'gb/brightness-up)
          (exwm-input-set-key (kbd "<s-f5>") #'gb/brightness-down)
          (exwm-input-set-key (kbd "<s-f2>") #'gb/audio-lower-volume)
          (exwm-input-set-key (kbd "<s-f3>") #'gb/audio-raise-volume)
          (exwm-input-set-key (kbd "<s-f1>") #'gb/audio-mute-volume)
          (exwm-input-set-key (kbd "<s-f12>") #'exwm-floating-toggle-floating)
          (exwm-input-set-key (kbd "C-M-s-l") #'gb/suspend-laptop)
          (exwm-input-set-key (kbd "C-M-s-s") #'gb/shutdown)
          (exwm-input-set-key (kbd "C-M-s-r") #'gb/reboot)
          (exwm-input-set-key (kbd "s-'") #'gb/exwm-workspace-up)
          (exwm-input-set-key (kbd "s-/") #'gb/exwm-workspace-down)
          (exwm-input-set-key (kbd "s-e") #'buffer-expose)

          ;; shrink selected window horizontally
          (exwm-input-set-key (kbd "C-s-<left>") 'shrink-window-horizontally-effect)
          (exwm-input-set-key (kbd "C-S-s-<left>") '(lambda () (interactive) (shrink-window-horizontally-effect 50)))
          ;; enlarge selected window horizontally
          (exwm-input-set-key (kbd "C-s-<right>") 'enlarge-window-horizontally-effect)
          (exwm-input-set-key (kbd "C-S-s-<right>") '(lambda () (interactive) (enlarge-window-horizontally-effect 50)))
          ;; shrink selected window vertically
          (exwm-input-set-key (kbd "C-s-<down>") 'shrink-window-effect)
          (exwm-input-set-key (kbd "C-S-s-<down>") '(lambda () (interactive) (shrink-window-effect 50)))
          ;; enlarge slected window vertically
          (exwm-input-set-key (kbd "C-s-<up>") 'enlarge-window-effect)
          (exwm-input-set-key (kbd "C-S-s-<up>") '(lambda () (interactive) (enlarge-window-effect 50)))


          (when (eq gb/completion-framework 'ivy)
            (exwm-input-set-key (kbd "s-1") #'gb/ivy--program-select-and-run)
            (exwm-input-set-key (kbd "s-b") #'ivy-switch-buffer)
            (exwm-input-set-key (kbd "s-f") #'counsel-buffer-or-recentf)
            (exwm-input-set-key (kbd "s-SPC") #'counsel-M-x))

          (when (eq gb/completion-framework 'helm)
            ;; start programs
            (exwm-input-set-key (kbd "s-1") #'gb/exwm-program-select) ;; do not wrap, since it already resets exwm
            ;; switch buffers
            (exwm-input-set-key (kbd "s-b") #'helm-mini)
            ;; open files
            (exwm-input-set-key (kbd "s-f") #'helm-for-files)
            ;; helm-M-x
            (exwm-input-set-key (kbd "s-SPC") #'helm-M-x)) ;; may have problems jumping off from eclipse

          ;; select window via ace
          (exwm-input-set-key (kbd "s-o") #'ace-select-window)

          (exwm-input-set-key (kbd "s-<left>") #'gb/windmove-left)
          (exwm-input-set-key (kbd "s-<right>") #'gb/windmove-right)
          (exwm-input-set-key (kbd "s-<up>") #'windmove-up)
          (exwm-input-set-key (kbd "s-<down>") #'windmove-down)

          (exwm-input-set-key (kbd "H-l") #'gb/lock-screen)
          (exwm-input-set-key (kbd "H-c") #'gb/mouse-pointer-to-cursor)
          (exwm-input-set-key (kbd "H-s") #'gb/slack-open-on-workspace-1)
          (exwm-input-set-key (kbd "H-p") #'gb/pass-open-on-workspace-0)
          (exwm-input-set-key (kbd "H-u") #'gb/firefox-open-on-workspace-1)
          (exwm-input-set-key (kbd "H-m") #'gb/mail-open-on-workspace-7)
          (exwm-input-set-key (kbd "H-e") #'gb/emacs-init-open)
          (exwm-input-set-key (kbd "H-/") #'slack-select-rooms)
          (exwm-input-set-key (kbd "H-.") #'slack-select-unread-rooms)
          (exwm-input-set-key (kbd "H-a") #'gb/org-agenda)

          (exwm-input-set-key (kbd "S-s-<up>") #'gb/remove-upper-window)
          (exwm-input-set-key (kbd "S-s-<down>") #'gb/remove-lower-window)

          (exwm-input-set-key (kbd "S-s-<left>") #'gb/remove-left-window)
          (exwm-input-set-key (kbd "S-s-<right>") #'gb/remove-right-window)

          (exwm-input-set-key (kbd "s-3") #'(lambda () (interactive) (split-window-right-and-select-scratch)))
          (exwm-input-set-key (kbd "s-2") #'(lambda () (interactive) (split-window-below-and-select-scratch)))
          (exwm-input-set-key (kbd "s-0") #'(lambda () (interactive) (delete-window)))
          (exwm-input-set-key (kbd "C-s-o") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-s-a") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-s-u") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-s-s") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-S-s-o") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-S-s-a") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))
          (exwm-input-set-key (kbd "C-S-s-u") #'(lambda () (interactive) (gb/exwm-insert-string-anywhere "")))

          ;; aws browsing
          (exwm-input-set-key (kbd "C-c a a c") #'gb/aws-code-commit-browse)
          (exwm-input-set-key (kbd "C-c a a e") #'gb/aws-ec2-browse)
          (exwm-input-set-key (kbd "C-c a a p") #'gb/aws-pipeline-browse)
          (exwm-input-set-key (kbd "C-c a a s") #'gb/aws-s3-browse)

          (setq gb/aws-region "eu-central-1")
          (defun gb/aws-code-commit-browse ()
            "browse to aws service console for code commit"
            (interactive)
            (browse-url (format "https://eu-central-1.console.aws.amazon.com/codesuite/codecommit/repositories?region=%s" gb/aws-region)))
          (defun gb/aws-ec2-browse ()
            "browse to aws service console for ec2"
            (interactive)
            (browse-url (format "https://eu-central-1.console.aws.amazon.com/ec2/v2/home?region=%s" gb/aws-region)))
          (defun gb/aws-pipeline-browse ()
            "browse to aws service console for code pipline"
            (interactive)
            (browse-url (format "https://eu-central-1.console.aws.amazon.com/codesuite/codepipeline/pipelines?region=%s" gb/aws-region)))
          (defun gb/aws-s3-browse ()
            "browse to aws service console for s3"
            (interactive)
            (browse-url (format "https://s3.console.aws.amazon.com/s3/home?region=%s" gb/aws-region)))

          (setq gb/simulation-keys
                `(
                  ;; see http://ergoemacs.org/emacs/keystroke_rep.html for syntax of key definition
                  ;; movement
                  ;; read-key-sequence-vector can be used to get key-sequences as used as first element
                  (,(kbd "C-b") . left)
                  (,(kbd "M-b") . C-left)
                  (,(kbd "C-f") . right)
                  (,(kbd "M-f") . C-right)
                  (,(kbd "C-p") . up)
                  (,(kbd "C-n") . down)
                  (,(kbd "C-a") . home)
                  (,(kbd "C-e") . end)
                  (,(kbd "M-v") . prior)
                  (,(kbd "C-v") . next)
                  (,(kbd "C-d") . delete)
                  (,(kbd "M-d") . (S-C-right delete))
                  (,(kbd "<M-DEL>") . (S-C-left delete))
                  (,(kbd "C-k") . (S-end delete))
                  (,(kbd "M->") . (C-end))
                  (,(kbd "M-<") . (C-home))
                  (,(kbd "C-j") . (S-return))
                  ;; cut/paste.
                  (,(kbd "C-w") . ?\C-x)
                  (,(kbd "M-w") . ?\C-c)
                  (,(kbd "C-y") . ?\C-v)
                  ;; marking
                  (,(kbd "C-x h") . ?\C-a) ;; will work in emacs 27 first time [?\C-x ?h]
                  ;; other
                  (,(kbd "C-g") . escape)
                  ;; search
                  (,(kbd "C-s") . ?\C-f)))
          (setq exwm-input-simulation-keys gb/simulation-keys)

          ;; You can hide the mode-line of floating X windows by uncommenting the
          ;; following lines
          (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
          (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

          ;; You can hide the minibuffer and echo area when they're not used, by
          ;; uncommenting the following line
          ;; (setq exwm-workspace-minibuffer-position 'bottom)

          (setq exwm-workspace-number 8) ;; set the number of workspaces (default is 4)

          ;; make sure that workspace frames are initialized without frame creation speedup
          ;; gnus does not work well with speed initialized frames, it shows some font problems
          (advice-add 'exwm-workspace--init :around #'gb/disable-frame-speedup-for)

          ;; show all exwm buffers in all workspaces (no restriction)
          (setq exwm-workspace-show-all-buffers t)
          ;; automatic moving of x window from inactive workspace by switching buffer
          (setq exwm-layout-show-all-buffers t)

          ;; enable system tray which is displayed in the message area all the way to the right
          (require 'exwm-systemtray)
          (setq exwm-systemtray-height 17)
          (exwm-systemtray-enable)

          (defun gb/exwm-release-keyboard ()
            (interactive)
            (message "resetting exwm keyboard binding.")
            (exwm-input-release-keyboard)
            (exwm-input-set-local-simulation-keys nil))

          (exwm-input-set-key (kbd "H-r") #'gb/exwm-release-keyboard)

          (defun gb/exwm-grab-keyboard ()
            (interactive)
            (message "grab exwm keyboard binding.")
            (exwm-input-grab-keyboard))

          (exwm-input-set-key (kbd "H-g") #'gb/exwm-grab-keyboard)

          (setq exwm-manage-configurations `(((s-equals-p "dosbox" exwm-instance-name)
                                              char-mode t
                                              floating nil
                                              workspace 6
                                              simulation-keys nil
                                              )
                                             ((or (string= exwm-class-name "X64")
                                                 (string= (downcase exwm-class-name) "eclipse")
                                                 (string= exwm-class-name "qutebrowser"))
                                              simulation-keys nil
                                              char-mode t)
                                             ((or (string= (downcase exwm-class-name) "google-chrome")
                                                 (string-match "^firefox.*" (downcase exwm-class-name))
                                                 (string= (downcase exwm-class-name) "chromium-browser")
                                                 (string= (downcase exwm-class-name) "tor-browser"))
                                              simulation-keys
                                              ,(append
                                               gb/simulation-keys
                                               `((,(kbd "C-S-s") . C-k)        ;; search with search engine (C-S-s)
                                                 (,(kbd "C-S-u") . f6)         ;; jump into adresse bar (C-S-u)
                                                 (,(kbd "<C-left>") . C-S-tab) ;; switch to previous tab
                                                 (,(kbd "<C-right>") . C-tab)  ;; switch to next tab
                                                 )))))

          ;; start pasystray from within emacs, starting it within xinitrc does not work
          (add-hook 'exwm-init-hook
                    (lambda ()
                      (gb/start-if-not-running (s-trim (shell-command-to-string "command -v pasystray")))
                      ;; (start-process "yabar" nil  "/usr/bin/yabar") ;; see here: https://github.com/geommer/yabar
                      (ido-mode -1)
                      (set-fringe-mode 10)
                      (toggle-truncate-lines 1)
                      (gb/disable-ligatures)
                      (setq pomodoro-mode-line-string nil)
                      ;; (exwm-mff-mode)
                      (setq global-mode-string
                            (append '("" emms-mode-line-string emms-playing-time-string " "
                                      (:eval (s-concat "[" (number-to-string (exwm-workspace--position exwm-workspace--current)) "]" ))
                                      (:eval (unless (string-empty-p pomodoro-mode-line-string) " ") pomodoro-mode-line-string))
                                    global-mode-string))
                      (setq auto-hscroll-mode t)))

          ))
    #+END_SRC
  - exwm-edit
    #+BEGIN_SRC emacs-lisp
      (when gb/use-exwm
        (use-package exwm-edit
          ;; C-c C-' to edit any text field within a x-window program in a separate emacs buffer
          :ensure t))
    #+END_SRC
  - exwm-xmi (disabled, dosbox not working)
    #+begin_src emacs-lisp :tangle no
      (when (gb/use-exwm)
        (require 'exwm-xim)
        (exwm-xim-enable))
    #+end_src
* fritz nas
  - tested with cifs-utils-6.9
  #+begin_src emacs-lisp
    (defvar gb/fritz-mount-point
      "/home/pe/temp/fp2_mountpoint"
      "mount fritz nas to this folder")

    (defvar gb/fritz-mount-point-check-folder
      "INTENSO"
      "folder expected to exist on fritz nas")

    (defvar gb/fritz-nas-ip
      "192.168.0.2"
      "ip address of the fritz nas")

    (defun gb/umount-fritz-nas ()
      "unmount the fritz nas"
      (interactive)
      (if (file-directory-p (s-concat gb/fritz-mount-point "/" gb/fritz-mount-point-check-folder))
          (message (s-trim (shell-command-to-string (s-concat "sudo umount -v " gb/fritz-mount-point "/"))))
        (message "not mounted or mount empty")))

    (defun gb/mount-fritz-nas ()
      "mount the fritz nas"
      (interactive)
      (if (file-directory-p (s-concat gb/fritz-mount-point "/" gb/fritz-mount-point-check-folder))
          (message "already mounted or mountpoint not empty.")
        (let* ((pass (read-passwd "password for fritz nas: ")))
          (message (s-trim (shell-command-to-string (format "sudo mount.cifs --verbose \\\\\\\\%s\\\\FRITZ.NAS %s/ -o user=gunther.bachmann,pass=%s,dom=WORKGROUP,vers=1.0" gb/fritz-nas-ip gb/fritz-mount-point pass))))
          (dired gb/fritz-mount-point))))
  #+end_src
* networking en/disable
  #+begin_src emacs-lisp
    (defun gb/net-lan-switch-on ()
      "switch wired lan on"
      (interactive)
      (message (s-trim (shell-command-to-string "sudo ifconfig --up enp0s31f6"))))

    (defun gb/net-lan-switch-off ()
      "switch wired lan off"
      (interactive)
      (message (s-trim (shell-command-to-string "sudo ifconfig --down enp0s31f6"))))

    (defun gb/net-wlan-switch-on ()
      "switch wireless lan on, needs tlp to be installed"
      (interactive)
      (shell-command-to-string "sudo systemctl start wpa_supplicant.service ") ;; just to make sure
      (message (s-trim (shell-command-to-string "sudo wifi on"))))

    (defun gb/net-wlan-switch-off ()
      "switch wireless lan off, needs tlp to be installed"
      (interactive)
      (message (s-trim (shell-command-to-string "sudo wifi off")))) ;; systemctl stop wpa_supplicant.service

    (defun gb/net-bluetooth-switch-on ()
      "switch bluetooth on, needs tlp to be installed"
      (interactive)
      (message (s-trim (shell-command-to-string "sudo bluetooth on"))))

    (defun gb/net-bluetooth-switch-off ()
      "switch bluetooth off, needs tlp to be installed"
      (interactive)
      (message (s-trim (shell-command-to-string "sudo bluetooth off"))))

    (defun gb/get-vpns-available ()
      "get a list of available vpns"
      (split-string (s-trim (shell-command-to-string " systemctl --all list-unit-files openvpn*  | grep openvpn | cut -f1 -d' '"))))

    (defun gb/net-vpn-switch-on ()
      "switch vpn on"
      (interactive)
      (let ((vpn-id (completing-read "vpn:" (gb/get-vpns-available) nil t)))
        (message (s-trim (shell-command-to-string (format "sudo systemctl start %s" vpn-id))))))

    (defun gb/net-vpn-switch-off ()
      "switch vpn off"
      (interactive)
      (let ((vpn-id (completing-read "vpn:" (gb/get-vpns-available) nil t)))
        (message (s-trim (shell-command-to-string (format "sudo systemctl stop %s" vpn-id))))))

    (defun gb/net-vpn-log-show ()
      "show the log of vpns (this day)"
      (interactive)
      (let ((buf (generate-new-buffer "*vpn service log*")))
        (with-current-buffer buf
          (switch-to-buffer buf)
          (setq buffer-offer-save nil)
          (text-mode)
          (shell-command "journalctl --since -1d  -u openvpn*" (current-buffer))
          (end-of-buffer)
          (read-only-mode 1))))
  #+end_src
* org tree slide (presenting org mode files as slides)
  - did some modifications to allow for timers during presentation
    #+begin_src emacs-lisp :tangle no
      ;; org-tree-slide-move-next-tree was adjusted:
      ;; at head
      (when (org-tree-slide--active-p)
        (unless gb/slides-started
          (setq gb/slides-started (org-time-add nil 0)))
        (when org-timer-start-time
          (org-timer-stop))  ;; ...
      )
      ;; at the tail

      (unless (equal org-tree-slide-modeline-display 'outside)
        (setq gb/current-slide (org-tree-slide--count-slide (point)))
        (message (format "   %s Next >>" gb/current-slide))
        (gb/org-tree-slide--update-slide-timer))
      ;; and this was added completely
      (setq gb/current-slide 0)

      (defun gb/org-tree-slide--update-slide-timer ()
        ""
        (let* ((slide    (string-to-number (nth 1 (s-match "\\[\\(.*\\)/\\(.*\\)\\]" gb/current-slide))))
               (rem-secs (floor
                          (float-time (org-time-subtract (org-time-add gb/slides-started (* 90 slide))
                                                         (org-time-add nil 0))))))
          (if (> rem-secs 0)
              (org-timer-set-timer (org-timer-secs-to-hms rem-secs))
            (message (format "hurry up, got to catch up %s seconds" (- 0 rem-secs))))))
    #+end_src
  - package
    #+begin_src emacs-lisp
      (use-package org-tree-slide
        :load-path "~/repo/org-tree-slide"
        :commands (gb/presentation-on gb/presentation-off)
        :config
        (setq org-tree-slide-header nil)
        (setq org-tree-slide-heading-emphasis t)
        (setq original-org-show-notification-handler org-show-notification-handler)

        (defun gb/presentation-toggle-show-cursor ()
          (interactive)
          (if cursor-type
              (progn
                (setq cursor-type nil)
                (hl-line-mode -1))
            (setq cursor-type 'box)
            (hl-line-mode 1)))

        (bind-key "C-?" #'gb/presentation-toggle-show-cursor org-tree-slide-mode-map)

        (defun gb/presentation-on ()
          "make all relevant adjustments to present an org-tree-slide presentation"
          (interactive)
          (setq org-show-notification-handler
                      #'(lambda
                          (msg)
                          (message msg)))
          (when (boundp 'org-bullets-mode)
            (setq org-bullets-bullet-list '("" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "")))
          (setq cursor-type nil)
          (global-hl-line-mode -1)
          (hl-line-mode -1)
          (when (fboundp 'add-fira-code-symbol-keywords)
            (add-fira-code-symbol-keywords))
          (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.6))
          (progn (setq current-prefix-arg '(16))(call-interactively 'org-latex-preview))
          (org-display-inline-images)
          (org-show-all)
          (org-show-block-all)
          (save-excursion
            (goto-char (point-max))
            (when (re-search-backward (format "^[ \\t]*%s" (regexp-quote "#+begin_src")) nil t)
              (message "fold last lambda expression")
              (move-beginning-of-line nil)
              (org-hide-block-toggle 'on)))
          (org-babel-result-hide-all)
          (read-only-mode +1)
          (flyspell-mode 0) ;; no spell check errors
          (when (fboundp 'toggle-serif)
            (toggle-serif))
          ;; (when (boundp org-padding-mode)
          ;;   (setq org-padding-heading-padding-alist
          ;;         '((4.0 . 1.5) (3.0 . 0.5) (3.0 . 0.5) (3.0 . 0.5) (2.5 . 0.5) (2.0 . 0.5) (1.5 . 0.5) (0.5 . 0.5)))
          ;;   (org-padding-mode))
          (org-tree-slide-mode)
          (redisplay t)
          (when (boundp beginend-org-mode)
            (beginend-org-mode-goto-beginning))
          (setq org-tree-slide-content--pos nil)
          (org-tree-slide-content))

        (defun gb/presentation-off ()
          "revert all adjustments done to present an org-tree-slide presentation"
          (interactive)
          (org-tree-slide-mode -1)
          (when (fboundp 'remove-fira-code-symbol-keywords)
            (remove-fira-code-symbol-keywords))
          (when (boundp 'org-bullets-mode)
            (setq org-bullets-bullet-list '("" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "")))
          (when (fboundp 'toggle-serif)
            (toggle-serif))
          ;; (when (fboundp 'org-padding-mode)
          ;;   (org-padding-mode -1)
          ;;   (setq org-padding-heading-padding-alist
          ;;         '((0 . 0) (0 . 0) (0 . 0) (0 . 0) (0 . 0) (0 . 0) (0 . 0) (0 . 0)))
          ;;   (org-padding-mode 1)
          ;;   (redisplay t))
          (global-hl-line-mode 1)
          (setq cursor-type 'box)
          (setq org-show-notification-handler original-org-show-notification-handler)))
    #+end_src
  - disabled original package
    #+begin_src emacs-lisp :tangle no
      (use-package org-tree-slide
        :commands org-tree-slide-mode
        :ensure t
        :config
        (setq org-tree-slide-header nil)
        (setq org-tree-slide-heading-emphasis t))
    #+end_src
* eglot
  #+begin_src emacs-lisp
    (when (version< emacs-version "28")
      ;; starting with emacs 28, jsonrpc is internal and does not need to be loaded here
      (use-package jsonrpc
        :ensure t))
    (use-package eglot
      :ensure t
      :config
      (setq eglot-connect-timeout 240) ;; eglot takes some time to start if the project is complex
      (setq eglot-send-changes-idle-time 3) ;; wait 3s idle before contacting language server
      ;; (flymake-mode-off)
      ;; (flycheck-mode 1)
      )
  #+end_src
* vue (via lsp - eglot, thus this must be defined after eglot)
  - see https://genehack.blog/2020/08/web-mode-eglot-vetur-vuejs-=-happy/
  - install vls via ~npm install -g vls~
  #+begin_src emacs-lisp
    (when (and (package-installed-p 'eglot) (package-installed-p 'web-mode) (executable-find "vls"))
      (require 'web-mode)
      (require 'eglot)
      (define-derived-mode gb/vue-mode web-mode "gbVue"
        "A major mode derived from web-mode, for editing .vue files with LSP support.")
      (add-to-list 'auto-mode-alist '("\\.vue\\'" . gb/vue-mode))
      (add-hook 'gb/vue-mode-hook #'eglot-ensure)
      (add-to-list 'eglot-server-programs '(gb/vue-mode "vls")))
  #+end_src
* filter annoying messages
  #+begin_src emacs-lisp
    ;; filter annoying messages
    (setq gb/do-filter-annoying-messages nil)
    (defvar message-filter-regexp-list '("^Starting new Ispell process \\[.+\\] \\.\\.\\.$"
                                         "^Ispell process killed$"
                                         "^Omitting...$"
                                         "^Omitted .+ lines?\\.$"
                                         ;; "\\(.*mitt.*\\)"
                                         "^SUBTREE.*$"
                                         "^FOLDED"
                                         "^CHILDREN.*$"
                                         "^\\(Shell command succeeded with no output\\)$"
                                         "^Invalid face .*$"
                                         "^\\(Shell command succeeded with no output\\)$"
                                         "^Error during redisplay:.*run-hook-with-args helm--delete-frame-function.*user-error \"No recursive edit is in progress\".*$")
      "filter formatted message string to remove noisy messages")
    (when gb/do-filter-annoying-messages
      (defadvice message (around message-filter-by-regexp activate)
        (if (not (ad-get-arg 0))
            ad-do-it
          (let ((formatted-string (apply 'format (ad-get-args 0))))
            (if (and (stringp formatted-string)
                   (some (lambda (re) (string-match re formatted-string)) message-filter-regexp-list))
                (with-current-buffer "*Messages*"
                  (read-only-mode 0)
                  (goto-char (point-max))
                  (insert formatted-string "\n")
                  (read-only-mode 1))
              (progn
                (ad-set-args 0 `("%s" ,formatted-string))
                ad-do-it))))))
  #+end_src
* EVAL winum (select windows by number, which is shown in the modeline)
  - is useful for native applications in exwm, since ace-window cannot overlay those with the key to select those
  #+begin_src emacs-lisp
  (use-package winum
    :ensure t
    :config (winum-mode))
  #+end_src
* EVAL org-noter (keep notes to pdf, epub etc. files, that scroll with the document)
  - execute org-noter within a pdf document (pdf-tools), or epub (nov.el) ...
  - now you are in a noter session (quit with q)
  - i = insert note for page
  - M-i = insert note with precise location (asked to click)
  - M-n/p = jump to next/previous annotated page
  #+begin_src emacs-lisp
    (use-package org-noter
      :ensure t
      :commands (org-noter)
      :config
      (setq org-noter-default-notes-file-names '("notes.org")))
  #+end_src
* DISABLED treemacs (start with C-x t t)
  - see [[https://github.com/Alexander-Miller/treemacs][here]]
  #+begin_src emacs-lisp :tangle no
    (use-package treemacs
      :ensure t
      :defer t
      :init
      (with-eval-after-load 'winum
        (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
      :config
      (cond
       ((eq gb/theme-mode 'light) nil) ;; TODO complete
       (t (progn
            (--each '( (treemacs-root-face ((t (:inherit font-lock-variable-name-face :weight bold :height 1.2)))))
              (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
      (defun gb/tremacs-themes-setup-tab-width (&rest _)
        "Set `tab-width' to 1, so tab characters don't ruin formatting."
        (setq tab-width 1))
      (add-hook 'treemacs-mode-hook #'gb/tremacs-themes-setup-tab-width)
      (let ((face-spec '(:inherit font-lock-doc-face :slant normal)))
        (treemacs-create-theme "atom"
          ;; :icon-directory (f-join treemacs-dir "icons/default")
          :config
          (progn
            (treemacs-create-icon
             :icon (format " %s\t" (all-the-icons-octicon "repo" :height 1.2 :v-adjust -0.1 :face face-spec))
             :extensions (root))
            (treemacs-create-icon
             :icon (format "%s\t%s\t"
                           (all-the-icons-octicon "chevron-down" :height 0.75 :v-adjust 0.1 :face face-spec)
                           (all-the-icons-octicon "file-directory" :v-adjust 0 :face face-spec))
             :extensions (dir-open))
            (treemacs-create-icon
             :icon (format "%s\t%s\t"
                           (all-the-icons-octicon "chevron-right" :height 0.75 :v-adjust 0.1 :face face-spec)
                           (all-the-icons-octicon "file-directory" :v-adjust 0 :face face-spec))
             :extensions (dir-closed))
            (treemacs-create-icon
             :icon (format "%s\t%s\t"
                           (all-the-icons-octicon "chevron-down" :height 0.75 :v-adjust 0.1 :face face-spec)
                           (all-the-icons-octicon "package" :v-adjust 0 :height 0.9 :face face-spec)) :extensions (tag-open))
            (treemacs-create-icon
             :icon (format "%s\t%s\t"
                           (all-the-icons-octicon "chevron-right" :height 0.75 :v-adjust 0.1 :face face-spec)
                           (all-the-icons-octicon "package" :v-adjust 0 :height 0.9 :face face-spec))
             :extensions (tag-closed))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "tag" :height 0.9 :v-adjust 0 :face face-spec))
             :extensions (tag-leaf))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "flame" :v-adjust 0 :face face-spec))
             :extensions (error))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "stop" :v-adjust 0 :face face-spec))
             :extensions (warning))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "info" :height 0.75 :v-adjust 0.1 :face face-spec))
             :extensions (info))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-media" :v-adjust 0 :face face-spec))
             :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                          "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                          "wav" "mp3" "ogg" "midi"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-code" :height 1.1 :v-adjust 0 :face face-spec))
             :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                          "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                          "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                          "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                          "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                          "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                          "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                          "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                          "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                          "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                          "gitconfig" "csv" "cabal" "kt" "kts" "nim" "nims" "pm6" "sql"
                          "styles" "lua" "adoc" "asciidoc" "pp" "j2" "jinja2" "dockerfile"
                          "vagrantfile" "v" "vh" "sv"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "book" :v-adjust 0 :face face-spec))
             :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                          "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                          "azw3" "kf8" "kfx" "lit" "prc" "mobi" "exe" "or" "html"
                          "pkg" "opf" "txt" "pdb" "ps" "rtf" "pdg" "xml" "tr2"
                          "tr3" "oxps" "xps"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-text" :v-adjust 0 :face face-spec))
             :extensions ("md" "markdown" "rst" "log" "org" "txt"
                          "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-binary" :v-adjust 0 :face face-spec))
             :extensions ("exe" "dll" "obj" "so" "o" "out"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-pdf" :v-adjust 0 :face face-spec))
             :extensions ("pdf"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-zip" :v-adjust 0 :face face-spec))
             :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-octicon "file-text" :v-adjust 0 :face face-spec))
             :extensions (fallback))))

        (defun gb/get-treemacs-extensions (ext)
          "Expand the extension pattern EXT into a list of extensions.
    This is used to generate extensions for `treemacs' from `all-the-icons-icon-alist'."
          (let* ((e (s-replace-all
                     '((".\\?" . "") ("\\?" . "") ("\\." . "")
                       ("\\" . "") ("^" . "") ("$" . "")
                       ("'" . "") ("*." . "") ("*" . ""))
                     ext))
                 (exts (list e)))
            ;; Handle "[]"
            (when-let* ((s (s-split "\\[\\|\\]" e))
                        (f (car s))
                        (m (cadr s))
                        (l (caddr s))
                        (mcs (delete "" (s-split "" m))))
              (setq exts nil)
              (dolist (c mcs)
                (push (s-concat f c l) exts)))
            ;; Handle '?
            (dolist (ext exts)
              (when (s-match "?" ext)
                (when-let ((s (s-split "?" ext)))
                  (setq exts nil)
                  (push (s-join "" s) exts)
                  (push (s-concat (if (> (length (car s)) 1)
                                      (substring (car s) 0 -1))
                                  (cadr s)) exts))))
            exts))

        (treemacs-create-theme "doom-colors"
          :extends "atom"
          :config
          (progn
            (treemacs-create-icon
             :icon (format " %s\t" (all-the-icons-octicon "repo" :height 1.2 :v-adjust -0.1 :face 'font-lock-string-face))
             :extensions (root))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "flame" :v-adjust 0 :face 'all-the-icons-red))
             :extensions (error))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "stop" :v-adjust 0 :face 'all-the-icons-yellow))
             :extensions (warning))
            (treemacs-create-icon
             :icon (format "%s\t" (all-the-icons-octicon "info" :height 0.75 :v-adjust 0.1 :face 'all-the-icons-green))
             :extensions (info))
            (treemacs-create-icon
             :icon (format "  %s\t" (all-the-icons-alltheicon "git" :height 0.9 :face 'all-the-icons-red))
             :extensions ("gitignore" "git" "gitconfig" "gitmodules"))

            (dolist (item all-the-icons-icon-alist)
              (let* ((extensions (gb/get-treemacs-extensions (car item)))
                     (func (cadr item))
                     (args (append (list (caddr item)) '(:v-adjust -0.05) '(:height 0.85) (cdddr item)))
                     (icon (apply func args)))
                (let* ((icon-pair (cons (format "  %s\t" icon) " "))
                       (gui-icons (treemacs-theme->gui-icons treemacs--current-theme))
                       (tui-icons (treemacs-theme->tui-icons treemacs--current-theme))
                       (gui-icon  (car icon-pair))
                       (tui-icon  (cdr icon-pair)))
                  (--each extensions
                    (ht-set! gui-icons it gui-icon)
                    (ht-set! tui-icons it tui-icon))))))))
      (progn
        (setq treemacs-collapse-dirs                 (if (executable-find "python") 3 0)
              treemacs-deferred-git-apply-delay      0.5
              treemacs-display-in-side-window        t
              treemacs-file-event-delay              5000
              treemacs-file-follow-delay             0.2
              treemacs-follow-after-init             t
              treemacs-git-command-pipe              ""
              treemacs-goto-tag-strategy             'refetch-index
              treemacs-indentation                   2
              treemacs-indentation-string            "\t"
              treemacs-is-never-other-window         nil
              treemacs-max-git-entries               5000
              treemacs-no-png-images                 nil
              treemacs-no-delete-other-windows       t
              treemacs-project-follow-cleanup        nil
              treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
              treemacs-recenter-distance             0.1
              treemacs-recenter-after-file-follow    nil
              treemacs-recenter-after-tag-follow     nil
              treemacs-recenter-after-project-jump   'always
              treemacs-recenter-after-project-expand 'on-distance
              treemacs-show-cursor                   nil
              treemacs-show-hidden-files             nil
              treemacs-silent-filewatch              nil
              treemacs-silent-refresh                nil
              treemacs-sorting                       'alphabetic-desc
              treemacs-space-between-root-nodes      t
              treemacs-tag-follow-cleanup            t
              treemacs-tag-follow-delay              1.5
              treemacs-width                         45)

        ;; The default width and height of the icons is 22 pixels. If you are
        ;; using a Hi-DPI display, uncomment this to double the icon size.
        ;;(treemacs-resize-icons 44)

        (treemacs-follow-mode t)
        (treemacs-filewatch-mode t)
        (treemacs-fringe-indicator-mode t)
        (pcase (cons (not (null (executable-find "git")))
                     (not (null (executable-find "python3"))))
          (`(t . t)
           (treemacs-git-mode 'deferred))
          (`(t . _)
           (treemacs-git-mode 'simple))))
      (treemacs-load-theme "doom-colors") ;; "default" "atom"
      :bind
      (:map global-map
            ("M-0"       . treemacs-select-window)
            ("C-x t 1"   . treemacs-delete-other-windows)
            ("C-x t t"   . treemacs)
            ("C-x t B"   . treemacs-bookmark)
            ("C-x t C-t" . treemacs-find-file)
            ("C-x t M-t" . treemacs-find-tag)))

    ;; (use-package treemacs-evil
    ;;   :after treemacs evil
    ;;   :ensure t)

    (use-package treemacs-projectile
      :after treemacs projectile
      :ensure t)

    ;; (use-package treemacs-icons-dired
    ;;   :after treemacs dired
    ;;   :ensure t
    ;;   :config (treemacs-icons-dired-mode))

    (use-package treemacs-magit
      :after treemacs magit
      :ensure t)

    ;; (use-package lsp-treemacs
    ;;   :after treemacs lsp-mode
    ;;   :ensure t)
  #+end_src
* EVAL emacs surround (see [[https://github.com/ganmacs/emacs-surround][here]])
  #+begin_src emacs-lisp
  (when (file-exists-p "~/.emacs.d/additionals/emacs-surround/emacs-surround.el")
    (use-package emacs-surround
      :load-path "~/.emacs.d/additionals/emacs-surround"
      :bind (("s-q c s" . emacs-surround))))
  #+end_src
* EVAL browse-kill-ring
  #+begin_src emacs-lisp
  (use-package browse-kill-ring
    :load-path "~/.emacs.d/additionals/browse-kill-ring"
    :commands (browse-kill-ring))
  #+end_src
* EVAL pdf-view-restore (disabled)
  - stores .pdf-view-restore in each folder where pdfs are opned!
  #+begin_src emacs-lisp :tangle no
  (use-package pdf-view-restore
    :after pdf-tools
    :ensure t
    :init
    (add-hook 'pdf-view-mode-hook 'pdf-view-restore-mode))
  #+end_src
* EVAL docker mode
  #+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode (("Dockerfile.*\\'" . dockerfile-mode)))
  #+end_src
* EVAL sysctl
  #+begin_src emacs-lisp
    (use-package sysctl
      :commands (sysctl))
  #+end_src
* EVAL dianyou (gnus mail searching see https://github.com/redguardtoo/dianyou/blob/master/dianyou.el)
  #+begin_src emacs-lisp
    (use-package dianyou
      :ensure t)
  #+end_src
* EVAL tempbuff mode
  - remove buffers deemed unused see https://www.emacswiki.org/emacs/TempbufMode
  #+begin_src emacs-lisp
    (when (file-exists-p "~/.emacs.d/additionals/tempbuf.el")
      (use-package tempbuf
        :load-path "~/.emacs.d/additionals/"
        :config
        (custom-set-variables '(tempbuf-minimum-timeout (* 60 60 4)))
        (add-hook 'after-change-major-mode-hook 'turn-on-tempbuf-mode)))
  #+end_src
* EVAL hercules
  - see https://gitlab.com/jjzmajic/hercules.el
  - creates hydra like popups derived from which key information
  #+begin_src emacs-lisp
    (use-package hercules
      :ensure t
      :config
      (hercules-def
       :toggle-funs #'macrostep-mode
       :keymap 'macrostep-keymap)
      (hercules-def
       :toggle-funs #'debugger-mode
       :keymap 'debugger-mode-map
       :transient t))
  #+end_src
* EVAL scihub (access to otherwise under copyright inaccessible research papers etc.)
  #+begin_src emacs-lisp
    (use-package scihub
      :config
      (setq scihub-download-directory "~/Downloads"))
  #+end_src
* EVAL POSTPONED company-fuzzy
  - takes too long
  - does not allow for narrowing down
  - may interfer with company-hard
  #+begin_src emacs-lisp :tangle no
    (use-package company-fuzzy
      :ensure t)
  #+end_src
* EVAL awscli-capf
  - allow for awscli command line completion
  #+begin_src emacs-lisp
    (use-package awscli-capf
      :commands (awscli-add-to-capf awscli-capf-refresh-data-from-cli)
      ;; :ensure-system-package awscli ;; reinstalls awscli all the time
      :ensure t
      :hook (shell-mode . awscli-capf-add))
  #+end_src
* EVAL fast scroll (currently disabled)
  - disable font lock during C-v and M-v pagewise scrolling (if doing it fast)
  #+begin_src emacs-lisp :tangle no
    (use-package fast-scroll
      :ensure t
      :config
      (fast-scroll-config)
      (fast-scroll-mode 1)
      ;; (add-hook 'fast-scroll-start-hook (lambda () (flycheck-mode -1)))
      ;; (add-hook 'fast-scroll-end-hook (lambda () (flycheck-mode 1)))
      (setq fast-scroll-throttle 0.5))
  #+end_src
* EVAL csv mode
  #+begin_src emacs-lisp
    (when (file-exists-p "~/.emacs.d/additionals/csv-mode.el")
        (use-package csv-mode
          :commands csv-mode
          :load-path "~/.emacs.d/additionals"))
  #+end_src
* EVAL terraform-lsp
  #+begin_src emacs-lisp
    (with-eval-after-load 'lsp-mode
      (add-to-list 'lsp-language-id-configuration '(terraform-mode . "terraform"))

      (lsp-register-client
       (make-lsp-client :new-connection (lsp-stdio-connection `(,(s-trim (shell-command-to-string "command -v terraform-lsp")) "-enable-log-file"))
                        :major-modes '(terraform-mode)
                        :server-id 'terraform-ls))

      (add-hook 'terraform-mode-hook #'lsp))
  #+end_src
* EVAL indent-tools (navigate, fold and (de-indent))
  - see https://github.com/vindarel/indent-tools
  #+begin_src emacs-lisp
    (use-package indent-tools
      :bind (:map indent-tools-mode-map
                  ("C-c >" . indent-tools-indent)
                  ("C-c <" . indent-tools-demote)
                  ("C-c n" . indent-tools-goto-next-sibling)
                  ("C-c p" . indent-tools-goto-previous-sibling)
                  ("C-c u" . indent-tools-goto-parent)
                  ("C-c d" . indent-tools-goto-child)
                  ("<tab>" . yafolding-toggle-element)
                  ;; ("" . indent-tools-goto-end-of-tree)
                  ;; ("" . indent-tools-end-of-level)
                  )
      :config
      (add-hook 'python-mode-hook (lambda () (indent-tools-minor-mode)))
      (add-hook 'yaml-mode-hook (lambda () (indent-tools-minor-mode)))
      )
  #+end_src
* EVAL fancy narrow (disabled)
  - narrow to (function, block ...) while keeping other text visible r/o and faded out
  - this works currently best for elisp
  #+begin_src emacs-lisp :tangle no
    (use-package fancy-narrow
      :ensure t)
  #+end_src
* EVAL wttrin
  #+begin_src emacs-lisp
    (use-package wttrin
      :bind ("H-w" . wttrin)
      :ensure t
      :config
      (setq wttrin-default-cities '("Hamburg" "Darmstadt" "Coburg"))
      (setq wttrin-default-accept-language '("Accept-Language" . "de-DE"))
      (defalias 'weather 'wttrin)
      (defun wttrin-fetch-raw-string (query)
        "Get the weather information based on your QUERY."
        (shell-command-to-string (format "curl -s wttr.in/%s" query))))
  #+end_src
* EVAL helm-rg
  #+begin_src emacs-lisp
    (when (eq gb/completion-framework 'helm)
      (use-package helm-rg
        :commands helm-rg
        :ensure-system-package rg
        :ensure t))
  #+end_src
* EVAL keycast (incomplete) disabled
  #+begin_src emacs-lisp :tangle no
    (use-package keycast
      :config
      (add-hook 'keycast-mode #'(lambda () (setq mode-line-format '("%e" mode-line-front-space (:eval (doom-modeline-format--main))))))
      (setq keycast-insert-after 'mode-line-front-space)
      (setq keycast-separator-width 0)
      (setq keycast-remove-tail-elements nil)
      (setq mode-line-format '("%e" (:eval (doom-modeline-format--main)))))
  #+end_src
* EVAL emacs-piper (interactively work on os pipe commands)
  - see https://gitlab.com/howardabrams/emacs-piper/
  #+begin_src emacs-lisp
    (use-package piper
      :commands piper
      :load-path "~/.emacs.d/additionals/emacs-piper/")
  #+end_src
* EVAL camcorder (make recordings of emacs -> ogv|gif)
  #+begin_src emacs-lisp
    (use-package camcorder
      :ensure-system-package imagemagick
      :commands camcorder-record)
  #+end_src
* EVAL helm-switch-shell
  #+begin_src emacs-lisp
    (when (eq gb/completion-framework 'helm)
      (use-package helm-switch-shell
        :bind (("s-n" . helm-switch-shell))
        :ensure t))
  #+end_src
* EVAL fzf
  #+begin_src emacs-lisp
    (use-package fzf
      :commands (fzf fzf-git)
      :ensure-system-package fzf
      :ensure t)
  #+end_src
* EVAL helm-fish-completion (disabled)
  - interferes with programs started from the shell (mame looses keyboard control, dosbox too)
  #+begin_src emacs-lisp
    ;; (use-package helm-fish-completion)
  #+end_src
* EVAL pomodoro
  #+begin_src emacs-lisp
    (use-package pomodoro
      :ensure t
      :commands (pomodoro-stop pomodoro-start pomodoro-pause pomodoro-resume)
      :custom
      (pomodoro-desktop-notification nil)
      (pomodoro-play-sounds nil)
      (pomodoro-sound-player "mpg123")
      (pomodoro-time-format "%.2m ")
      :config
      (pomodoro-add-to-mode-line))
  #+end_src
* deft (deactivated, using notdeft instead)
  #+begin_src emacs-lisp :tangle no
    (use-package deft
      :commands deft
      :ensure t
      :bind ("s-S-d" . deft)
      :init
      (setq deft-default-extension "org"
            ;; de-couples filename and note title:
            deft-use-filename-as-title nil
            deft-use-filter-string-for-filename t
            ;; disable auto-save
            deft-auto-save-interval -1.0
            ;; search in subdirectories too
            deft-recursive t
            ;; converts the filter string into a readable file-name using kebab-case:
            deft-file-naming-rules
            '((noslash . "-")
              (nospace . "-")
              (case-fn . downcase))
            deft-strip-summary-regexp "\\([\n]\\|^#\\+[[:upper:]_]+:.*$\\|#\\+begin_src.*$\\|;; eval:.*$\\|#\\+end_src.*$\\|;; Local Variables.*$\\|;; End.*$\\|[[:space:]]\\{2,\\}\\|#\\+title: \\)"
            deft-directory "~/documents/roam")
      :config
      (add-to-list 'deft-extensions "tex")

      (defun gb/deft-parse-content (str)
        "strip content from default texts (noise)"
        (replace-regexp-in-string deft-strip-summary-regexp " " str))

      ;; replace existing caching of deft w/ modified version
      ;; that strips content before storing it in deft-hash-contents, too!
      (defun deft-cache-newer-file (file mtime)
        "Update cached information for FILE with given MTIME."
        ;; Modification time
        (puthash file mtime deft-hash-mtimes)
        (let (contents title)
          ;; Contents
          (with-current-buffer (get-buffer-create "*Deft temp*")
            (insert-file-contents file nil nil nil t)
            (setq contents (concat (buffer-string))))
          (puthash file (gb/deft-parse-content contents) deft-hash-contents)
          ;; Title
          (setq title (deft-parse-title file contents))
          (puthash file title deft-hash-titles)
          ;; Summary
          (puthash file (deft-parse-summary contents title) deft-hash-summaries))
        (kill-buffer "*Deft temp*")))

  #+end_src
* notdeft
  - alternative to deft, using xapian to do the heavy lifting of full text searching
  - see https://github.com/hasu/notdeft
  #+begin_src emacs-lisp
    (use-package notdeft
      :commands (notdeft)
      :bind ("s-d" . notdeft)
      :load-path "~/repo/notdeft"
      :hook (notdeft-mode . org-roam-stack-mode)
      :custom
      (notdeft-directories '("~/documents/roam"))
      (notdeft-xapian-program "/home/pe/repo/notdeft/xapian/notdeft-xapian")
      (notdeft-xapian-max-results 1000 "show up to 1000 entries in the notdef query buffer")
      :config
      ;; (require 'notdeft-org)

      ;; redefinition of reading deft link, using completing-read instead of ivy
    ;;   (defun notdeft-org-read-deft-link-name ()
    ;;     "Query for a \"deft:\" link name.
    ;; Do so interactively. Return the name component of a link, without
    ;; the \"deft:\" prefix."
    ;;     (let ((name-lst (notdeft-make-basename-list)))
    ;;       (when name-lst
    ;;         (completing-read "NotDeft note: " name-lst))))
      )
  #+end_src
* org roam
  - see https://rgoswami.me/posts/org-note-workflow/
  - for org-roam-server browser to http://localhost:8080
  - company-org-roam allows completion (company) of references other org-roam documents
  - patched org-roam-buffer at line 195 (only valid for emacs < 27)
    #+begin_src emacs-lisp :tangle no
      (run-hooks 'org-roam-buffer-prepare-hook)
      (read-only-mode 1)
      (org-mode) ;; added
      (org-show-all) ;; added
    #+end_src
  #+begin_src emacs-lisp
    (if (not (executable-find "sqlite3"))
        (message "ERROR: could not find executable sqlite3")
      (progn
        (use-package emacsql-sqlite)
        (use-package org-roam
          :commands (org-roam-buffer-toggle-display
                     org-roam-find-file
                     org-roam-graph
                     org-roam-insert
                     org-roam-switch-to-buffer
                     org-roam-dailies-date
                     org-roam-dailies-today
                     org-roam-dailies-tomorrow
                     org-roam-dailies-yesterday)
          :after (org emacsql-sqlite)
          :hook (after-init . org-roam-mode)
          :ensure t
          :custom
          (org-roam-graph-viewer "emacsclient")
          (org-notes "/home/pe/documents/roam")
          (org-directory org-notes)
          (deft-directory org-notes)
          (notdeft-directories `(,org-notes))
          (org-roam-directory org-notes)
          (org-roam-db-update-method 'immediate)
          (org-ref-bibtex-completion-add-keywords-field nil) ;; make sure that some org helm ref package loads correctly when executing (org-roam-db-build-cache t)
          :config
          (require 'org-roam-protocol)

          (defvar gb/set-tag-config-list '(("ROAM_TAGS" . " ") ("FILETAGS" . ":"))
            "list of pairs, describing org attribute and tag separator to be used")

          (defun gb/set-tags-in-org-roam-file ()
            "set the following tags on the first org header and on all attributes listed in 'gb/set-tag-config-list'"
            (interactive)
            (when buffer-read-only
              (read-only-mode -1))
            (save-excursion
              (goto-char (point-min))
              (org-next-visible-heading 1)
              (let* ((existing-tags (org-get-tags))
                     (tag-string-list (s-split " " (read-string "tags (space separated): " (s-join " " existing-tags)))))
                (-map (lambda (config)
                        (let ((attr (car config))
                              (sep (cdr config)))
                          (goto-char (point-min))
                          (when (re-search-forward (format "#\\+%s:" attr) nil t)
                            (when (< (point) (line-end-position)) (kill-line))
                            (unless (equal sep " ") (insert " "))
                            (insert sep)
                            (insert (s-join sep tag-string-list))
                            (unless (equal sep " ") (insert sep)))))
                      gb/set-tag-config-list)
                (goto-char (point-min))
                (org-next-visible-heading 1)
                (org-set-tags tag-string-list))))

          (defun gb/org-roam-open-entry-visibility ()
            "setup initial org visibility in org-roam entries"
            (interactive)
            (org-hide-block-all)
            (org-babel-result-hide-all)
            (add-fira-code-symbol-keywords)
            (org-display-inline-images)
            (org-content)
            (progn (setq current-prefix-arg '(16))(call-interactively 'org-latex-preview))
            (save-excursion
              (goto-char (point-min))
              (org-next-visible-heading 1)
              (org-show-entry)))
          :bind (:map org-roam-mode-map
                      (("C-c n l" . org-roam)
                       ("C-c n f" . org-roam-find-file)
                       ("C-c n g" . org-roam-show-graph))
                      :map org-mode-map
                      (("C-c n i" . org-roam-insert)
                       ("C-c n t" . gb/set-tags-in-org-roam-file))))

        (use-package org-roam-server
          :commands (org-roam-server-mode)
          :custom (org-roam-server-port "8092")
          :ensure t
          :config
          (defun gb/org-roam-server ()
            "start org roam server mode and open browser"
            (interactive)
            (unless org-roam-server-mode
              (org-roam-server-mode 1))
            (browse-url "http://localhost:8092")))

        (use-package company-org-roam
          :after (org-roam company)
          :ensure t
          :config
          :config (add-to-list 'company-backends 'company-org-roam))))

    ;; failed with "run-hooks: Symbols value as variable is void: bibtex-completion-find-note-functions"

    ;; (use-package org-ref-helm-bibtex
    ;;   :ensure t)
    ;; (use-package org-roam-bibtex
    ;;   :after (org-roam)
    ;;   :hook (org-roam-mode . org-roam-bibtex-mode)
    ;;   :ensure t
    ;;   :config
    ;;   (setq bibtex-completion-display-formats nil)
    ;;   (setq org-roam-bibtex-preformat-keywords
    ;;         '("=key=" "title" "url" "file" "author-or-editor" "keywords"))
    ;;   (setq orb-templates
    ;;         '(("r" "ref" plain (function org-roam-capture--get-point)
    ;;            ""
    ;;            :file-name "${slug}"
    ;;            :head "#+TITLE: ${=key=}: ${title}\n#+ROAM_KEY: ${ref}

    ;; - tags ::
    ;; - keywords :: ${keywords}

    ;; \n* ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :URL: ${url}\n  :AUTHOR: ${author-or-editor}\n  :NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n  :NOTER_PAGE: \n  :END:\n\n"

    ;;            :unnarrowed t))))
  #+end_src
* emacs-mini-frame
  #+begin_src emacs-lisp
    (use-package mini-frame
      :load-path "~/repo/emacs-mini-frame"
      :config
      (custom-set-variables
       '(mini-frame-internal-border-color "#654865")
       '(mini-frame-completions-show-parameters
         '((top . 0.7)
           (width . 0.5)
           (left . 0.5)
           (height . 1)
           (background-color . "#251825")
           (border-color . "#654865")))
       '(mini-frame-show-parameters
         '((top . 0.7)
           (width . 0.5)
           (left . 0.5)
           (height . 1)
           (background-color . "#251825")
           (border-color . "#654865"))))

      (setq mini-frame--command-adjusted-show-parameters
            '((counsel-buffer-or-recentf (width . 0.8))
              (gb/ivy--program-select-and-run (width . 0.2))
              (ivy-switch-buffer (width  . 0.8))
              (counsel-git-grep (width .  0.8))
              (counsel-ag-popup-search-here (width . 0.9))
              (counsel-ag-popup-search (width . 0.9))))

      (setq mini-frame-ignore-commands
            '(
              helm-for-files
              helm-M-x
              helm-find-files
              helm-mini
              helm-imenu-anywhere
              byte-compile-file
              gb/helm-bufler-switch
              helm-org-in-buffer-headings
              helm-imenu-anywhere
              gb/exwm-program-select
              embark-keymap-help
              embark--completing-read-map
              ignore
              calcDigit-start
              helm-swoop
              helm-switch-shell
              helm-multi-swoop
              helm-multi-swoop-all
              helm-cmd-t
              helm-cmd-t-repos))
      (when (eq gb/completion-framework 'ivy)
        (mini-frame-mode 1)))
  #+end_src
* share2computer
  - allow easy download from handy by simply starting 'M-x share2computer'
  #+begin_src emacs-lisp
    (use-package share2computer
      :ensure t
      :commands (share2computer)
      :custom (share2computer-default-directory "~/Downloads/"))
  #+end_src
* EVAL bufler see
  #+begin_src emacs-lisp
    (use-package bufler
      :ensure t)
    (when (eq gb/completion-framework 'helm)
      (use-package helm-bufler
        :bind (("H-b" . #'gb/helm-bufler-switch))
        :init (defun gb/helm-bufler-switch () "" (interactive)(helm :sources '(helm-bufler-source))) ;; assign this to a command
        :ensure t))
  #+end_src
* EVAL vlc (not really useful => disabled)
  #+begin_src emacs-lisp :tangle no
    (use-package vlc
      :ensure-system-package vlc
      :ensure t)
  #+end_src
* maxima
  #+begin_src emacs-lisp
    (setq maxima-elisp-loadpath
          (if running-nixos
              (s-concat (s-trim (shell-command-to-string "dirname $(readlink -f $(command -v maxima))")) "/../share/emacs/site-lisp")
            "~/.emacs.d/additionals/maxima"))

    (use-package imaxima
      :load-path maxima-elisp-loadpath
      :commands (imaxima)
      :ensure-system-package maxima
      :custom (imaxima-use-maxima-mode-flag t)
              (imaxima-fnt-size "LARGE"))
    (use-package imath
      :load-path maxima-elisp-loadpath)
    (use-package maxima
      :load-path maxima-elisp-loadpath)



    ;; see http://maxima.sourceforge.net/documentation.html
    ;;     http://maxima.sourceforge.net/docs/manual/maxima.html#SEC_Top
    ;; http://www.hippasus.com/resources/symmath/maximacalc.html

    ;; start by M-x imaxima
  #+end_src
* EVAL ctrlf
  #+begin_src emacs-lisp
    (use-package ctrlf
      :ensure t)
  #+end_src
* EVAL prescient
  #+begin_src emacs-lisp
    (use-package prescient
      :ensure t
      :custom
      (prescient-aggressive-file-save t)
      (prescient-persist-mode t))
  #+end_src
* EVAL company-prescient
  #+begin_src emacs-lisp
    (use-package company-prescient
      :ensure t
      :config
      (company-prescient-mode 1))
  #+end_src
* EVAL selectrum (disabled, ivy seems to be ok)
  - idea: additional install selectrum-prescient
  #+begin_src emacs-lisp :tangle no
    (when (eq gb/completion-framework 'selectrum)
      (use-package selectrum
        :ensure t
        :bind (:map selectrum-minibuffer-map
               ("<tab>"    . selectrum-insert-current-candidate))
        :config
        (setq selectrum-num-candidates-displayed 45)
        (selectrum-mode 1))

      (use-package selectrum-prescient
        :ensure t
        :config
        (selectrum-prescient-mode 1)))
  #+end_src
* EVAL smtpmail-async
  #+begin_src emacs-lisp
    (use-package smtpmail-async
      :load-path "~/.emacs.d/additionals/"
      :config
      (defun gb/gnus-mail-send-switch-to-safe-sync ()
        "set to save sync mode of sending gnu mails"
        (interactive)
        (setq send-mail-function 'smtpmail-multi-send-it
              message-send-mail-function 'smtpmail-multi-send-it)
        (message "Now sending with safe (but blocking) sync"))

      (defun gb/gnus-mail-send-switch-to-unsafe-async ()
        "set to unsafe async mode - might fail, if additional certificate acknowledgment is necessary"
        (interactive)
        (setq send-mail-function 'async-smtpmail-send-it
              message-send-mail-function 'async-smtpmail-send-it)
        (message "Now sending with unsafe (but non-blocking) async, switch back with M-x gb/gnus-mail-send-switch-to-safe-sync")))
  #+end_src
* EVAL scanner (disabled, device not detected, scanimage cannot use -o parameter)
  #+begin_src emacs-lisp :tangle no
    (use-package scanner
      :commands (scanner-scan-image scanner-scan-document)
      ;; :ensure-system-package (sane-backends sane-frontends)
      :config
      (setq scanner-resolution '(:image 300 :doc 300) )
      (setq scanner-scan-mode '(:image "Color" :doc "Gray"))
      (setq scanner-tesseract-languages '("eng" "deu"))
      (setq scanner-tesseract-program (s-trim (shell-command-to-string (s-concat "readlink -f " (s-trim  (shell-command-to-string "command -v tesseract"))))))
      (setq scanner-tesseract-configdir (s-concat (s-trim (shell-command-to-string (s-concat "dirname " scanner-tesseract-program))) "/../share/tessdata/configs")))
  #+end_src
* EVAL cpu-sos - send invisible buffers SIGSTOP (to prevent background processing)
  - activate this minor mode on e.g. web browsers that do lots of background processing
  - this mode will then send signals to limit cpu usage if that buffer is not visible
  #+begin_src emacs-lisp
    (use-package cpu-sos)
  #+end_src
* EVAL bookmark+
  - for more info, see https://www.emacswiki.org/emacs/BookmarkPlus
  #+begin_src emacs-lisp
    (setq gb/bookmarkplus-dir "~/.emacs.d/custom/bookmark-plus/")

    (defun gb/update-bookmark-plus ()
      "since bookmark+ is no longer on melpa, manual update is needed"
      (interactive)
      (let ((bookmarkplus-dir gb/bookmarkplus-dir)
            (emacswiki-base "https://www.emacswiki.org/emacs/download/")
            (bookmark-files '("bookmark+.el" "bookmark+-mac.el" "bookmark+-bmu.el" "bookmark+-key.el" "bookmark+-lit.el" "bookmark+-1.el")))
        (require 'url)
        (add-to-list 'load-path bookmarkplus-dir)
        (make-directory bookmarkplus-dir t)
        (mapcar (lambda (arg)
                  (let ((local-file (concat bookmarkplus-dir arg)))
                    (url-copy-file (concat emacswiki-base arg) local-file t)))
                bookmark-files)
        (byte-recompile-directory bookmarkplus-dir 0)
        (require 'bookmark+)))

    (unless (file-exists-p (format "%sbookmark+.el" gb/bookmarkplus-dir))
      (gb/update-bookmark-plus))

    (use-package bookmark+
      :load-path gb/bookmarkplus-dir)
  #+end_src
* EVAL keypression
  - patched function keypression--push-string, self-insert evaluates to: (note check on org-self-insert-command)
    #+begin_src emacs-lisp :tangle no
      (self-insert (and keypression-concat-self-insert
                                 (or (eq this-command 'self-insert-command)
                                     (eq this-command 'org-self-insert-command))))
    #+end_src
  - replaced substitution keypression--key-to-string: (note check on org-self-insert-command)
    #+begin_src emacs-lisp :tangle no
      (defsubst keypression--keys-to-string (keys)
        (if (bound-and-true-p gb/within-password-entry)
            "*"
          (if (and (or (eq this-command 'self-insert-command)
                    (eq this-command 'org-self-insert-command))
                 (string= keys " "))
              keypression-space-substitution-string
            (key-description keys))))
    #+end_src
  #+begin_src emacs-lisp
    (use-package keypression
      :commands (keypression-mode)
      :ensure t
      :init
      (defvar gb/within-password-entry nil)
      :config

      (setq keypression-use-child-frame t)
      (setq frame-resize-pixelwise nil)

      (defun gb/set-password-entry-flag (&rest args)
        (setq gb/within-password-entry t))
      (advice-add 'read-passwd :before #'gb/set-password-entry-flag)

      ;; leaving the mini buffer undos that
      (defun gb/unset-password-entry-flag (&rest args)
          (setq gb/within-password-entry nil))
      (advice-add 'exit-minibuffer :before #'gb/unset-password-entry-flag)

      ;; (advice-remove 'comint-send-invisible #'gb/around-send-invisible)

      (setq keypression-use-child-frame nil
            keypression-foreground-for-light-mode "#606060"
            keypression-frame-background-mode 'light ;; use black for frame background of keys pressed
            keypression-fade-out-delay 3.0
            keypression-frame-justify 'keypression-right-justified
            keypression-frames-maxnum 7 ;; max 7 frames to show the last 7 keystrokes
            keypression-cast-command-name t
            keypression-cast-command-name-format "%s  %s"
            keypression-combine-same-keystrokes t
            keypression-concat-self-insert t
            keypression-x-offset 8
            keypression-y-offset 40
            keypression-font-face-attribute '(:width normal :height 200 :weight bold)))
  #+end_src
* EVAl languagetool (see language-tool in other config) collides with langtool!, currently disabled
  #+begin_src emacs-lisp :tangle no
    (use-package languagetool)
  #+end_src
* EVAL shrface - allows browsing the web via org-mode like rendering
  - see https://github.com/chenyanming/shrface
  #+begin_src emacs-lisp
    (use-package shrface
      :config
      (shrface-basic) ; enable shrfaces, must be called before loading eww/dash-docs/nov.el
      (shrface-trial) ; enable shrface experimental face(s), must be called before loading eww/dash-docs/nov.el
      (setq shrface-href-versatile t) ; enable versatile URL faces support
                                            ; (http/https/ftp/file/mailto/other), if
                                            ; `shrface-href-versatile' is nil, default
                                            ; face `shrface-href-face' would be used.
      (setq shrface-toggle-bullets nil) ; Set t if you do not like headline bullets

      ;; eww support
      (with-eval-after-load 'eww
        (add-hook 'eww-after-render-hook 'shrface-mode)
        (define-key eww-mode-map (kbd "<tab>") 'org-cycle)
        (define-key eww-mode-map (kbd "S-<tab>") 'org-shifttab)
        (define-key eww-mode-map (kbd "C-t") 'shrface-toggle-bullets)
        (define-key eww-mode-map (kbd "C-c C-n") 'shrface-next-headline)
        (define-key eww-mode-map (kbd "C-c C-p") 'shrface-previous-headline)
        (define-key eww-mode-map (kbd "C-i") 'shrface-links-counsel) ; or 'shrface-links-helm
        (define-key eww-mode-map (kbd "C-o") 'shrface-headline-counsel))

      ;; nov support
      (with-eval-after-load 'nov
        (setq nov-shr-rendering-functions '((img . nov-render-img) (title . nov-render-title))) ; reset nov-shr-rendering-functions, in case of the list get bigger and bigger
        (setq nov-shr-rendering-functions (append nov-shr-rendering-functions shr-external-rendering-functions))
        (add-hook 'nov-mode-hook 'shrface-mode))

      ;; mu4e support
      (with-eval-after-load 'mu4e
        (add-hook 'mu4e-view-mode-hook 'shrface-mode)))
  #+end_src
* file grep and replace
  #+begin_src emacs-lisp
    (when (eq gb/completion-framework 'helm)
      (use-package helm-ag
        :commands (helm-ag)
        :ensure t))
    (use-package wgrep
       :ensure t)
    (use-package wgrep-ag
      :ensure t)
    (when (eq gb/completion-framework 'helm)
      (use-package wgrep-helm
        :ensure t))
  #+end_src
* scratch comment (insert eval s-expr into scratch buffer as comment)
  #+begin_src emacs-lisp
    (use-package scratch-comment
      :bind ("C-x M-e" . scratch-comment-eval-sexp)
      :ensure t)
  #+end_src
* EVAL journalctl-mode
  #+begin_src emacs-lisp
    (use-package journalctl-mode
      :ensure t
      :commands (journalctl))
  #+end_src
* EVAL format-all
  - format a very large number of different programming language using external tools
  - ~format-all-mode~ will format automatically on save
  #+begin_src emacs-lisp
    (use-package format-all
      :commands (format-all-buffer)
      :ensure t)
  #+end_src
* EVAL compy - adjust programs via patterns
  - use the current selection as input template for pattern matching and transformation
  - see https://comby.dev/
  #+begin_src emacs-lisp
    (use-package comby
      :commands (comby)
      :ensure t)
  #+end_src
* EVAL disk-usage - show disk usage in dired like mode
  #+begin_src emacs-lisp
    (use-package disk-usage
      :ensure t
      :commands (disk-usage))
  #+end_src
* EVAL dired-narrow - narrow list of files in dired mode
  - narrow using "/", revert narrow mode using "g"
  #+begin_src emacs-lisp
    (use-package dired-narrow
      :ensure t
      :bind (:map dired-mode-map (("/" . dired-narrow))))
  #+end_src
* helm-icons - show icons in helm selection
  - see https://github.com/yyoncho/helm-icons
  #+begin_src emacs-lisp
    (when (eq gb/completion-framework 'helm)
      (use-package helm-icons
        :ensure t
        :config (helm-icons-enable)))
  #+end_src
* EVAL ob-mermaid - allow diagram generation via mermaid (javascript lib md->png)
  - install mermaid via ~npm install -g mermaid.cli --no-save~
  - see https://mermaid-js.github.io/mermaid/#/
  #+begin_src emacs-lisp
    (use-package ob-mermaid
      :ensure t
      :config (setq ob-mermaid-cli-path (executable-find "mmdc")))
  #+end_src
* EVAL agda
  - installed agda via ~nix-env -iA nixos.haskellPackages.Agda~
  - there now is an alternative to the prepackaged agda mode, its called agda2-mode (on melpa)
  #+begin_src emacs-lisp
    (if (executable-find "agda-mode")
        (load-file (let ((coding-system-for-read 'utf-8))
                     (shell-command-to-string "agda-mode locate")))
      (message "WARNING: agda-mode not found"))
    (setq agda2-backend "GHC")

    (setq auto-mode-alist
          (append
           '(("\\.agda\\'" . agda2-mode)
             ("\\.lagda.md\\'" . agda2-mode))
           auto-mode-alist))

    (cond
     ((eq gb/theme-mode 'light) nil) ;; TODO complete
     (t (progn
          (--each '((agda2-highlight-datatype-face ((t (:foreground "light blue"))))
                    (agda2-highlight-primitive-type-face ((t (:foreground "light blue"))))
                    (agda2-highlight-operator-face ((t (:foreground "light blue"))))
                    (agda2-highlight-function-face ((t (:foreground "light blue"))))
                    (agda2-highlight-primitive-face ((t (:foreground "light blue")))))
            (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))
  #+end_src
* EVAL grugru - rotate thing at point dependent on mode through list of items defined
  - see https://github.com/ROCKTAKEY/grugru
  #+begin_src emacs-lisp
    (use-package grugru
      :ensure t
      :commands (grugru grugru-edit)
      :bind (("H-." . grugru))
      :config
      (grugru-default-setup)
      (grugru-edit-load))
  #+end_src
* EVAL ess - statistics package for emacs
  #+begin_src emacs-lisp
    (use-package ess
      :config (require 'ess-r-mode))
  #+end_src
* fragtog - replace latex fragments with graphics, entering the original text cursor moves over the graphics
  - see https://github.com/io12/org-fragtog
  #+begin_src emacs-lisp
    (use-package org-fragtog
      :ensure t
      :hook (org-mode . org-fragtog-mode))
  #+end_src
* EVAL notate - indentation aware of prettified symbols (disabled, does not work out of the box)
  - see https://github.com/ekaschalk/notate
  #+begin_src emacs-lisp :tangle no
    (when (file-exists-p "~/.emacs.d/additionals/notate/nt.el")
      (use-package smartparens
        :ensure t)
      (use-package nt-dev
        :load-path "~/.emacs.d/additionals/notate"))
  #+end_src

* beginend - jump to the right beginning / end, depending on the mode
  #+begin_src emacs-lisp
    (use-package beginend
      :ensure t
      :config (beginend-global-mode))
  #+end_src
* scratch - open scratch buffer in the same mode as the current buffer
  #+begin_src emacs-lisp
    (use-package scratch
      :ensure t
      :bind ("s-x" . scratch)
      :config (add-hook 'scratch-create-buffer-hook #'gb/scratch-insert-comment)
      :init
      (defun gb/scratch-insert-comment ()
        ""
        (interactive)
        (goto-char (point-min))
        (insert "scratchpad")
        (mark-whole-buffer)
        (comment-dwim nil)
        (goto-char (point-max))
        (insert "\n")))
  #+end_src
* EVAL esup - emacs startup profiling
  #+begin_src emacs-lisp
    (use-package esup
      :ensure t
      :commands (esup))
  #+end_src
* EVAL org-padding - define padding for each org mode heading level
  #+begin_src emacs-lisp
    (use-package org-padding
      :load-path "~/.emacs.d/additionals/"
      :config
      ;; (remove-hook 'org-mode-hook #'org-padding-mode)
      (setq org-padding-block-begin-line-padding '(2.0 . nil))
      (setq org-padding-block-end-line-padding '(nil . 1.0))
      (setq org-padding-heading-padding-alist
            '((4.0 . 1.5) (3.0 . 0.5) (3.0 . 0.5) (3.0 . 0.5) (2.5 . 0.5) (2.0 . 0.5) (1.5 . 0.5) (0.5 . 0.5)))
      )
  #+end_src
* EVAL find-file-rg - use ripgrep for find file in projects (can be configured e.g. in ~.ignore~ or ~.gitignore~ files)
  #+begin_src emacs-lisp
    (use-package find-file-rg
      :ensure t
      :bind (("C-s-f" . find-file-rg)))
  #+end_src
* EVAL eshell-syntax-highlighting
  - provide syntax hightlighting in the eshell
  #+begin_src emacs-lisp
    (use-package eshell-syntax-highlighting
      :after esh-mode
      :demand t
      :config (eshell-syntax-highlighting-global-mode +1))
  #+end_src
* EVAL smeargle - hightlight source depending on age of git changes
  - see https://github.com/emacsorphanage/smeargle
  #+begin_src emacs-lisp
    (use-package smeargle
      :ensure t
      :commands (smeargle smeargle-commits smeargle-clear)
      :config
      (custom-set-variables
       '(smeargle-colors '((older-than-1day   . "grey20")
                           (older-than-3day   . "grey18")
                           (older-than-1week  . "grey16")
                           (older-than-2week  . "grey14")
                           (older-than-1month . "grey12")
                           (older-than-3month . "grey10")
                           (older-than-6month . "grey8")
                           (older-than-1year . "grey6"))))
      (custom-set-variables
       '(smeargle-age-colors '((0 . nil)
                               (1 . "grey80")
                               (2 . "grey70")
                               (3 . "grey60")
                               (4 . "grey50")
                               (5 . "grey40")
                               (6 . "grey30")
                               (7 . "grey20")
                               (8 . "grey10"))))

      (bind-key "C-c v g" #'smeargle)
      (bind-key "C-c v c" #'smeargle-commits)
      (bind-key "C-c v k" #'smeargle-clear))
  #+end_src
* TODO EVAL git-messenger - popup last commit information for line (uses popup should use posframe)
  - see https://github.com/emacsorphanage/git-messenger
  #+begin_src emacs-lisp
    (use-package git-messenger
      :ensure t
      :bind (("C-c v p" . gb/git-messenger:popup-message)
             :map git-messenger-map
             ("m" . gb/git-messenger:popup-message))
      :custom (git-messenger:use-magit-popup nil "Use magit-show-commit for showing status/diff commands")
      :init
      (defun gb/git-messenger:popup-message ()
        (interactive)
        (let* ((vcs (git-messenger:find-vcs))
               (file (buffer-file-name (buffer-base-buffer)))
               (line (line-number-at-pos))
               (commit-info (git-messenger:commit-info-at-line vcs file line))
               (commit-id (car commit-info))
               (author (cdr commit-info))
               (msg (git-messenger:commit-message vcs commit-id))
               (popuped-message (if (git-messenger:show-detail-p commit-id)
                                    (git-messenger:format-detail vcs commit-id author msg)
                                  (cl-case vcs
                                    (git msg)
                                    (svn (if (string= commit-id "-")
                                             msg
                                           (git-messenger:svn-message msg)))
                                    (hg msg)))))
          (setq git-messenger:vcs vcs
                git-messenger:last-message popuped-message
                git-messenger:last-commit-id commit-id)
          (let (finish)
            (run-hook-with-args 'git-messenger:before-popup-hook popuped-message)
            ;;(pos-tip-show "some")
            (let (key-read)
              (loop-until (eq key-read ?q)
                (posframe-show "* git messenger *" :string msg)
                (setq key-read (read-key "[q]uit")))
              (posframe-delete-all)))
          (run-hook-with-args 'git-messenger:after-popup-hook popuped-message))))
  #+end_src
* gitconfig-mode - mode to edit git config files
  - see https://github.com/magit/git-modes
  #+begin_src emacs-lisp
    (use-package gitconfig-mode
      :ensure t)
  #+end_src
* EVAL yascroll - yet another scroll bar mode
  - see https://github.com/emacsorphanage/yascroll
  #+begin_src emacs-lisp
    (use-package yascroll
      :ensure t
      :config
      (setq yascroll:delay-to-hide 0.75)
      (setq yascroll:disabled-modes '(image-mode))
      ;; (global-yascroll-bar-mode) ;; seems to eat lots of memory during scrolling
      )
  #+end_src
* EVAL quickrun - run (out of babel) code blocks of different languages
  - https://github.com/emacsorphanage/quickrun
  #+begin_src emacs-lisp
    (use-package quickrun
      :commands (quickrun
                 quickrun-region
                 quickrun-with-arg
                 quickrun-shell
                 quickrun-compile-only
                 quickrun-replace-region
                 quickrun-autorun-mode
                 helm-quickrun
                 anything-quickrun)
      :ensure t)
  #+end_src
* EVAL git grep
  #+begin_src emacs-lisp
    (use-package git-grep
      :commands (git-grep git-grep-repo)
      :bind (("C-c g g" . git-grep)
             ("C-c g r" . git-grep-repo)))
  #+end_src
* EVAL google-translate
  #+begin_src emacs-lisp
    (use-package google-translate
      :ensure t
      :bind (("H-h l" . google-translate-at-point)
             ("H-h h" . gb/translate-at-point-eng-ger))
      :init
      (defun gb/translate-at-point-eng-ger ()
        "translate region or word at point english->geman"
        (interactive)
        (google-translate-translate
         "en" "de"
         (if (use-region-p)
             (buffer-substring-no-properties (region-beginning) (region-end))
           (or (and (setq bounds (bounds-of-thing-at-point 'word))
                 (buffer-substring-no-properties (car bounds) (cdr bounds)))
              (error "No word at point."))))))
  #+end_src
* EVAL dir-treeview
  - patched function ~dir-treeview-get-control~ to return dir-treeview-file-control in case of file node
    #+begin_src emacs-lisp :tangle no
      (defun dir-treeview-get-control (node)
        "Return the control symbol for NODE.
      If NODE represents a directory, `dir-treeview-folded-dir-control' or
      `dir-treeview-expanded-dir-control' is returned depending on whether the
      directory is folded or not.  Otherwise, nil (meaning: no control) is returned."
        (if (dir-treeview-directory-p node)
            (if (treeview-node-folded-p node) dir-treeview-folded-dir-control
              dir-treeview-expanded-dir-control)
          dir-treeview-file-control))
    #+end_src
  - open via ~dir-treeview~
  #+begin_src emacs-lisp
    (use-package dir-treeview
      :commands (dir-treeview)
      :config
      (load-theme 'dir-treeview-pleasant t)
      (custom-set-variables
       '(dir-treeview-control-margin-left "")
       '(dir-treeview-control-margin-right "")
       '(dir-treeview-dir-label-margin-left "")
       '(dir-treeview-expanded-dir-control "- ")
       '(dir-treeview-file-control "  ")
       '(dir-treeview-file-icon "")
       '(dir-treeview-file-label-margin-left "")
       '(dir-treeview-folded-dir-control "+ ")
       '(dir-treeview-icon-margin-left "")
       '(dir-treeview-icon-margin-right " ")
       '(dir-treeview-indent-last-unit "   ")
       '(dir-treeview-indent-unit "|  "))
      (setq dir-treeview-show-in-side-window t))
  #+end_src
* EVAL fill-page
  - activate via ~fill-page-mode~
  - automatically scroll so that no empty space is left at the bottom
  - interfers with beacon
  #+begin_src emacs-lisp
    (use-package fill-page
      :ensure t
      :config (fill-page-mode 1))
  #+end_src
* greenbar-mode
  - puts stripes on the comint output (shell output), making long lines a bit more tractable
  #+begin_src emacs-lisp
    (use-package greenbar
      :ensure t
      :config
      (add-hook 'comint-mode-hook #'greenbar-mode)
      (add-to-list 'greenbar-color-themes
                   (cons 'dark-gray-bar
                         (list
                          (if (eq (frame-parameter nil 'background-mode) 'dark)
                              "gray10" "gray70")
                          (face-background 'default))))
      (setq greenbar-background-colors 'dark-gray-bar)
      (setq greenbar-lines-per-bar 3))
  #+end_src
* EVAL continuous scroll mode (disabled, no scroll end detection, not working out of the box)
  #+begin_src emacs-lisp :tangle no
    (use-package pdf-continuous-scroll-mode
      :load-path "~/repo/pdf-continuous-scroll-mode.el/"
      :config
      (add-hook 'pdf-view-mode-hook 'pdf-continuous-scroll-mode) ;; pdf-view-mode-hook
      (setq pdf-view-have-image-mode-pixel-vscroll nil))

  #+end_src
* eimp (internal)
  #+begin_src emacs-lisp
    (use-package eimp
      :ensure t
      :config
      (setq gb/image-scale 1.0)
      (bind-key "<left>" #'image-backward-hscroll eimp-minor-mode-map)
      (bind-key "<right>" #'image-forward-hscroll eimp-minor-mode-map)
      (bind-key "<down>" #'image-next-line eimp-minor-mode-map)
      (bind-key "<up>" #'image-previous-line eimp-minor-mode-map)
      (bind-key "+" #'(lambda () (interactive) (setq gb/image-scale (+ 0.25 gb/image-scale)) (image-transform-set-scale gb/image-scale)) eimp-minor-mode-map)
      (bind-key "-" #'(lambda () (interactive) (setq gb/image-scale (- gb/image-scale 0.25)) (image-transform-set-scale gb/image-scale)) eimp-minor-mode-map)
      (bind-key "0" #'(lambda () (interactive) (setq gb/image-scale 1.0) (image-transform-set-scale gb/image-scale)) eimp-minor-mode-map)
      (bind-key "2" #'(lambda () (interactive) (setq gb/image-scale 2.0) (image-transform-set-scale gb/image-scale)) eimp-minor-mode-map))
  #+end_src
* delve - org
  - see https://github.com/publicimageltd/delve
  - provides a alternative view on
    - links, backlinks, date last modified, date the link established on, tag usage
    - format is: <modification> <icon> ( <tags-of-zettel> ) <n-incoming-links> <zettel-title> <m-outgoing-links>
  #+begin_src emacs-lisp
    (use-package lister
      :load-path "~/repo/lister")
    (use-package delve
      :load-path "~/repo/delve/"
      :commands (delve-open-or-select)
      :bind (:map delve-mode-map
                  ("C-l" . #'recenter-top-bottom))
      :config
       (use-package delve-minor-mode
        :config
        (add-hook 'org-mode-hook #'delve-minor-mode-maybe-activate)))
  #+end_src
* EVAL hardhat - make files r/o that should not be editable
  #+begin_src emacs-lisp
    (use-package hardhat
      :ensure t
      :config

      (--each '("org-roam\\.db\\'"
                "\\.sqlite\\'")
        (push it hardhat-basename-protected-regexps))

      (--each `(,(regexp-quote " * generated by Xtext"))
        (push it hardhat-bof-content-protected-regexps))

      (--each '("^/nix/store/")
        (push it hardhat-fullpath-protected-regexps))

      (global-hardhat-mode 1))
  #+end_src
* EVAL refine - interative list value editing
  #+begin_src emacs-lisp
    (use-package refine
      :ensure t
      :commands (refine))
  #+end_src
* EVAL key-assist - provide an improved C-h m, additionally program own cheatsheets
  - see [[https://github.com/Boruch-Baum/emacs-key-assist][here]]
  #+begin_src emacs-lisp
    (use-package key-assist
      :ensure t
      :commands (key-assist))
  #+end_src
* EVAL gcmh - gc magic hack, defer gc to idle times
  - works alright, seems to interfer with some other package though, which then uses up to 30s blocking emacs
    one method needed adjust to make idle gc not go over 10s idle time
  - seems to be fixed by setting the max idle time to 10s, never longer even in auto mode!
  #+begin_src emacs-lisp
    (use-package gcmh
      :load-path "~/repo/gcmh/"
      :demand t
      :custom
      (gcmh-verbose t)
      (gcmh-idle-delay 'auto)
      :config (gcmh-mode 1))
  #+end_src
* EVAL regexp-expand - show regular expression at point expanded
  - see [[https://github.com/danielmartin/regexp-expand][here]]
  - move cursor in reg ex, execute ~M-x regexp-expand~, inspect regex, press ~q~ to leave expansion
  #+begin_src emacs-lisp
    (use-package xr
      :ensure t)

    (use-package regexp-expand
      :load-path "~/repo/regexp-expand"
      :commands (regexp-expand))
  #+end_src
* EVAL rec-mode - show rec files (human readable db)
  - see [[https://www.gnu.org/software/recutils/][here]]
  #+begin_src emacs-lisp
    (use-package rec-mode
      :ensure t)
  #+end_src
* EVAL diredc - dired commander (midnight commander)
  #+begin_src emacs-lisp
    (use-package diredc
      :load-path "~/repo/emacs-diredc"
      :commands (diredc))
  #+end_src
* backup duplicity support
  #+begin_src emacs-lisp
    (defun gb/backup-log-open ()
      "open the backup log"
      (interactive)
      (let ((buf (generate-new-buffer "backup log")))
        (with-current-buffer buf
          (switch-to-buffer buf)
          (setq buffer-offer-save nil)
          (text-mode)
          (shell-command "journalctl --user-unit backup-drive.service --since -2w" (current-buffer))
          (end-of-buffer)
          (read-only-mode 1))))

    (defun gb/backup-collection-status ()
      "try to read the duplicity collections from backup medium"
      (interactive)
      (let ((buf (generate-new-buffer "collection status")))
        (with-current-buffer buf
          (switch-to-buffer buf)
          (setq buffer-offer-save nil)
          (text-mode)
          (shell-command "duplicity-backup.sh collection-status" (current-buffer))
          (end-of-buffer)
          (read-only-mode 1))))
  #+end_src
* org-roam-stack
  #+begin_src emacs-lisp
    (use-package org-roam-stack
      :load-path "~/repo/org-roam-stack/"
      :custom (org-roam-stack--link-adjustments t)
      (org-roam-stack--open-ro t))
  #+end_src
* proced
  #+begin_src emacs-lisp
    (use-package proced
      :config
      (custom-set-variables
       '(proced-auto-update-flag t)
       '(proced-format (quote long))
       ))
  #+end_src
* tramp
  #+begin_src emacs-lisp
    (use-package tramp-term
      :ensure t
      :commands (tramp-term))
  #+end_src
* provide battery warning
  #+begin_src emacs-lisp
    (when (and (package-installed-p 'alert)
             (executable-find "upower"))

      (setq gb/battery-id "/org/freedesktop/UPower/devices/battery_BAT0")

      (defun gb/battery-discharging-p ()
        "is the battery currently in discharging mode?"
        (not (string-empty-p (s-trim (shell-command-to-string (format  "upower -i %s | grep \"state:[ \t]*discharging\"" gb/battery-id))))))

      (defun gb/battery-charging-p ()
        "is the battery currently in charging mode?"
        (not (string-empty-p (s-trim (shell-command-to-string (format "upower -i %s | grep \"state:[ \t]*charging\"" gb/battery-id))))))

      (defun gb/battery-level-get ()
        "get the current level or charge in percent"
        (let ((bat-info (s-trim (shell-command-to-string (format "upower -i %s | grep 'percentage:'" gb/battery-id)))))
          (when (string-match "[^0-9]*\\([0-9]*\\)%" bat-info)
            (string-to-number (match-string 1 bat-info)))))

      (setq gb/battery-timed-shutdown-run nil)
      (setq gb/battery-alert-warning-given nil)
      (setq gb/battery-shutdown-warning-given nil)

      (defun gb/battery-level-check-and-report ()
        (when (gb/battery-charging-p)
          (setq gb/battery-timed-shutdown-run nil)
          (setq gb/battery-alert-warning-given nil)
          (setq gb/battery-shutdown-warning-given nil))
        (when (gb/battery-discharging-p)
          (let ((level (gb/battery-level-get)))
            (cond ((<= level 4)
                   (message "shutting down ...")
                   (gb/shutdown--immediately))
                  ((and (<= level 6) (not gb/battery-timed-shutdown-run))
                   (progn
                     (alert "Running low on power.\nAutomatic shutdown will be run in 30 seconds.\nCan be stopped with M-x list-timers." :severity 'high :title (format "BATTERY VERY LOW (%i perc)" level))
                     (setq gb/battery-timed-shutdown-run t)
                     (message "shutting down ...")
                     (run-at-time 30 nil #'gb/shutdown--immediately)))
                  ((and (< level 10) (not gb/battery-shutdown-warning-given) (not gb/battery-timed-shutdown-run))
                   (progn
                     (alert "Please shutdown (or recharge).\nAutomatic shutdown will be run on 4 percent." :severity 'high :title (format "Battery WARNING (%i perc)" level))
                     (setq gb/battery-shutdown-warning-given t)
                     (gb/shutdown)))
                  ((and (< level 15) (not gb/battery-alert-warning-given) (not gb/battery-shutdown-warning-given) (not gb/battery-timed-shutdown-run))
                   (progn
                     (alert "Please shutdown (or recharge).\nAutomatic shutdown will be run on 4 percent." :severity 'high :title (format "Battery warning (%i perc)" level))
                     (setq gb/battery-alert-warning-given t)))
                  ((>= level 15)
                   (progn
                     (setq gb/battery-alert-warning-given nil)
                     (setq gb/battery-shutdown-warning-given nil)
                     (setq gb/battery-timed-shutdown-run nil)))))))

      (run-at-time t 100 #'gb/battery-level-check-and-report))
  #+end_src

* valign - better table alignment in org-mode and markdown
  - see https://github.com/casouri/valign
  #+begin_src emacs-lisp
    (use-package valign
      :load-path "~/repo/valign"
      :hook (org-mode . valign-mode)
      :config (setq valign-fancy-bar t))
  #+end_src
* org-tree-slide-pause
  #+begin_src emacs-lisp
    (use-package org-tree-slide-pauses
      :load-path "~/repo/org-tree-slide-pauses")
  #+end_src
* EVAL embark - provide context sensitive menu
  - see https://github.com/oantolin/embark
  #+begin_src emacs-lisp
    (use-package embark
      :ensure t
      :bind (("H-<SPC>" . embark-act)))
  #+end_src
* TODO udisksctl - make package of this
  #+begin_src emacs-lisp
    (defvar gb/udisksctl--ignore-devices '("nvme0n1") "list of devices to ignore")

    (defun gb/udisksctl--info (blk-device)
      (s-trim (shell-command-to-string (format "udisksctl info -b %s" blk-device))))

    (defun gb/udisksctl--get-devices ()
      (-filter (lambda (device-desc) (when-let ((device (--last (not (string-empty-p it)) (s-split " " device-desc))))
                                  (not (-contains? gb/udisksctl--ignore-devices device))))
               (s-split "\n" (s-trim (shell-command-to-string (format "udisksctl  status | tail -n +3"))))))

    (defun gb/udisksctl--completing-read-blk-device ()
      (if-let ((devices (gb/udisksctl--get-devices)))
          (s-concat "/dev/" (--last (not (string-empty-p it)) (s-split " " (completing-read "Device: " devices nil t))))
        (message "no device found")
        nil))

    (defun gb/udisksctl--unpower-device (device)
      ""
      (message (s-trim (shell-command-to-string (format "udisksctl power-off -b %s" device)))))

    (defun gb/udisksctl--unpower ()
      (interactive)
      (when-let ((device (gb/udisksctl--completing-read-blk-device)))
        (gb/udisksctl--unpower-device device)))

    (defun gb/udisksctl--get-mounts (device)
      (s-split "\n" (s-trim (shell-command-to-string (format  "mount | grep -e '^%s'" device)))))

    (defun gb/udisksctl--completing-read-mount (device)
      (--first (not (string-empty-p it)) (s-split " " (completing-read "Mounts: " (gb/udisksctl--get-mounts device) nil t))))

    (defun gb/udisksctl--unmount-mount (mount)
      (message (s-trim (shell-command-to-string (format "udisksctl unmount -b %s" mount)))))

    (defun gb/udisksctl--unmount ()
      (interactive)
      (when-let ((device (gb/udisksctl--completing-read-blk-device)))
        (when-let ((mount (gb/udisksctl--completing-read-mount device)))
           (gb/udisksctl--unmount-mount mount))))
  #+end_src
* show-font-mode - shows the font under cursor in the mode line
  - mode needs to be (re)setted by switching workspaces
  #+begin_src emacs-lisp
    (use-package show-font-mode
      :commands (show-font-mode)
      :ensure t)
  #+end_src
* EVAL - good-scroll - uses pixel scroll to provide more smooth scrolling behaviour (see https://github.com/io12/good-scroll.el)
  #+begin_src emacs-lisp
    (use-package good-scroll
      :ensure t)
  #+end_src
* EVAL - transient-posframe -  posframe to show transient
  #+begin_src emacs-lisp
    (use-package transient-posframe
      :ensure t
      :config
      (custom-set-faces '(transient-posframe-border ((t (:inherit default :background "#5a205a")))))
      (transient-posframe-mode 1)
      :custom (transient-posframe-border-width 2)
              (transient-posframe-min-height 25)
              (transient-posframe-min-width 120)
              (transient-posframe-poshandler #'posframe-poshandler-frame-bottom-center))
  #+end_src
* EVAL - counsel-ag-popup - Interactive search with counsel-ag
  #+begin_src emacs-lisp
    (use-package counsel-ag-popup
      :ensure t
      :commands (counsel-ag-popup))
  #+end_src
* EVAL - org-tag-beautify - replace (some) tags with icons
  #+begin_src emacs-lisp
    (use-package org-tag-beautify
      :ensure t
      :config (org-tag-beautify-mode 1))
  #+end_src
* EVAL - fdupes - find duplicates in dired
  - needs installation of fdupes (e.g. nix-env -iA nixos.fdupes)
  #+begin_src emacs-lisp
    (use-package find-dupes-dired
      :ensure t
      :custom (find-dupes-dired-ls-option '("-q | grep -v -e '^$' | xargs -d \"\\n\" ls -dilsbUN" . "-dilsbUN")))
  #+end_src
* EVAL iscroll - Smooth scrolling over images
  #+begin_src emacs-lisp
    (use-package iscroll
      :ensure t
      :config (iscroll-mode 1))
  #+end_src
* EVAL ytdious - Query / Preview YouTube via Invidious
  #+begin_src emacs-lisp
    (use-package ytdious
      :ensure t
      :commands (ytdious)
      :bind (:map ytdious-mode-map
                  ("y" . #'ytdious-watch)
                  ("<return>" . #'ytdious-watch)
                  ("x" . #'ytdious-download-2mp3))
      :custom (ytdious-invidious-api-url "https://invidious.namazso.eu")
      :config
      (defun ytdious-download-2mp3 ()
        "Download video at point and extract mp3"
        (interactive)
        (let* ((video (ytdious-get-current-video))
               (id    (ytdious-video-id-fun video)))
          (start-process-shell-command "ytdious dl" nil (format "youtube-dl -x --audio-format mp3 %s" id))
          (message (format "Downloading/Transcoding (%s)..." id))))
      (defun ytdious-watch ()
        "Stream video at point in mpv."
        (interactive)
        (let* ((video (ytdious-get-current-video))
               (id    (ytdious-video-id-fun video)))
          (start-process "ytdious mpv" nil
                         "mpv"
                         (concat "https://www.youtube.com/watch?v=" id " --ytdl-format=bestvideo[height<=?720]+bestaudio/best")))
        (message "Starting streaming...")))
  #+end_src
* EVAL edebug-inline-result - display edebug results inline (via posframe)
  #+begin_src emacs-lisp
    (use-package edebug-inline-result
      :ensure t
      :defer t
      :custom (edebug-inline-result-backend 'posframe)
      :hook (edebug-mode . edebug-inline-result-mode))
  #+end_src
* project configuration
  #+begin_src emacs-lisp
    (use-package project
      :ensure t
      :config
      (setq vc-handled-backends
    ;;=> (RCS CVS SVN SCCS SRC Bzr Git Hg)
     '(Git)))
  #+end_src
* compilation mode configuration
  #+begin_src emacs-lisp
    (use-package compile
      :init
      ;; Shut up compile saves
      (setq compilation-ask-about-save nil)
      ;; Don't save *anything*
      (setq compilation-save-buffers-predicate '(lambda () nil))
      :hook (comint-mode . compilation-shell-minor-mode)
      :config
      ;; Add NodeJS error format
      (setq compilation-error-regexp-alist-alist
            ;; Tip: M-x re-builder to test this out
            (cons '(node "^[  ]+at \\(?:[^\(\n]+ \(\\)?\\([a-zA-Z\.0-9_/-]+\\):\\([0-9]+\\):\\([0-9]+\\)\)?$"
                               1 ;; file
                               2 ;; line
                               3 ;; column
                               )
                  compilation-error-regexp-alist-alist))
      (setq compilation-error-regexp-alist
            (cons 'node compilation-error-regexp-alist)))
  #+end_src
* INTERESTING
** blog/presentation
  - org-present using a cell phone to switch pages
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package org-present-remote
     :after org)
   #+END_SRC
  - easy-jekyll (tool to manage jekyll blogs)
  - grip-mode (preview md files as github does)
  - ox-hugo
    - export org markdown to hugo blog entries
    - see [[https://github.com/kaushalmodi/ox-hugo][here]]
  - gif-screencast
    - allow screencast recording single gif for each action, combining them into animated gifs thereafter
    - https://github.com/Ambrevar/emacs-gif-screencast
** completion/templates
  - company suggest (propose sentence completion based on wikionary or google)
    - company-suggest, see [[https://github.com/juergenhoetzel/company-suggest][here]]
  - project-abbrev - project specific abbrev expansion
  - company-posframe (company in separate frame, alternative to company box?)
  - company-nginx (allow for company completion of nginx files)
  - company-prescient (ordering and filtering of candidates)
  - company-fuzzy (fuzzy matchin in company mode)
  - helm-fuzzy
  - compdef define completion local to a mode (not globally like company does)
    - see  https://gitlab.com/jjzmajic/compdef
  - selectrum - emacs selection and narrowing framework
  - company-manually - manually provide completio entries
  - company-ledger - fuzzy autocomplete for ledger and friends
  - helm-org-ql - Helm commands for org-ql
  - company-maxima - maxima integration
** cloud
   - axe - aws interface (directly through aws api, no aws-cli)
** configuration
  - use-package-ensure-system-package
    - require binaries / packages of the underlying system for installation of package
    - if provided with installation script might even execute the appropriate installation
    - see [[https://github.com/waymondo/use-package-ensure-system-package][here]]
  - leaf - drop in replacement for use-package
  - leaf-manager - Configure manager for leaf based init.el
  - leaf-tree - Interactive side-bar feature for init.el using leaf
  - leaf-convert - convert configuration to leaf syntax (automatic optimization)
** db
   - sqlite3 - Direct access to the core SQLite3 API
** document
  - latexdiff (diff between two latex files)
  - texfrag
    - allow tex fragments preview in (almost) any buffer
    - see [[https://github.com/TobiasZawada/texfrag][here]]
  - org-latex-impatient - show tex preview while you type (using javascript lib) currently in orgmode only (https://github.com/yangsheng6810/org-latex-impatient)
  - virtual-auto-fill (line break without modifying underlying buffer)
  - auctex-cluttex - interface to ClutTeX is a program to automatically process your LaTeX document. If necessary, it re-runs (La)TeX program to resolve cross-references and everything.
  - bibtex-completion - bibtex completion backend
  - lsp-latex - lsp mode client for LaTeX
  - ob-latex-as-png - org babel functions for latex-as-png
  - toc-mode - extract table of contents from a pdf document that has it printed, but not explicit within the pdf structure itself, clean it
    up and add the cleaned up toc to the pdf (such that it is usable). see https://github.com/dalanicolai/toc-mode
  - org-inline-pdf - inline preview of pdf (similiar to inlined images) in org mode, needs pdf2svg installed
** (function) selection
  - helm-selected
  - helm-org - Helm for org headlines and keywords completion
  - consult-flycheck - Provides the command `consult-flycheck'
  - consult-selectrum - Selectrum integration for Consult
** git
  - magit-tbdiff (diffing extension for magit)
    - git-tbdiff is a git extension that allows diffs for topic branches
    - tbdiff shows the differences between two versions of a patch series, or more generally, two sets of commits (ignoring merges). To do
      this in a meaningful way, it tries to find a good correspondence between commits in the two versions (see Algorithm below), and then
      shows the difference between the pairs found. It also copes with removal and addition of commits.
    - see [[https://github.com/magit/magit-tbdiff][link]]
  - git-msg-prefix, provide prefix for commit messages based on previous commit messages and the like
  - multi-magit
  - github-notifier: display github notifications in modeline (see [[https://github.com/xuchunyang/github-notifier.el][here]])
  - magit-circleci: magit extension for circleci (see last build result ...)
  - magit-vcsh, vcsh (vcsh allow separation of .git tree and actual files -> easy way to add file, like dot files from your home directory
    into a version controlled repository)
  - gerrit - interface to gerrit, code reviews
  - magit-patch-changelog: Generate a patch according to emacs-mirror/CONTRIBUTE
** java/kotlin/scala
  - lsp-javacomp
    - lsp support for java using [[https://github.com/tigersoldier/JavaComp][java-comp]]
  - organize imports java
    - needs configuration, see here https://github.com/jcs090218/organize-imports-java
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package organize-imports-java)
    #+END_SRC
  - taskrunner - Retrieve build system/taskrunner tasks  (e.g. gradle tasks ....)
  - lsp-metals - lsp for scala (metals)
  - jmt-mode - java mode tamed provides better syntax highlighting (interesting to find out about syntax highlighting, too)
** languages
  - karma test runner integration (upbo)
  - jest-test-mode - running node.js tests using jest
  - rustic (major mode for rust)
  - ccls (c++ language server for lsp ui), see here https://github.com/MaskRay/emacs-ccls
  - dash-docs
  - ob-elm
  - ob-graphql
  - flycheck-indent
  - ob-deno - Babel Functions for Javascript/TypeScript with Deno
*** javascript/json/yaml/html
    - indium (java script development environment) [[https://github.com/NicolasPetton/Indium][home page]]
    - lsp-html - lsp frontend for html serving
    - html5-schema (html5 support for nXML)
    - json-reformatter-jq
    - yaml-imode
      - This package enhances the imenu support in yaml-mode
      - requires ruby >= 2.5
          #+BEGIN_SRC emacs-lisp :tangle no
          (use-package yaml-imode)
          #+END_SRC
** lisp/racket/haskell/clojure
  - ob-clojure-literate
  - highlight-function-calls
    - highlight functions in lisp specially
  - attrap - Attrap! provides a command to attempt to fix the flycheck error at point.(haskell and elisp currently)
  - nix-haskell-mode
  - elpl (emacs lisp repl)
  - elisp-depmap - Generate an elisp dependency map in graphviz
  - clojure-essential-ref - the essential reference
  - clojure-essential-ref-nov - browse the essential ref offline (via epub)
** mail
   - autocrypt - automatically encrypts and distributes encrypted emails (usable in gnus) https://git.sr.ht/~zge/autocrypt
** navigation
  - smart-jump (smart go to definition)
  - all-the-icons-ibuffer (icons in ibuffers)
  - bufler - buffer selection based on groups (see )
  - atl-long-lines - Turn off truncate-lines when the line is long
** org
  - org-wild-notifier, customizable notifier for org agenda entries (global or per entry)
  - orca (org-capture configuration)
    - allows filing based on the url it was captured from into special files/headers etc.
  - org-send-ebook
    - send an ebook link to an external device (ebook reader) from org mode
  - org-mind-map
    - translate an org file into a mind map
  - org-super-agenda
    - see [[https://github.com/alphapapa/org-super-agenda][here]]
    - This package lets you "supercharge" your Org daily/weekly agenda. The idea is to group items into sections, rather than having them all
      in one big list.
    - lets you group agenda entries based on tags, regex on title, todo status etc.
  - org-projectile-helm
    - This package aims to provide an easy interface to creating per project org-mode TODO headings.
  - org-category-capture
    - This package aims to provide an easy interface to creating per project org-mode TODO headings.
      #+BEGIN_SRC emacs-lisp
      (use-package org-category-capture
        :after ( org))
      #+END_SRC
  - treefactor - organize org-headers and dired files of org files (see https://treefactor-docs.nfshost.com)
  - doct: Declarative Org capture templates
  - walkman: write http requests within org
  - org-pdftools - links to documents in pdfmode
  - org-roam - Roam Research replica with Org-mode, allows something like zettelkasten  (see
    https://blog.jethro.dev/posts/introducing_org_roam/)
  - org-roam-bibtex - Connector between Org-roam, BibTeX-completion, and Org-ref
  - org-treeusage - Examine the usage of org headings in a tree-like manner
  - org-noter-pdftools - integration of org-noter and pdftools
  - ox-leanpub - Export Org documents to Leanpub book format
  - org-ml - Functional Org Mode API
  - orgstrap - allow elisp usage in org source blocks more freely (less cryptic header configuration) see https://github.com/tgbugs/orgstrap)
** os/system
  - network-watch (allows hooks to run when network is goiing down/up)
  - scp (use scp to transfer files)
  - kubel: Emacs extension for controlling Kubernetes with limited permissions. (https://github.com/abrochard/kubel)
  - archive-rpm
    - provide an interface for rpm package open (extends archive-mode)
  - counsel-tramp
  - proced-narrow - Live-narrowing of search results for proced.
  - syslog-mode - mode to view syslogs (filter etc.)
  - nix-env-install - install packages through nix-env (currently npm packages only), see https://github.com/akirak/nix-env-install
  - kubel - inspect pods in kubernetes (with limited rights)
  - nixpkgs-fmt - format nix using nixpkgs-fmt
  - modern-sh - shell script edit mode, see https://github.com/damon-kwok/modern-sh
** project
   - treemacs-persp - integration of perspective into treemacs buffer visibility
   - browse-at-remote - Open github/gitlab/bitbucket/stash/gist/phab/sourcehut page from Emacs
   - org-runbook - define project commands (build run clean ...) project specific in some org file with command completion ...
   - flycheck-projectile - get all errors within a project (see https://github.com/nbfalcon/flycheck-projectile)
** searching/replace
  - zop-to-char (more options during zap to char)
  - mark-thing-at (mark certain things at point, e.g. words, s-exp, url, filename ...)
  - deadgrep - ripgrep front end
  - projectile-codesearch (use codesearch to query projects)
  - isearch-project
  - color-rg: search and refactoring tool based in ripgrep (see [[https://github.com/manateelazycat/color-rg][here]])
  - helm-fd: like helm find, using fd instead
  - ctrlf - search in emacs
** utilities
  - shrink-path: do fish like reduciton of paths (e.g. for modeline)
  - counsel-jq: interactively use jq on json buffer
  - vlc - videoLAN VLC Media Player Control
  - transient-dwim - supposed to be useful to explore keybindings/functions in a major mode
  - smart-input-source - Switch input source smartly
  - docopt - a docopt implementation in elisp (docopt allows generating cli options for bash scripts)
  - leo - Interface for dict.leo.org
  - diredc - Extensions for dired (acting similar to midnight commander)
** windowmanager/x-integration
  - edwin (dynamic window manager)
  - zoom
    - keeps balanced windows, zooming the one currently having the focus
  - windswap - swap window buffers (with left, right, up, down)
  - windmove - move to window (left, right, up, down)
** unsorted
  - flycheck-indicator - A fancy mode line indicator for `flycheck-mode'
  - helm-tail - tailing of several sources
  - template-overlays - overlays for template regions
  - sx (elaborate stack exchange interface for emacs)
  - powerthesaurus - interface to powerthesaurus.org
  - pickle - Major mode for editing cucumber gherkin files.
  - aio - async execution and await for elisp (lambda and functions)
  - live-preview
  - howdoyou - A stackoverflow and its sisters' sites reader
  - calc-at-point - do calculations on selections or at point
  - basic-ide - c64 basic ide that allows for basic dev and execution in vice (see https://gitlab.com/sasanidas/emacs-c64-basic-ide)
  - pspp-mode - edit pspp files
** development
   - navigel (develop modes based on tablist more efficiently)
   - helm-taskrunner (select from tasks the build system of the current project provides (e.g. gradle tasks)) https://github.com/emacs-taskrunner/helm-taskrunner
   - eldev (gradle for elisp projects)
   - verb (organize http requests from emacs to ...)
   - with-shell-interpreter (helper for cli apis)
   - auth-source-xoauth2 - Integrate auth-source with XOAUTH2
   - prettier - code formatting with prettier (see prettier-js)
   - lsp-focus - use focus in lsp (reduce to some region, rest is grayed out)
   - origami - code folding (several languages, default = indentlevel)
     see https://github.com/gregsexton/origami.el
   - tree-sitter - tooling to make language toolin within emacs more tractable (see https://github.com/ubolonton/emacs-tree-sitter)
** graphics
   - vega-view - allow preview of vega graphics (graphics described by json), see https://vega.github.io/vega/ and https://github.com/applied-science/emacs-vega-view
** system
   - arduino-cli-mode - Arduino-CLI command wrapper
   - etc-sudoers-mode - Edit Sudo security policies
   - ednc - Emacs Desktop Notification Center (pure lisp implementation of freedesktop org notification system, replacement for dunst)
** ui
   - modern-fringes - Replaces default fringe bitmaps with better looking ones
   - simple-modeline -
* discarded
** dired-posframe (disabled) preview is disrupting
   #+begin_src emacs-lisp :tangle no
     (use-package dired-posframe
       :ensure t
       :disabled t
       :commands (dired-posframe-show dired-posframe-mode)
       :bind (:map dired-mode-map
                   ("C-c t p" . #'dired-posframe-mode)
                   ("C-c p" . #'dired-posframe-show)))
   #+end_src
** pixel-scroll (pixel wise scrolling) currently disabled (part of emacs 27)
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; currently on the load path by .emacs.d/additionals
     (if (not  (file-exists-p "~/.emacs.d/additionals/pixel-scroll.el"))
         (message "WARNING: pixel-scroll.el does not exist, it will not be installed")
       (progn
         (message "OK: pixel-scroll.el locally found, will be installed")
         (use-package pixel-scroll
           :load-path "~/.emacs.d/additionals/"
           :after ( sublimity-scroll)
           :config
           (progn
             (require 'sublimity-scroll)
             ;; redefine pre command for speed up of n no pre commands are present
             (defun sublimity--pre-command ()
               (save-excursion (goto-char (window-start)) (setq sublimity--prev-lin (string-to-number (format-mode-line "%l"))))
               (setq
                     sublimity--prev-col (window-hscroll)
                     sublimity--prev-buf (current-buffer)
                     sublimity--prev-wnd (selected-window)
                     sublimity--prepared t)
               (sublimity--run-hooks sublimity--pre-command-functions))
             (setq gb/modeline-enabled t)
             (defun gb/modeline ()
               ""
               (if gb/modeline-enabled
                   (spaceline-ml-main)))
             (defun sublimity-scroll--vscroll-effect (lins)
               (save-excursion
                 (let* ((pixel-scroll-last-line (and (not (equal major-mode 'org-mode)) (> (abs lins) 5)))
                        (speeds (sublimity-scroll--gen-speeds (if pixel-scroll-last-line (* (signum lins) (- (abs lins) 1)) lins)))
                        (cursor-type (and (not sublimity-scroll-hide-cursor) cursor-type)))
                   ;; (message (concat "scroll: " (number-to-string lins) ", at: " (number-to-string (nlinum--line-number-at-pos))))
                   ;; (message pixel-scroll-last-line)
                   (sublimity-scroll--vscroll (- lins))
                   (setq gb/modeline-enabled nil)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (gb/modeline)))))
                   (dolist (speed speeds)
                     (progn
                       (sublimity-scroll--vscroll speed)
                       (force-window-update (selected-window))
                       (redisplay)))
                   (setq gb/modeline-enabled t)
                   ;; (if pixel-scroll-last-line (setq mode-line-format '("%e" (:eval (spaceline-ml-main)))))
                   (if  (and (> lins 0) pixel-scroll-last-line)
                       (progn (pixel-scroll-up 1)))
                   (if (and (< lins 0) pixel-scroll-last-line)
                       (pixel-scroll-down 1))
                   )))))))
   #+END_SRC
** pinentry (obsolete as of emacs 26)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package pinentry
       :config
       (progn
         (pinentry-start)
         ))
   #+END_SRC
** company quickhelp - produces help popups for company candidates (replaced by company-box)
   #+BEGIN_SRC emacs-lisp :tangle no
       (use-package company-quickhelp
         ;; :ensure t
         :after (company-box)
         :config
         (progn
           ;; (company-quickhelp-mode 1)
           (setq company-quickhelp-use-propertized-text t)
           (setq company-quickhelp-max-lines 30)
           ;; (setq company-quickhelp-color-background "gray80")
           ;; (setq company-quickhelp-color-foreground "black")
           ))
   #+END_SRC
** company quickhelp in terminal - company-quickhelp is replaced by company-box
   #+begin_src emacs-lisp :tangle no
     (use-package company-quickhelp-terminal
       :ensure t
       :config
       (company-quickhelp-terminal-mode 1))
   #+end_src
** exwm-surf
   - allows to control surf within exwm
   - surf is a webkit based browser that works as embedded x application and can thus be embedded into emacs directly
   - don't need this, since chromium or firefox can be directly embedded into exwm
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point 4")
#+END_SRC
** ranger (file browser/previewer, using dired)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ranger
       :ensure t
       :config
       (setq ranger-hide-cursor nil))
   #+END_SRC
** diminish (hide minor modes from spaceline mode line) (obsolete now)
   - its still a dependency of use-package, so its still loaded
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package diminish) ;; actual diminishing of modes is executed after init is completely run (see end of file)
   #+END_SRC
** use line if no region (deactive, currently evaluating easy-kill)
   uses a line as region if no active region is selected and a
   command is issued that works on regions
   (not: M-% replace)
   (yes: C-w)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package whole-line-or-region
     :config
     (whole-line-or-region-mode 1))
   #+END_SRC
** mode icons (disabled)
   - no longer used, since spaceline brings its own set of mode icons
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package mode-icons
     :disabled t
     :config
     (mode-icons-mode)
     (setq mode-icons-desaturate-inactive t)
     (setq mode-icons-desaturate-active nil)
     (setq mode-icons-grayscale-transform t))

     ;; (defvar minor-mode-icon-list
     ;;   '((paredit-mode paredit-mode-hook "~/icons/clojure-icon-small.png" png))
     ;;   "define a list of icon replacements for the given minor modes")

     ;; (defun install-minor-mode-icons (rem-minor-mode-icon-list)
     ;;   (let* ((minor-mode-icon (car rem-minor-mode-icon-list))
     ;;          (rem-minor-mode-icon-list-new (cdr rem-minor-mode-icon-list)))
     ;;     (if minor-mode-icon
     ;;         (add-hook (nth 1 minor-mode-icon)
     ;;                   `(lambda ()
     ;;                      (let* ((mode-id (nth 0 ,minor-mode-icon))
     ;;                             (icon-path (nth 2 ,minor-mode-icon))
     ;;                             (icon-type (nth 3 ,minor-mode-icon))
     ;;                             (image-line `(image :type ,icon-type :file ,icon-path :ascent center :margin ( 3 . 0 )))
     ;;                             (minor-mode-element (assoc mode-id minor-mode-alist)))
     ;;                        (if (message "FORMATSTRING" &optional ARGS)inor-mode-element
     ;;                          (setf (cdr minor-mode-element) (list (propertize "dummy" 'display image-line))))))))
     ;;     (if rem-minor-mode-icon-list-new
     ;;         install-minor-mode-icons rem-minor-mode-icon-list-new)))

     ;; (install-minor-mode-icons minor-mode-icon-list)
 #+END_SRC
** fonts with ligatures (realized differently)
   - the following is not functional within (my) emacs => it is not tangled
     #+BEGIN_SRC emacs-lisp :tangle no

       ;; if font with ligatures is selected, define some font compositions
       (when (string= gb/default-font "Fira Code")
         (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
                        (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
                        (36 . ".\\(?:>\\)")
                        (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
                        (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                        (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
                        (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
                        (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                        (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
                        (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                        (48 . ".\\(?:x[a-zA-Z]\\)")
                        (58 . ".\\(?:::\\|[:=]\\)")
                        (59 . ".\\(?:;;\\|;\\)")
                        (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
                        (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                        (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                        (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
                        (91 . ".\\(?:]\\)")
                        (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                        (94 . ".\\(?:=\\)")
                        (119 . ".\\(?:ww\\)")
                        (123 . ".\\(?:-\\)")
                        (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                        (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
                        )
                      ))
           (dolist (char-regexp alist)
             (set-char-table-range composition-function-table (car char-regexp)
                                   `([,(cdr char-regexp) 0 font-shape-gstring])))))
     #+END_SRC
** major mode icons
   - does not work with spaceline (nor powerline)
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package xpm)
     (use-package major-mode-icons
       :after ( xpm)
       :config
       (progn
         (setq mode-line-end-spaces
               (quote ((:eval (major-mode-icons/show)))))
         (major-mode-icons-mode 1)))
   #+END_SRC
** helm-navi
   - does not work together with current org-mode and hide-pw
     (opening password file does not start folded, passwords are shown)
   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package outshine)
   (use-package navi-mode)
   (use-package outorg)
   (use-package helm-navi
     :after ( outshine navi-mode)
     :commands helm-navi helm-navi-headings)
   #+END_SRC
** smex
   - replaced by helm-M-x, a helm interface to M-x
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Enhances M-x to allow easier execution of commands. Provides
     ;; a filterable list of possible commands in the minibuffer
     ;; http://www.emacswiki.org/emacs/Smex
     (use-package smex
       :ensure t
       :disabled t
       :bind (("M-x" . smex))
       :config
       (progn
       (setq smex-save-file (concat user-emacs-directory ".smex-items"))
       (smex-initialize)))
   #+END_SRC
** helm-fuzzier (seems not to have any positive effect)
   #+begin_src emacs-lisp :tangle no
   (use-package helm-fuzzier
     :ensure t
     :config (helm-fuzzier-mode 1))
   #+end_src
** frog-jump-buffer, allows avy selection in popup frame  (discarded)
   #+begin_src emacs-lisp :tangle no
   (use-package frog-menu
     :load-path "~/.emacs.d/additionals/frog-menu/")
   (use-package frog-jump-buffer
     :load-path "~/.emacs.d/additionals/frog-jump-buffer/"
     :after frog-menu)
   #+end_src
** clear-text (mode that makes you use only the 1000 most common english words)
 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package clear-text
     :ensure t
     :commands clear-text-mode)
 #+END_SRC
** emacs maple minibuffer
   - collides with helm posframe and all the other posframe stuff
   #+begin_src emacs-lisp :tangle no
     (use-package maple-minibuffer
       :load-path "~/.emacs.d/additionals/emacs-maple-minibuffer"
       ;; :hook (after-init . maple-minibuffer-mode)
       :config
       (setq maple-minibuffer:position-type 'window-bottom-left
             maple-minibuffer:height nil
             maple-minibuffer:border-color "gray50"
             maple-minibuffer:width 100)

       ;; more custom parameters for frame
       (defun maple-minibuffer:parameters ()
         "Maple minibuffer parameters."
         `((height . ,(or maple-minibuffer:height 10))
           (width . ,(or maple-minibuffer:width (window-pixel-width)))
           (left-fringe . 5)
           (right-fringe . 5))))
   #+end_src
** common-header (put one shared modeline into a frame, collides with treemacs and dired side bar, disrupts doom modeline colors/fonts)
   - see https://github.com/Bad-ptr/common-header-mode-line.el
   #+begin_src emacs-lisp :tangle no
     (if (file-exists-p "~/.emacs.d/additionals/common-header-mode-line-0.5.6")
             (use-package common-header-mode-line
     ;;          :commands
               :load-path "~/.emacs.d/additionals/common-header-mode-line-0.5.6"
               :config
               (require 'per-frame-header-mode-line)
               (require 'per-window-header-mode-line)
               (setq per-frame-mode-line-window-side 'top)
               (common-mode-line-mode 0)))
   #+end_src
** atomic chrome - allow text edit are within browser to be edited with emacs
   - no longer needed, since exwm-edit is in use
   - M-x atomic-chrome-start-server must be started within emacs
   - atomic-chrome extension must be installed within chrome
   - when within a text area of the browser, press the atomic-chrome button in the button bar, evoila, you are no in an emacs buffer editing
     the text area with life update!
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package atomic-chrome
       :ensure t
       :config (atomic-chrome-start-server))
   #+END_SRC
#+BEGIN_SRC emacs-lisp
(report-elapsed "check point - atomic chrome")
#+END_SRC
** fantom theme - org mode colors were white (mostly)
   #+begin_src emacs-lisp :tangle no
     (use-package fantom-theme
       :ensure t
       :config
       (load-theme 'fantom-theme t))
   #+end_src
** sidebar and icons in terminal (additional icons)
   - install font-lock+ into additionals https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/font-lock%2B.el
   - install icons-in-terminal https://github.com/sebastiencs/icons-in-terminal#installation
   - install sidebar into additionals https://github.com/sebastiencs/sidebar.el
   - now on melpa: originally install frame-local into additionals https://github.com/sebastiencs/frame-local
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (and (file-exists-p "~/.emacs.d/additionals/font-lock+.el")
                (file-exists-p "~/.local/share/icons-in-terminal/icons-in-terminal.el")
                )
       (progn
         (use-package icons-in-terminal
           :after ( font-lock+)
           :load-path "~/.local/share/icons-in-terminal/")
         (when (file-exists-p "~/.emacs.d/additionals/sidebar.el/sidebar.el")
           (use-package ov)
           (use-package frame-local)
           ;; originally from here!
           ;; :load-path "~/.emacs.d/additionals/frame-local/"
           (use-package sidebar
             :after (projectile s dash dash-functional ov frame-local icons-in-terminal)
             :bind (("s-a" . gb/sidebar-toggle)
                    :map sidebar-mode-map
                    ("s-a" . sidebar-close))
             :load-path "~/.emacs.d/additionals/sidebar.el/"
             :config
             (defun sidebar-buffers-pre-command ()) ;; override default implementation
             (defun gb/sidebar-toggle ()
               ""
               (interactive)
               (if (sidebar-get-window t)
                   (sidebar-close)
                 (sidebar-open)))
             (custom-set-variables
              ;; '(sidebar-icon-powerline "")
              ;; '(sidebar-icon-modeline "")
              ;; '(sidebar-icon-header-end "")
              ;; '(sidebar-select-icon-right-header "")
              '(sidebar-mode-line-height 1.0)
              '(sidebar-width 50))
             (cond
              ((eq gb/theme-mode 'light) nil) ;; TODO complete
              (t (progn
                   (--each '((sidebar-primary-color ((t (:background "dark goldenrod" :foreground "black"))))
                             (sidebar-select-line ((t (:background "dark goldenrod" :foreground "black" :box nil))))
                             (sidebar-suffix-path-header ((t (:foreground "#404040")))))
                     (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it))))))))))
   #+END_SRC
** helm-selector - util functions for easy buffer selection - discarded: dwim behaviour is not what I want
   #+begin_src emacs-lisp :tangle no
     (use-package helm-selector
       :ensure t
       :config )
   #+end_src
* useful but discarded because of drawback that might be fixed
** magit-delta (disabled - speed degradation on large change sets)
   #+begin_src emacs-lisp :tangle no
     (use-package magit-delta
       :ensure t
       :config
       (setq magit-delta-default-light-theme "ansi-light")
       (setq magit-delta-default-dark-theme "Solarized (dark)") ;; "base16", "ansi-dark"
       (setq magit-delta-hide-plus-minus-markers nil)
       (magit-delta-mode))
   #+end_src
** (disabled: does not compile) vterm - better terminal emulation
   - installed ~cmake~, ~libvterm~ and ~libtool~ via nix-env
   #+begin_src emacs-lisp :tangle no
     (use-package vterm
       :commands (vterm))
   #+end_src
** ytel (youtube interface via invidous) [disabled, needs youtube-dl as extractor, too]
   #+begin_src emacs-lisp :tangle no
     (use-package ytel
       :config
       (defun ytel-watch ()
         "Stream video at point in mpv."
         (interactive)
         (let* ((video (ytel-get-current-video))
                (id    (ytel-video-id video)))
           (start-process "ytel cvlc" nil
                          "cvlc"
                          "--preferred-resolution" "720"
                          (concat "https://www.youtube.com/watch?v=" id)))
         (message "Starting streaming...")))
   #+end_src
** compass (interesting, but too many dependencies: docker, python ...)
  #+begin_src emacs-lisp :tangle no
    (use-package code-compass
      :load-path "~/repo/code-compass"
      ;; :requires diminish bind-key async dash f s simple-httpd
      )
  #+end_src
* finish - up
  #+BEGIN_SRC emacs-lisp
    (report-elapsed "enter finish - up")

    (require 'server)
    ;; start a server to allow reuse of this server when opening other files from within the os
    (unless (server-running-p)
      (server-start))
    ;; (maximize-frame)
    (gb/do-after-display-system-init
     ;; (toggle-frame-fullscreen)
     (ido-mode -1)
     (ido-unload-function)
     (when (eq gb/completion-framework 'ivy)
       (ivy-mode 1))
     (midnight-mode 1)
     (set-fringe-mode 10)
     (display-time-mode -1)
     ;; (eldoc-overlay-mode t)
     ;; for kuchen checks:
     ;; (add-hook 'buffer-list-update-hook #'gb/register-key-filter)
     ;; (add-hook 'magit-popup-mode-hook #'gb/un-register-key-filter)
     (cond
      ((eq gb/theme-mode 'light) nil) ;; TODO complete
      (t (progn
           (--each '((hl-line ((t (:background "gray18"))))
                     (highlight ((t (:background "gray18"))))
                     (region ((t (:background "gray24"))))
                     (font-lock-doc-face ((t (:foreground "gray52"))))
                     (font-lock-comment-face ((t (:foreground "gray50"))))
                     (font-lock-comment-delimiter-face ((t (:foreground "gray50"))))
                     (font-lock-string-face ((t (:foreground "#4080b0")))))
             (progn (add-to-list 'gb/list-of-faces-to-set it)(custom-set-faces it)))))))
    (setq gc-cons-threshold 80000000)
    (midnight-mode 1)
    ;; ;; set color of echo/mini buffer area (in some cases)
    ;; (add-hook 'minibuffer-setup-hook
    ;;       (lambda ()
    ;;         (make-local-variable 'face-remapping-alist)
    ;; ;;         (buffer-face-mode 1)
    ;; ;;         (setq buffer-face-mode-face '(:background "#241422"))
    ;;         (add-to-list 'face-remapping-alist '(default (:background "#241422")))))
    ;; (dolist (buf '(" *Echo Area 0*" " *Echo Area 1*" " *Minibuf-0*" " *Minibuf-1*"))
    ;;   (ignore-errors
    ;;     (when (get-buffer buf)
    ;;       (with-current-buffer (get-buffer buf)
    ;;         (make-local-variable 'face-remapping-alist)
    ;;         ;; (define-symbol-prop 'face-remapping-alist 'permanent-local t)
    ;;         (add-to-list 'face-remapping-alist '(default (:background "#241422")))))))
    ;; (set-face-background 'minibuffer-prompt "#241422")
    (report-elapsed "exit finish - up")
  #+END_SRC

# Local Variables:
# eval: (read-only-mode 1)
# eval: (flyspell-mode 0)
# eval: (org-hide-block-all)
# eval: (org-overview)
# End:
